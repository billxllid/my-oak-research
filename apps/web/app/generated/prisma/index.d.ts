
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Keyword
 * 
 */
export type Keyword = $Result.DefaultSelection<Prisma.$KeywordPayload>
/**
 * Model Proxy
 * 
 */
export type Proxy = $Result.DefaultSelection<Prisma.$ProxyPayload>
/**
 * Model Credential
 * 
 */
export type Credential = $Result.DefaultSelection<Prisma.$CredentialPayload>
/**
 * Model Source
 * 
 */
export type Source = $Result.DefaultSelection<Prisma.$SourcePayload>
/**
 * Model WebSourceConfig
 * 
 */
export type WebSourceConfig = $Result.DefaultSelection<Prisma.$WebSourceConfigPayload>
/**
 * Model DarknetSourceConfig
 * 
 */
export type DarknetSourceConfig = $Result.DefaultSelection<Prisma.$DarknetSourceConfigPayload>
/**
 * Model SearchEngineSourceConfig
 * 
 */
export type SearchEngineSourceConfig = $Result.DefaultSelection<Prisma.$SearchEngineSourceConfigPayload>
/**
 * Model SocialMediaSourceConfig
 * 
 */
export type SocialMediaSourceConfig = $Result.DefaultSelection<Prisma.$SocialMediaSourceConfigPayload>
/**
 * Model Query
 * 
 */
export type Query = $Result.DefaultSelection<Prisma.$QueryPayload>
/**
 * Model QueryRun
 * 
 */
export type QueryRun = $Result.DefaultSelection<Prisma.$QueryRunPayload>
/**
 * Model TaskEvent
 * 
 */
export type TaskEvent = $Result.DefaultSelection<Prisma.$TaskEventPayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model ContentKeyword
 * 
 */
export type ContentKeyword = $Result.DefaultSelection<Prisma.$ContentKeywordPayload>
/**
 * Model ContentEntity
 * 
 */
export type ContentEntity = $Result.DefaultSelection<Prisma.$ContentEntityPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model ReportTemplate
 * 
 */
export type ReportTemplate = $Result.DefaultSelection<Prisma.$ReportTemplatePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportMaterial
 * 
 */
export type ReportMaterial = $Result.DefaultSelection<Prisma.$ReportMaterialPayload>
/**
 * Model Knowledge
 * 
 */
export type Knowledge = $Result.DefaultSelection<Prisma.$KnowledgePayload>
/**
 * Model KnowledgeFile
 * 
 */
export type KnowledgeFile = $Result.DefaultSelection<Prisma.$KnowledgeFilePayload>
/**
 * Model KnowledgeChunk
 * 
 */
export type KnowledgeChunk = $Result.DefaultSelection<Prisma.$KnowledgeChunkPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SourceType: {
  WEB: 'WEB',
  DARKNET: 'DARKNET',
  SEARCH_ENGINE: 'SEARCH_ENGINE',
  SOCIAL_MEDIA: 'SOCIAL_MEDIA'
};

export type SourceType = (typeof SourceType)[keyof typeof SourceType]


export const CrawlerEngine: {
  FETCH: 'FETCH',
  CHEERIO: 'CHEERIO',
  PLAYWRIGHT: 'PLAYWRIGHT',
  PUPPETEER: 'PUPPETEER',
  CUSTOM: 'CUSTOM'
};

export type CrawlerEngine = (typeof CrawlerEngine)[keyof typeof CrawlerEngine]


export const ProxyType: {
  HTTP: 'HTTP',
  HTTPS: 'HTTPS',
  SOCKS4: 'SOCKS4',
  SOCKS5: 'SOCKS5',
  TOR: 'TOR'
};

export type ProxyType = (typeof ProxyType)[keyof typeof ProxyType]


export const SearchEngineKind: {
  GOOGLE: 'GOOGLE',
  BING: 'BING',
  DDG: 'DDG',
  SEARXNG: 'SEARXNG',
  CUSTOM: 'CUSTOM'
};

export type SearchEngineKind = (typeof SearchEngineKind)[keyof typeof SearchEngineKind]


export const SocialPlatform: {
  X: 'X',
  TELEGRAM: 'TELEGRAM',
  REDDIT: 'REDDIT'
};

export type SocialPlatform = (typeof SocialPlatform)[keyof typeof SocialPlatform]


export const QueryFrequency: {
  MANUAL: 'MANUAL',
  HOURLY: 'HOURLY',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  CRONTAB: 'CRONTAB'
};

export type QueryFrequency = (typeof QueryFrequency)[keyof typeof QueryFrequency]


export const TaskStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const ContentType: {
  Web: 'Web',
  Client: 'Client',
  Darknet: 'Darknet'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const MaterialSource: {
  FAVORITE: 'FAVORITE',
  KNOWLEDGE: 'KNOWLEDGE'
};

export type MaterialSource = (typeof MaterialSource)[keyof typeof MaterialSource]


export const ReportStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  PUBLISHED: 'PUBLISHED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]

}

export type SourceType = $Enums.SourceType

export const SourceType: typeof $Enums.SourceType

export type CrawlerEngine = $Enums.CrawlerEngine

export const CrawlerEngine: typeof $Enums.CrawlerEngine

export type ProxyType = $Enums.ProxyType

export const ProxyType: typeof $Enums.ProxyType

export type SearchEngineKind = $Enums.SearchEngineKind

export const SearchEngineKind: typeof $Enums.SearchEngineKind

export type SocialPlatform = $Enums.SocialPlatform

export const SocialPlatform: typeof $Enums.SocialPlatform

export type QueryFrequency = $Enums.QueryFrequency

export const QueryFrequency: typeof $Enums.QueryFrequency

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type MaterialSource = $Enums.MaterialSource

export const MaterialSource: typeof $Enums.MaterialSource

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categories
 * const categories = await prisma.category.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categories
   * const categories = await prisma.category.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keyword`: Exposes CRUD operations for the **Keyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keyword.findMany()
    * ```
    */
  get keyword(): Prisma.KeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxy`: Exposes CRUD operations for the **Proxy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proxies
    * const proxies = await prisma.proxy.findMany()
    * ```
    */
  get proxy(): Prisma.ProxyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **Credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.CredentialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.source`: Exposes CRUD operations for the **Source** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sources
    * const sources = await prisma.source.findMany()
    * ```
    */
  get source(): Prisma.SourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.webSourceConfig`: Exposes CRUD operations for the **WebSourceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebSourceConfigs
    * const webSourceConfigs = await prisma.webSourceConfig.findMany()
    * ```
    */
  get webSourceConfig(): Prisma.WebSourceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.darknetSourceConfig`: Exposes CRUD operations for the **DarknetSourceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DarknetSourceConfigs
    * const darknetSourceConfigs = await prisma.darknetSourceConfig.findMany()
    * ```
    */
  get darknetSourceConfig(): Prisma.DarknetSourceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchEngineSourceConfig`: Exposes CRUD operations for the **SearchEngineSourceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchEngineSourceConfigs
    * const searchEngineSourceConfigs = await prisma.searchEngineSourceConfig.findMany()
    * ```
    */
  get searchEngineSourceConfig(): Prisma.SearchEngineSourceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialMediaSourceConfig`: Exposes CRUD operations for the **SocialMediaSourceConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialMediaSourceConfigs
    * const socialMediaSourceConfigs = await prisma.socialMediaSourceConfig.findMany()
    * ```
    */
  get socialMediaSourceConfig(): Prisma.SocialMediaSourceConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.query`: Exposes CRUD operations for the **Query** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Queries
    * const queries = await prisma.query.findMany()
    * ```
    */
  get query(): Prisma.QueryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queryRun`: Exposes CRUD operations for the **QueryRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueryRuns
    * const queryRuns = await prisma.queryRun.findMany()
    * ```
    */
  get queryRun(): Prisma.QueryRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskEvent`: Exposes CRUD operations for the **TaskEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskEvents
    * const taskEvents = await prisma.taskEvent.findMany()
    * ```
    */
  get taskEvent(): Prisma.TaskEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentKeyword`: Exposes CRUD operations for the **ContentKeyword** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentKeywords
    * const contentKeywords = await prisma.contentKeyword.findMany()
    * ```
    */
  get contentKeyword(): Prisma.ContentKeywordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentEntity`: Exposes CRUD operations for the **ContentEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentEntities
    * const contentEntities = await prisma.contentEntity.findMany()
    * ```
    */
  get contentEntity(): Prisma.ContentEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportTemplate`: Exposes CRUD operations for the **ReportTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportTemplates
    * const reportTemplates = await prisma.reportTemplate.findMany()
    * ```
    */
  get reportTemplate(): Prisma.ReportTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportMaterial`: Exposes CRUD operations for the **ReportMaterial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportMaterials
    * const reportMaterials = await prisma.reportMaterial.findMany()
    * ```
    */
  get reportMaterial(): Prisma.ReportMaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledge`: Exposes CRUD operations for the **Knowledge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Knowledges
    * const knowledges = await prisma.knowledge.findMany()
    * ```
    */
  get knowledge(): Prisma.KnowledgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeFile`: Exposes CRUD operations for the **KnowledgeFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeFiles
    * const knowledgeFiles = await prisma.knowledgeFile.findMany()
    * ```
    */
  get knowledgeFile(): Prisma.KnowledgeFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeChunk`: Exposes CRUD operations for the **KnowledgeChunk** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeChunks
    * const knowledgeChunks = await prisma.knowledgeChunk.findMany()
    * ```
    */
  get knowledgeChunk(): Prisma.KnowledgeChunkDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Category: 'Category',
    Keyword: 'Keyword',
    Proxy: 'Proxy',
    Credential: 'Credential',
    Source: 'Source',
    WebSourceConfig: 'WebSourceConfig',
    DarknetSourceConfig: 'DarknetSourceConfig',
    SearchEngineSourceConfig: 'SearchEngineSourceConfig',
    SocialMediaSourceConfig: 'SocialMediaSourceConfig',
    Query: 'Query',
    QueryRun: 'QueryRun',
    TaskEvent: 'TaskEvent',
    Content: 'Content',
    ContentKeyword: 'ContentKeyword',
    ContentEntity: 'ContentEntity',
    Favorite: 'Favorite',
    ReportTemplate: 'ReportTemplate',
    Report: 'Report',
    ReportMaterial: 'ReportMaterial',
    Knowledge: 'Knowledge',
    KnowledgeFile: 'KnowledgeFile',
    KnowledgeChunk: 'KnowledgeChunk'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "category" | "keyword" | "proxy" | "credential" | "source" | "webSourceConfig" | "darknetSourceConfig" | "searchEngineSourceConfig" | "socialMediaSourceConfig" | "query" | "queryRun" | "taskEvent" | "content" | "contentKeyword" | "contentEntity" | "favorite" | "reportTemplate" | "report" | "reportMaterial" | "knowledge" | "knowledgeFile" | "knowledgeChunk"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Keyword: {
        payload: Prisma.$KeywordPayload<ExtArgs>
        fields: Prisma.KeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findFirst: {
            args: Prisma.KeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          findMany: {
            args: Prisma.KeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          create: {
            args: Prisma.KeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          createMany: {
            args: Prisma.KeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          delete: {
            args: Prisma.KeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          update: {
            args: Prisma.KeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          deleteMany: {
            args: Prisma.KeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>[]
          }
          upsert: {
            args: Prisma.KeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KeywordPayload>
          }
          aggregate: {
            args: Prisma.KeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeyword>
          }
          groupBy: {
            args: Prisma.KeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.KeywordCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordCountAggregateOutputType> | number
          }
        }
      }
      Proxy: {
        payload: Prisma.$ProxyPayload<ExtArgs>
        fields: Prisma.ProxyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          findFirst: {
            args: Prisma.ProxyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          findMany: {
            args: Prisma.ProxyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>[]
          }
          create: {
            args: Prisma.ProxyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          createMany: {
            args: Prisma.ProxyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>[]
          }
          delete: {
            args: Prisma.ProxyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          update: {
            args: Prisma.ProxyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          deleteMany: {
            args: Prisma.ProxyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>[]
          }
          upsert: {
            args: Prisma.ProxyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyPayload>
          }
          aggregate: {
            args: Prisma.ProxyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxy>
          }
          groupBy: {
            args: Prisma.ProxyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyCountAggregateOutputType> | number
          }
        }
      }
      Credential: {
        payload: Prisma.$CredentialPayload<ExtArgs>
        fields: Prisma.CredentialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CredentialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CredentialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findFirst: {
            args: Prisma.CredentialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CredentialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          findMany: {
            args: Prisma.CredentialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          create: {
            args: Prisma.CredentialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          createMany: {
            args: Prisma.CredentialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CredentialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          delete: {
            args: Prisma.CredentialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          update: {
            args: Prisma.CredentialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          deleteMany: {
            args: Prisma.CredentialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CredentialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CredentialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>[]
          }
          upsert: {
            args: Prisma.CredentialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CredentialPayload>
          }
          aggregate: {
            args: Prisma.CredentialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCredential>
          }
          groupBy: {
            args: Prisma.CredentialGroupByArgs<ExtArgs>
            result: $Utils.Optional<CredentialGroupByOutputType>[]
          }
          count: {
            args: Prisma.CredentialCountArgs<ExtArgs>
            result: $Utils.Optional<CredentialCountAggregateOutputType> | number
          }
        }
      }
      Source: {
        payload: Prisma.$SourcePayload<ExtArgs>
        fields: Prisma.SourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findFirst: {
            args: Prisma.SourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          findMany: {
            args: Prisma.SourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          create: {
            args: Prisma.SourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          createMany: {
            args: Prisma.SourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          delete: {
            args: Prisma.SourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          update: {
            args: Prisma.SourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          deleteMany: {
            args: Prisma.SourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>[]
          }
          upsert: {
            args: Prisma.SourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourcePayload>
          }
          aggregate: {
            args: Prisma.SourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSource>
          }
          groupBy: {
            args: Prisma.SourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceCountArgs<ExtArgs>
            result: $Utils.Optional<SourceCountAggregateOutputType> | number
          }
        }
      }
      WebSourceConfig: {
        payload: Prisma.$WebSourceConfigPayload<ExtArgs>
        fields: Prisma.WebSourceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebSourceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebSourceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          findFirst: {
            args: Prisma.WebSourceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebSourceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          findMany: {
            args: Prisma.WebSourceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>[]
          }
          create: {
            args: Prisma.WebSourceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          createMany: {
            args: Prisma.WebSourceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebSourceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>[]
          }
          delete: {
            args: Prisma.WebSourceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          update: {
            args: Prisma.WebSourceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          deleteMany: {
            args: Prisma.WebSourceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebSourceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WebSourceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>[]
          }
          upsert: {
            args: Prisma.WebSourceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebSourceConfigPayload>
          }
          aggregate: {
            args: Prisma.WebSourceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebSourceConfig>
          }
          groupBy: {
            args: Prisma.WebSourceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebSourceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebSourceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<WebSourceConfigCountAggregateOutputType> | number
          }
        }
      }
      DarknetSourceConfig: {
        payload: Prisma.$DarknetSourceConfigPayload<ExtArgs>
        fields: Prisma.DarknetSourceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DarknetSourceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DarknetSourceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          findFirst: {
            args: Prisma.DarknetSourceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DarknetSourceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          findMany: {
            args: Prisma.DarknetSourceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>[]
          }
          create: {
            args: Prisma.DarknetSourceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          createMany: {
            args: Prisma.DarknetSourceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DarknetSourceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>[]
          }
          delete: {
            args: Prisma.DarknetSourceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          update: {
            args: Prisma.DarknetSourceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          deleteMany: {
            args: Prisma.DarknetSourceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DarknetSourceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DarknetSourceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>[]
          }
          upsert: {
            args: Prisma.DarknetSourceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DarknetSourceConfigPayload>
          }
          aggregate: {
            args: Prisma.DarknetSourceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDarknetSourceConfig>
          }
          groupBy: {
            args: Prisma.DarknetSourceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<DarknetSourceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.DarknetSourceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<DarknetSourceConfigCountAggregateOutputType> | number
          }
        }
      }
      SearchEngineSourceConfig: {
        payload: Prisma.$SearchEngineSourceConfigPayload<ExtArgs>
        fields: Prisma.SearchEngineSourceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchEngineSourceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchEngineSourceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          findFirst: {
            args: Prisma.SearchEngineSourceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchEngineSourceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          findMany: {
            args: Prisma.SearchEngineSourceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>[]
          }
          create: {
            args: Prisma.SearchEngineSourceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          createMany: {
            args: Prisma.SearchEngineSourceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchEngineSourceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>[]
          }
          delete: {
            args: Prisma.SearchEngineSourceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          update: {
            args: Prisma.SearchEngineSourceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          deleteMany: {
            args: Prisma.SearchEngineSourceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchEngineSourceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SearchEngineSourceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>[]
          }
          upsert: {
            args: Prisma.SearchEngineSourceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchEngineSourceConfigPayload>
          }
          aggregate: {
            args: Prisma.SearchEngineSourceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchEngineSourceConfig>
          }
          groupBy: {
            args: Prisma.SearchEngineSourceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchEngineSourceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchEngineSourceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SearchEngineSourceConfigCountAggregateOutputType> | number
          }
        }
      }
      SocialMediaSourceConfig: {
        payload: Prisma.$SocialMediaSourceConfigPayload<ExtArgs>
        fields: Prisma.SocialMediaSourceConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialMediaSourceConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialMediaSourceConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          findFirst: {
            args: Prisma.SocialMediaSourceConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialMediaSourceConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          findMany: {
            args: Prisma.SocialMediaSourceConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>[]
          }
          create: {
            args: Prisma.SocialMediaSourceConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          createMany: {
            args: Prisma.SocialMediaSourceConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialMediaSourceConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>[]
          }
          delete: {
            args: Prisma.SocialMediaSourceConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          update: {
            args: Prisma.SocialMediaSourceConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          deleteMany: {
            args: Prisma.SocialMediaSourceConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialMediaSourceConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialMediaSourceConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>[]
          }
          upsert: {
            args: Prisma.SocialMediaSourceConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaSourceConfigPayload>
          }
          aggregate: {
            args: Prisma.SocialMediaSourceConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialMediaSourceConfig>
          }
          groupBy: {
            args: Prisma.SocialMediaSourceConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaSourceConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialMediaSourceConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaSourceConfigCountAggregateOutputType> | number
          }
        }
      }
      Query: {
        payload: Prisma.$QueryPayload<ExtArgs>
        fields: Prisma.QueryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findFirst: {
            args: Prisma.QueryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          findMany: {
            args: Prisma.QueryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          create: {
            args: Prisma.QueryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          createMany: {
            args: Prisma.QueryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          delete: {
            args: Prisma.QueryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          update: {
            args: Prisma.QueryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          deleteMany: {
            args: Prisma.QueryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>[]
          }
          upsert: {
            args: Prisma.QueryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryPayload>
          }
          aggregate: {
            args: Prisma.QueryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuery>
          }
          groupBy: {
            args: Prisma.QueryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryCountArgs<ExtArgs>
            result: $Utils.Optional<QueryCountAggregateOutputType> | number
          }
        }
      }
      QueryRun: {
        payload: Prisma.$QueryRunPayload<ExtArgs>
        fields: Prisma.QueryRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueryRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueryRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          findFirst: {
            args: Prisma.QueryRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueryRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          findMany: {
            args: Prisma.QueryRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>[]
          }
          create: {
            args: Prisma.QueryRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          createMany: {
            args: Prisma.QueryRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueryRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>[]
          }
          delete: {
            args: Prisma.QueryRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          update: {
            args: Prisma.QueryRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          deleteMany: {
            args: Prisma.QueryRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueryRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueryRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>[]
          }
          upsert: {
            args: Prisma.QueryRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueryRunPayload>
          }
          aggregate: {
            args: Prisma.QueryRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueryRun>
          }
          groupBy: {
            args: Prisma.QueryRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueryRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueryRunCountArgs<ExtArgs>
            result: $Utils.Optional<QueryRunCountAggregateOutputType> | number
          }
        }
      }
      TaskEvent: {
        payload: Prisma.$TaskEventPayload<ExtArgs>
        fields: Prisma.TaskEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          findFirst: {
            args: Prisma.TaskEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          findMany: {
            args: Prisma.TaskEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          create: {
            args: Prisma.TaskEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          createMany: {
            args: Prisma.TaskEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          delete: {
            args: Prisma.TaskEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          update: {
            args: Prisma.TaskEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          deleteMany: {
            args: Prisma.TaskEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>[]
          }
          upsert: {
            args: Prisma.TaskEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskEventPayload>
          }
          aggregate: {
            args: Prisma.TaskEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskEvent>
          }
          groupBy: {
            args: Prisma.TaskEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskEventCountArgs<ExtArgs>
            result: $Utils.Optional<TaskEventCountAggregateOutputType> | number
          }
        }
      }
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      ContentKeyword: {
        payload: Prisma.$ContentKeywordPayload<ExtArgs>
        fields: Prisma.ContentKeywordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentKeywordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentKeywordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          findFirst: {
            args: Prisma.ContentKeywordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentKeywordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          findMany: {
            args: Prisma.ContentKeywordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>[]
          }
          create: {
            args: Prisma.ContentKeywordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          createMany: {
            args: Prisma.ContentKeywordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentKeywordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>[]
          }
          delete: {
            args: Prisma.ContentKeywordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          update: {
            args: Prisma.ContentKeywordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          deleteMany: {
            args: Prisma.ContentKeywordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentKeywordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentKeywordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>[]
          }
          upsert: {
            args: Prisma.ContentKeywordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentKeywordPayload>
          }
          aggregate: {
            args: Prisma.ContentKeywordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentKeyword>
          }
          groupBy: {
            args: Prisma.ContentKeywordGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentKeywordGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentKeywordCountArgs<ExtArgs>
            result: $Utils.Optional<ContentKeywordCountAggregateOutputType> | number
          }
        }
      }
      ContentEntity: {
        payload: Prisma.$ContentEntityPayload<ExtArgs>
        fields: Prisma.ContentEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          findFirst: {
            args: Prisma.ContentEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          findMany: {
            args: Prisma.ContentEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>[]
          }
          create: {
            args: Prisma.ContentEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          createMany: {
            args: Prisma.ContentEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>[]
          }
          delete: {
            args: Prisma.ContentEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          update: {
            args: Prisma.ContentEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          deleteMany: {
            args: Prisma.ContentEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentEntityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>[]
          }
          upsert: {
            args: Prisma.ContentEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentEntityPayload>
          }
          aggregate: {
            args: Prisma.ContentEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentEntity>
          }
          groupBy: {
            args: Prisma.ContentEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentEntityCountArgs<ExtArgs>
            result: $Utils.Optional<ContentEntityCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      ReportTemplate: {
        payload: Prisma.$ReportTemplatePayload<ExtArgs>
        fields: Prisma.ReportTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findFirst: {
            args: Prisma.ReportTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          findMany: {
            args: Prisma.ReportTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          create: {
            args: Prisma.ReportTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          createMany: {
            args: Prisma.ReportTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          delete: {
            args: Prisma.ReportTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          update: {
            args: Prisma.ReportTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ReportTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ReportTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportTemplatePayload>
          }
          aggregate: {
            args: Prisma.ReportTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportTemplate>
          }
          groupBy: {
            args: Prisma.ReportTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ReportTemplateCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportMaterial: {
        payload: Prisma.$ReportMaterialPayload<ExtArgs>
        fields: Prisma.ReportMaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportMaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportMaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          findFirst: {
            args: Prisma.ReportMaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportMaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          findMany: {
            args: Prisma.ReportMaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>[]
          }
          create: {
            args: Prisma.ReportMaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          createMany: {
            args: Prisma.ReportMaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportMaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>[]
          }
          delete: {
            args: Prisma.ReportMaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          update: {
            args: Prisma.ReportMaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          deleteMany: {
            args: Prisma.ReportMaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportMaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportMaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>[]
          }
          upsert: {
            args: Prisma.ReportMaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportMaterialPayload>
          }
          aggregate: {
            args: Prisma.ReportMaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportMaterial>
          }
          groupBy: {
            args: Prisma.ReportMaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportMaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportMaterialCountArgs<ExtArgs>
            result: $Utils.Optional<ReportMaterialCountAggregateOutputType> | number
          }
        }
      }
      Knowledge: {
        payload: Prisma.$KnowledgePayload<ExtArgs>
        fields: Prisma.KnowledgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          findMany: {
            args: Prisma.KnowledgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>[]
          }
          create: {
            args: Prisma.KnowledgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          createMany: {
            args: Prisma.KnowledgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          update: {
            args: Prisma.KnowledgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledge>
          }
          groupBy: {
            args: Prisma.KnowledgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeFile: {
        payload: Prisma.$KnowledgeFilePayload<ExtArgs>
        fields: Prisma.KnowledgeFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          findMany: {
            args: Prisma.KnowledgeFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>[]
          }
          create: {
            args: Prisma.KnowledgeFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          createMany: {
            args: Prisma.KnowledgeFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          update: {
            args: Prisma.KnowledgeFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeFilePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeFile>
          }
          groupBy: {
            args: Prisma.KnowledgeFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeFileCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeFileCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeChunk: {
        payload: Prisma.$KnowledgeChunkPayload<ExtArgs>
        fields: Prisma.KnowledgeChunkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeChunkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          findFirst: {
            args: Prisma.KnowledgeChunkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeChunkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          findMany: {
            args: Prisma.KnowledgeChunkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          create: {
            args: Prisma.KnowledgeChunkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          createMany: {
            args: Prisma.KnowledgeChunkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeChunkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          delete: {
            args: Prisma.KnowledgeChunkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          update: {
            args: Prisma.KnowledgeChunkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeChunkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeChunkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeChunkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeChunkPayload>
          }
          aggregate: {
            args: Prisma.KnowledgeChunkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeChunk>
          }
          groupBy: {
            args: Prisma.KnowledgeChunkGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeChunkGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeChunkCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeChunkCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    category?: CategoryOmit
    keyword?: KeywordOmit
    proxy?: ProxyOmit
    credential?: CredentialOmit
    source?: SourceOmit
    webSourceConfig?: WebSourceConfigOmit
    darknetSourceConfig?: DarknetSourceConfigOmit
    searchEngineSourceConfig?: SearchEngineSourceConfigOmit
    socialMediaSourceConfig?: SocialMediaSourceConfigOmit
    query?: QueryOmit
    queryRun?: QueryRunOmit
    taskEvent?: TaskEventOmit
    content?: ContentOmit
    contentKeyword?: ContentKeywordOmit
    contentEntity?: ContentEntityOmit
    favorite?: FavoriteOmit
    reportTemplate?: ReportTemplateOmit
    report?: ReportOmit
    reportMaterial?: ReportMaterialOmit
    knowledge?: KnowledgeOmit
    knowledgeFile?: KnowledgeFileOmit
    knowledgeChunk?: KnowledgeChunkOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    keywords: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | CategoryCountOutputTypeCountKeywordsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }


  /**
   * Count Type KeywordCountOutputType
   */

  export type KeywordCountOutputType = {
    queries: number
    contentKeywords: number
  }

  export type KeywordCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | KeywordCountOutputTypeCountQueriesArgs
    contentKeywords?: boolean | KeywordCountOutputTypeCountContentKeywordsArgs
  }

  // Custom InputTypes
  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordCountOutputType
     */
    select?: KeywordCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }

  /**
   * KeywordCountOutputType without action
   */
  export type KeywordCountOutputTypeCountContentKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentKeywordWhereInput
  }


  /**
   * Count Type ProxyCountOutputType
   */

  export type ProxyCountOutputType = {
    sources: number
    darknetOverrides: number
    webOverrides: number
    socialOverrides: number
  }

  export type ProxyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | ProxyCountOutputTypeCountSourcesArgs
    darknetOverrides?: boolean | ProxyCountOutputTypeCountDarknetOverridesArgs
    webOverrides?: boolean | ProxyCountOutputTypeCountWebOverridesArgs
    socialOverrides?: boolean | ProxyCountOutputTypeCountSocialOverridesArgs
  }

  // Custom InputTypes
  /**
   * ProxyCountOutputType without action
   */
  export type ProxyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyCountOutputType
     */
    select?: ProxyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProxyCountOutputType without action
   */
  export type ProxyCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
  }

  /**
   * ProxyCountOutputType without action
   */
  export type ProxyCountOutputTypeCountDarknetOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarknetSourceConfigWhereInput
  }

  /**
   * ProxyCountOutputType without action
   */
  export type ProxyCountOutputTypeCountWebOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebSourceConfigWhereInput
  }

  /**
   * ProxyCountOutputType without action
   */
  export type ProxyCountOutputTypeCountSocialOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaSourceConfigWhereInput
  }


  /**
   * Count Type CredentialCountOutputType
   */

  export type CredentialCountOutputType = {
    sources: number
    socialOverrides: number
    searchOverrides: number
  }

  export type CredentialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | CredentialCountOutputTypeCountSourcesArgs
    socialOverrides?: boolean | CredentialCountOutputTypeCountSocialOverridesArgs
    searchOverrides?: boolean | CredentialCountOutputTypeCountSearchOverridesArgs
  }

  // Custom InputTypes
  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CredentialCountOutputType
     */
    select?: CredentialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountSocialOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaSourceConfigWhereInput
  }

  /**
   * CredentialCountOutputType without action
   */
  export type CredentialCountOutputTypeCountSearchOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchEngineSourceConfigWhereInput
  }


  /**
   * Count Type SourceCountOutputType
   */

  export type SourceCountOutputType = {
    queries: number
  }

  export type SourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    queries?: boolean | SourceCountOutputTypeCountQueriesArgs
  }

  // Custom InputTypes
  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceCountOutputType
     */
    select?: SourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SourceCountOutputType without action
   */
  export type SourceCountOutputTypeCountQueriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
  }


  /**
   * Count Type QueryCountOutputType
   */

  export type QueryCountOutputType = {
    keywords: number
    sources: number
    queryRuns: number
  }

  export type QueryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | QueryCountOutputTypeCountKeywordsArgs
    sources?: boolean | QueryCountOutputTypeCountSourcesArgs
    queryRuns?: boolean | QueryCountOutputTypeCountQueryRunsArgs
  }

  // Custom InputTypes
  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryCountOutputType
     */
    select?: QueryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
  }

  /**
   * QueryCountOutputType without action
   */
  export type QueryCountOutputTypeCountQueryRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryRunWhereInput
  }


  /**
   * Count Type QueryRunCountOutputType
   */

  export type QueryRunCountOutputType = {
    events: number
  }

  export type QueryRunCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | QueryRunCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * QueryRunCountOutputType without action
   */
  export type QueryRunCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRunCountOutputType
     */
    select?: QueryRunCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueryRunCountOutputType without action
   */
  export type QueryRunCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEventWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    keywords: number
    favorites: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | ContentCountOutputTypeCountKeywordsArgs
    favorites?: boolean | ContentCountOutputTypeCountFavoritesArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentKeywordWhereInput
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }


  /**
   * Count Type ReportTemplateCountOutputType
   */

  export type ReportTemplateCountOutputType = {
    reports: number
  }

  export type ReportTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReportTemplateCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplateCountOutputType
     */
    select?: ReportTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportTemplateCountOutputType without action
   */
  export type ReportTemplateCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    materials: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | ReportCountOutputTypeCountMaterialsArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportMaterialWhereInput
  }


  /**
   * Count Type KnowledgeCountOutputType
   */

  export type KnowledgeCountOutputType = {
    files: number
    knowledgeChunks: number
  }

  export type KnowledgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | KnowledgeCountOutputTypeCountFilesArgs
    knowledgeChunks?: boolean | KnowledgeCountOutputTypeCountKnowledgeChunksArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeCountOutputType without action
   */
  export type KnowledgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeCountOutputType
     */
    select?: KnowledgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeCountOutputType without action
   */
  export type KnowledgeCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeFileWhereInput
  }

  /**
   * KnowledgeCountOutputType without action
   */
  export type KnowledgeCountOutputTypeCountKnowledgeChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeChunkWhereInput
  }


  /**
   * Count Type KnowledgeFileCountOutputType
   */

  export type KnowledgeFileCountOutputType = {
    chunks: number
  }

  export type KnowledgeFileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chunks?: boolean | KnowledgeFileCountOutputTypeCountChunksArgs
  }

  // Custom InputTypes
  /**
   * KnowledgeFileCountOutputType without action
   */
  export type KnowledgeFileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFileCountOutputType
     */
    select?: KnowledgeFileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KnowledgeFileCountOutputType without action
   */
  export type KnowledgeFileCountOutputTypeCountChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeChunkWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keywords?: boolean | Category$keywordsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | Category$keywordsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      keywords: Prisma.$KeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords<T extends Category$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Category$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.keywords
   */
  export type Category$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Keyword
   */

  export type AggregateKeyword = {
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  export type KeywordMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lang: string | null
    categoryId: string | null
    enableAiExpand: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    lang: string | null
    categoryId: string | null
    enableAiExpand: boolean | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KeywordCountAggregateOutputType = {
    id: number
    name: number
    description: number
    lang: number
    categoryId: number
    includes: number
    excludes: number
    enableAiExpand: number
    synonyms: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KeywordMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lang?: true
    categoryId?: true
    enableAiExpand?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lang?: true
    categoryId?: true
    enableAiExpand?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KeywordCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    lang?: true
    categoryId?: true
    includes?: true
    excludes?: true
    enableAiExpand?: true
    synonyms?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keyword to aggregate.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Keywords
    **/
    _count?: true | KeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordMaxAggregateInputType
  }

  export type GetKeywordAggregateType<T extends KeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyword[P]>
      : GetScalarType<T[P], AggregateKeyword[P]>
  }




  export type KeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithAggregationInput | KeywordOrderByWithAggregationInput[]
    by: KeywordScalarFieldEnum[] | KeywordScalarFieldEnum
    having?: KeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordCountAggregateInputType | true
    _min?: KeywordMinAggregateInputType
    _max?: KeywordMaxAggregateInputType
  }

  export type KeywordGroupByOutputType = {
    id: string
    name: string
    description: string | null
    lang: string | null
    categoryId: string | null
    includes: string[]
    excludes: string[]
    enableAiExpand: boolean
    synonyms: string[]
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: KeywordCountAggregateOutputType | null
    _min: KeywordMinAggregateOutputType | null
    _max: KeywordMaxAggregateOutputType | null
  }

  type GetKeywordGroupByPayload<T extends KeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordGroupByOutputType[P]>
        }
      >
    >


  export type KeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    lang?: boolean
    categoryId?: boolean
    includes?: boolean
    excludes?: boolean
    enableAiExpand?: boolean
    synonyms?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Keyword$categoryArgs<ExtArgs>
    queries?: boolean | Keyword$queriesArgs<ExtArgs>
    contentKeywords?: boolean | Keyword$contentKeywordsArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    lang?: boolean
    categoryId?: boolean
    includes?: boolean
    excludes?: boolean
    enableAiExpand?: boolean
    synonyms?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Keyword$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    lang?: boolean
    categoryId?: boolean
    includes?: boolean
    excludes?: boolean
    enableAiExpand?: boolean
    synonyms?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | Keyword$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["keyword"]>

  export type KeywordSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    lang?: boolean
    categoryId?: boolean
    includes?: boolean
    excludes?: boolean
    enableAiExpand?: boolean
    synonyms?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "lang" | "categoryId" | "includes" | "excludes" | "enableAiExpand" | "synonyms" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["keyword"]>
  export type KeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Keyword$categoryArgs<ExtArgs>
    queries?: boolean | Keyword$queriesArgs<ExtArgs>
    contentKeywords?: boolean | Keyword$contentKeywordsArgs<ExtArgs>
    _count?: boolean | KeywordCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Keyword$categoryArgs<ExtArgs>
  }
  export type KeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Keyword$categoryArgs<ExtArgs>
  }

  export type $KeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Keyword"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      queries: Prisma.$QueryPayload<ExtArgs>[]
      contentKeywords: Prisma.$ContentKeywordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      lang: string | null
      categoryId: string | null
      includes: string[]
      excludes: string[]
      enableAiExpand: boolean
      synonyms: string[]
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["keyword"]>
    composites: {}
  }

  type KeywordGetPayload<S extends boolean | null | undefined | KeywordDefaultArgs> = $Result.GetResult<Prisma.$KeywordPayload, S>

  type KeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordCountAggregateInputType | true
    }

  export interface KeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Keyword'], meta: { name: 'Keyword' } }
    /**
     * Find zero or one Keyword that matches the filter.
     * @param {KeywordFindUniqueArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KeywordFindUniqueArgs>(args: SelectSubset<T, KeywordFindUniqueArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KeywordFindUniqueOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, KeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KeywordFindFirstArgs>(args?: SelectSubset<T, KeywordFindFirstArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindFirstOrThrowArgs} args - Arguments to find a Keyword
     * @example
     * // Get one Keyword
     * const keyword = await prisma.keyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, KeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keyword.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordWithIdOnly = await prisma.keyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KeywordFindManyArgs>(args?: SelectSubset<T, KeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keyword.
     * @param {KeywordCreateArgs} args - Arguments to create a Keyword.
     * @example
     * // Create one Keyword
     * const Keyword = await prisma.keyword.create({
     *   data: {
     *     // ... data to create a Keyword
     *   }
     * })
     * 
     */
    create<T extends KeywordCreateArgs>(args: SelectSubset<T, KeywordCreateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keywords.
     * @param {KeywordCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KeywordCreateManyArgs>(args?: SelectSubset<T, KeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keywords and returns the data saved in the database.
     * @param {KeywordCreateManyAndReturnArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keyword = await prisma.keyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, KeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Keyword.
     * @param {KeywordDeleteArgs} args - Arguments to delete one Keyword.
     * @example
     * // Delete one Keyword
     * const Keyword = await prisma.keyword.delete({
     *   where: {
     *     // ... filter to delete one Keyword
     *   }
     * })
     * 
     */
    delete<T extends KeywordDeleteArgs>(args: SelectSubset<T, KeywordDeleteArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keyword.
     * @param {KeywordUpdateArgs} args - Arguments to update one Keyword.
     * @example
     * // Update one Keyword
     * const keyword = await prisma.keyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KeywordUpdateArgs>(args: SelectSubset<T, KeywordUpdateArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keywords.
     * @param {KeywordDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KeywordDeleteManyArgs>(args?: SelectSubset<T, KeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KeywordUpdateManyArgs>(args: SelectSubset<T, KeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords and returns the data updated in the database.
     * @param {KeywordUpdateManyAndReturnArgs} args - Arguments to update many Keywords.
     * @example
     * // Update many Keywords
     * const keyword = await prisma.keyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keywords and only return the `id`
     * const keywordWithIdOnly = await prisma.keyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, KeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Keyword.
     * @param {KeywordUpsertArgs} args - Arguments to update or create a Keyword.
     * @example
     * // Update or create a Keyword
     * const keyword = await prisma.keyword.upsert({
     *   create: {
     *     // ... data to create a Keyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keyword we want to update
     *   }
     * })
     */
    upsert<T extends KeywordUpsertArgs>(args: SelectSubset<T, KeywordUpsertArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keyword.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends KeywordCountArgs>(
      args?: Subset<T, KeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordAggregateArgs>(args: Subset<T, KeywordAggregateArgs>): Prisma.PrismaPromise<GetKeywordAggregateType<T>>

    /**
     * Group by Keyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeywordGroupByArgs['orderBy'] }
        : { orderBy?: KeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Keyword model
   */
  readonly fields: KeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Keyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Keyword$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    queries<T extends Keyword$queriesArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contentKeywords<T extends Keyword$contentKeywordsArgs<ExtArgs> = {}>(args?: Subset<T, Keyword$contentKeywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Keyword model
   */
  interface KeywordFieldRefs {
    readonly id: FieldRef<"Keyword", 'String'>
    readonly name: FieldRef<"Keyword", 'String'>
    readonly description: FieldRef<"Keyword", 'String'>
    readonly lang: FieldRef<"Keyword", 'String'>
    readonly categoryId: FieldRef<"Keyword", 'String'>
    readonly includes: FieldRef<"Keyword", 'String[]'>
    readonly excludes: FieldRef<"Keyword", 'String[]'>
    readonly enableAiExpand: FieldRef<"Keyword", 'Boolean'>
    readonly synonyms: FieldRef<"Keyword", 'String[]'>
    readonly active: FieldRef<"Keyword", 'Boolean'>
    readonly createdAt: FieldRef<"Keyword", 'DateTime'>
    readonly updatedAt: FieldRef<"Keyword", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Keyword findUnique
   */
  export type KeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findUniqueOrThrow
   */
  export type KeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword findFirst
   */
  export type KeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findFirstOrThrow
   */
  export type KeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keyword to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Keywords.
     */
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword findMany
   */
  export type KeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter, which Keywords to fetch.
     */
    where?: KeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Keywords to fetch.
     */
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Keywords.
     */
    cursor?: KeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Keywords.
     */
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Keyword create
   */
  export type KeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a Keyword.
     */
    data: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
  }

  /**
   * Keyword createMany
   */
  export type KeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Keyword createManyAndReturn
   */
  export type KeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to create many Keywords.
     */
    data: KeywordCreateManyInput | KeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword update
   */
  export type KeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a Keyword.
     */
    data: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
    /**
     * Choose, which Keyword to update.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword updateMany
   */
  export type KeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
  }

  /**
   * Keyword updateManyAndReturn
   */
  export type KeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * The data used to update Keywords.
     */
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyInput>
    /**
     * Filter which Keywords to update
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Keyword upsert
   */
  export type KeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the Keyword to update in case it exists.
     */
    where: KeywordWhereUniqueInput
    /**
     * In case the Keyword found by the `where` argument doesn't exist, create a new Keyword with this data.
     */
    create: XOR<KeywordCreateInput, KeywordUncheckedCreateInput>
    /**
     * In case the Keyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeywordUpdateInput, KeywordUncheckedUpdateInput>
  }

  /**
   * Keyword delete
   */
  export type KeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    /**
     * Filter which Keyword to delete.
     */
    where: KeywordWhereUniqueInput
  }

  /**
   * Keyword deleteMany
   */
  export type KeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Keywords to delete
     */
    where?: KeywordWhereInput
    /**
     * Limit how many Keywords to delete.
     */
    limit?: number
  }

  /**
   * Keyword.category
   */
  export type Keyword$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * Keyword.queries
   */
  export type Keyword$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Keyword.contentKeywords
   */
  export type Keyword$contentKeywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    where?: ContentKeywordWhereInput
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    cursor?: ContentKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentKeywordScalarFieldEnum | ContentKeywordScalarFieldEnum[]
  }

  /**
   * Keyword without action
   */
  export type KeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
  }


  /**
   * Model Proxy
   */

  export type AggregateProxy = {
    _count: ProxyCountAggregateOutputType | null
    _min: ProxyMinAggregateOutputType | null
    _max: ProxyMaxAggregateOutputType | null
  }

  export type ProxyMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProxyType | null
    url: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.ProxyType | null
    url: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyCountAggregateOutputType = {
    id: number
    name: number
    type: number
    url: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProxyMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    url?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProxyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxy to aggregate.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proxies
    **/
    _count?: true | ProxyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyMaxAggregateInputType
  }

  export type GetProxyAggregateType<T extends ProxyAggregateArgs> = {
        [P in keyof T & keyof AggregateProxy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxy[P]>
      : GetScalarType<T[P], AggregateProxy[P]>
  }




  export type ProxyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyWhereInput
    orderBy?: ProxyOrderByWithAggregationInput | ProxyOrderByWithAggregationInput[]
    by: ProxyScalarFieldEnum[] | ProxyScalarFieldEnum
    having?: ProxyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyCountAggregateInputType | true
    _min?: ProxyMinAggregateInputType
    _max?: ProxyMaxAggregateInputType
  }

  export type ProxyGroupByOutputType = {
    id: string
    name: string
    type: $Enums.ProxyType
    url: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProxyCountAggregateOutputType | null
    _min: ProxyMinAggregateOutputType | null
    _max: ProxyMaxAggregateOutputType | null
  }

  type GetProxyGroupByPayload<T extends ProxyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyGroupByOutputType[P]>
        }
      >
    >


  export type ProxySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sources?: boolean | Proxy$sourcesArgs<ExtArgs>
    darknetOverrides?: boolean | Proxy$darknetOverridesArgs<ExtArgs>
    webOverrides?: boolean | Proxy$webOverridesArgs<ExtArgs>
    socialOverrides?: boolean | Proxy$socialOverridesArgs<ExtArgs>
    _count?: boolean | ProxyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxy"]>

  export type ProxySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proxy"]>

  export type ProxySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["proxy"]>

  export type ProxySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    url?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProxyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "url" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["proxy"]>
  export type ProxyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | Proxy$sourcesArgs<ExtArgs>
    darknetOverrides?: boolean | Proxy$darknetOverridesArgs<ExtArgs>
    webOverrides?: boolean | Proxy$webOverridesArgs<ExtArgs>
    socialOverrides?: boolean | Proxy$socialOverridesArgs<ExtArgs>
    _count?: boolean | ProxyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProxyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProxyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProxyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proxy"
    objects: {
      sources: Prisma.$SourcePayload<ExtArgs>[]
      darknetOverrides: Prisma.$DarknetSourceConfigPayload<ExtArgs>[]
      webOverrides: Prisma.$WebSourceConfigPayload<ExtArgs>[]
      socialOverrides: Prisma.$SocialMediaSourceConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.ProxyType
      url: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxy"]>
    composites: {}
  }

  type ProxyGetPayload<S extends boolean | null | undefined | ProxyDefaultArgs> = $Result.GetResult<Prisma.$ProxyPayload, S>

  type ProxyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyCountAggregateInputType | true
    }

  export interface ProxyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proxy'], meta: { name: 'Proxy' } }
    /**
     * Find zero or one Proxy that matches the filter.
     * @param {ProxyFindUniqueArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyFindUniqueArgs>(args: SelectSubset<T, ProxyFindUniqueArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Proxy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyFindUniqueOrThrowArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proxy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindFirstArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyFindFirstArgs>(args?: SelectSubset<T, ProxyFindFirstArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Proxy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindFirstOrThrowArgs} args - Arguments to find a Proxy
     * @example
     * // Get one Proxy
     * const proxy = await prisma.proxy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Proxies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proxies
     * const proxies = await prisma.proxy.findMany()
     * 
     * // Get first 10 Proxies
     * const proxies = await prisma.proxy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyWithIdOnly = await prisma.proxy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyFindManyArgs>(args?: SelectSubset<T, ProxyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Proxy.
     * @param {ProxyCreateArgs} args - Arguments to create a Proxy.
     * @example
     * // Create one Proxy
     * const Proxy = await prisma.proxy.create({
     *   data: {
     *     // ... data to create a Proxy
     *   }
     * })
     * 
     */
    create<T extends ProxyCreateArgs>(args: SelectSubset<T, ProxyCreateArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Proxies.
     * @param {ProxyCreateManyArgs} args - Arguments to create many Proxies.
     * @example
     * // Create many Proxies
     * const proxy = await prisma.proxy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyCreateManyArgs>(args?: SelectSubset<T, ProxyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Proxies and returns the data saved in the database.
     * @param {ProxyCreateManyAndReturnArgs} args - Arguments to create many Proxies.
     * @example
     * // Create many Proxies
     * const proxy = await prisma.proxy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Proxies and only return the `id`
     * const proxyWithIdOnly = await prisma.proxy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Proxy.
     * @param {ProxyDeleteArgs} args - Arguments to delete one Proxy.
     * @example
     * // Delete one Proxy
     * const Proxy = await prisma.proxy.delete({
     *   where: {
     *     // ... filter to delete one Proxy
     *   }
     * })
     * 
     */
    delete<T extends ProxyDeleteArgs>(args: SelectSubset<T, ProxyDeleteArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Proxy.
     * @param {ProxyUpdateArgs} args - Arguments to update one Proxy.
     * @example
     * // Update one Proxy
     * const proxy = await prisma.proxy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyUpdateArgs>(args: SelectSubset<T, ProxyUpdateArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Proxies.
     * @param {ProxyDeleteManyArgs} args - Arguments to filter Proxies to delete.
     * @example
     * // Delete a few Proxies
     * const { count } = await prisma.proxy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyDeleteManyArgs>(args?: SelectSubset<T, ProxyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proxies
     * const proxy = await prisma.proxy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyUpdateManyArgs>(args: SelectSubset<T, ProxyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proxies and returns the data updated in the database.
     * @param {ProxyUpdateManyAndReturnArgs} args - Arguments to update many Proxies.
     * @example
     * // Update many Proxies
     * const proxy = await prisma.proxy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Proxies and only return the `id`
     * const proxyWithIdOnly = await prisma.proxy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Proxy.
     * @param {ProxyUpsertArgs} args - Arguments to update or create a Proxy.
     * @example
     * // Update or create a Proxy
     * const proxy = await prisma.proxy.upsert({
     *   create: {
     *     // ... data to create a Proxy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proxy we want to update
     *   }
     * })
     */
    upsert<T extends ProxyUpsertArgs>(args: SelectSubset<T, ProxyUpsertArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Proxies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyCountArgs} args - Arguments to filter Proxies to count.
     * @example
     * // Count the number of Proxies
     * const count = await prisma.proxy.count({
     *   where: {
     *     // ... the filter for the Proxies we want to count
     *   }
     * })
    **/
    count<T extends ProxyCountArgs>(
      args?: Subset<T, ProxyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyAggregateArgs>(args: Subset<T, ProxyAggregateArgs>): Prisma.PrismaPromise<GetProxyAggregateType<T>>

    /**
     * Group by Proxy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyGroupByArgs['orderBy'] }
        : { orderBy?: ProxyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proxy model
   */
  readonly fields: ProxyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proxy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sources<T extends Proxy$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Proxy$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    darknetOverrides<T extends Proxy$darknetOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Proxy$darknetOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    webOverrides<T extends Proxy$webOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Proxy$webOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialOverrides<T extends Proxy$socialOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Proxy$socialOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proxy model
   */
  interface ProxyFieldRefs {
    readonly id: FieldRef<"Proxy", 'String'>
    readonly name: FieldRef<"Proxy", 'String'>
    readonly type: FieldRef<"Proxy", 'ProxyType'>
    readonly url: FieldRef<"Proxy", 'String'>
    readonly active: FieldRef<"Proxy", 'Boolean'>
    readonly createdAt: FieldRef<"Proxy", 'DateTime'>
    readonly updatedAt: FieldRef<"Proxy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proxy findUnique
   */
  export type ProxyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy findUniqueOrThrow
   */
  export type ProxyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy findFirst
   */
  export type ProxyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxies.
     */
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy findFirstOrThrow
   */
  export type ProxyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxy to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proxies.
     */
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy findMany
   */
  export type ProxyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter, which Proxies to fetch.
     */
    where?: ProxyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proxies to fetch.
     */
    orderBy?: ProxyOrderByWithRelationInput | ProxyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proxies.
     */
    cursor?: ProxyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proxies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proxies.
     */
    skip?: number
    distinct?: ProxyScalarFieldEnum | ProxyScalarFieldEnum[]
  }

  /**
   * Proxy create
   */
  export type ProxyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The data needed to create a Proxy.
     */
    data: XOR<ProxyCreateInput, ProxyUncheckedCreateInput>
  }

  /**
   * Proxy createMany
   */
  export type ProxyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Proxies.
     */
    data: ProxyCreateManyInput | ProxyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proxy createManyAndReturn
   */
  export type ProxyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * The data used to create many Proxies.
     */
    data: ProxyCreateManyInput | ProxyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proxy update
   */
  export type ProxyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The data needed to update a Proxy.
     */
    data: XOR<ProxyUpdateInput, ProxyUncheckedUpdateInput>
    /**
     * Choose, which Proxy to update.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy updateMany
   */
  export type ProxyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Proxies.
     */
    data: XOR<ProxyUpdateManyMutationInput, ProxyUncheckedUpdateManyInput>
    /**
     * Filter which Proxies to update
     */
    where?: ProxyWhereInput
    /**
     * Limit how many Proxies to update.
     */
    limit?: number
  }

  /**
   * Proxy updateManyAndReturn
   */
  export type ProxyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * The data used to update Proxies.
     */
    data: XOR<ProxyUpdateManyMutationInput, ProxyUncheckedUpdateManyInput>
    /**
     * Filter which Proxies to update
     */
    where?: ProxyWhereInput
    /**
     * Limit how many Proxies to update.
     */
    limit?: number
  }

  /**
   * Proxy upsert
   */
  export type ProxyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * The filter to search for the Proxy to update in case it exists.
     */
    where: ProxyWhereUniqueInput
    /**
     * In case the Proxy found by the `where` argument doesn't exist, create a new Proxy with this data.
     */
    create: XOR<ProxyCreateInput, ProxyUncheckedCreateInput>
    /**
     * In case the Proxy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyUpdateInput, ProxyUncheckedUpdateInput>
  }

  /**
   * Proxy delete
   */
  export type ProxyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    /**
     * Filter which Proxy to delete.
     */
    where: ProxyWhereUniqueInput
  }

  /**
   * Proxy deleteMany
   */
  export type ProxyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proxies to delete
     */
    where?: ProxyWhereInput
    /**
     * Limit how many Proxies to delete.
     */
    limit?: number
  }

  /**
   * Proxy.sources
   */
  export type Proxy$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    cursor?: SourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Proxy.darknetOverrides
   */
  export type Proxy$darknetOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    where?: DarknetSourceConfigWhereInput
    orderBy?: DarknetSourceConfigOrderByWithRelationInput | DarknetSourceConfigOrderByWithRelationInput[]
    cursor?: DarknetSourceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DarknetSourceConfigScalarFieldEnum | DarknetSourceConfigScalarFieldEnum[]
  }

  /**
   * Proxy.webOverrides
   */
  export type Proxy$webOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    where?: WebSourceConfigWhereInput
    orderBy?: WebSourceConfigOrderByWithRelationInput | WebSourceConfigOrderByWithRelationInput[]
    cursor?: WebSourceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebSourceConfigScalarFieldEnum | WebSourceConfigScalarFieldEnum[]
  }

  /**
   * Proxy.socialOverrides
   */
  export type Proxy$socialOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    where?: SocialMediaSourceConfigWhereInput
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialMediaSourceConfigScalarFieldEnum | SocialMediaSourceConfigScalarFieldEnum[]
  }

  /**
   * Proxy without action
   */
  export type ProxyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
  }


  /**
   * Model Credential
   */

  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    name: string | null
    kind: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    name: string | null
    kind: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    name: number
    kind: number
    data: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    name?: true
    kind?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    name?: true
    kind?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    name?: true
    kind?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CredentialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credential to aggregate.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CredentialWhereInput
    orderBy?: CredentialOrderByWithAggregationInput | CredentialOrderByWithAggregationInput[]
    by: CredentialScalarFieldEnum[] | CredentialScalarFieldEnum
    having?: CredentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }

  export type CredentialGroupByOutputType = {
    id: string
    name: string
    kind: string
    data: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type CredentialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    kind?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sources?: boolean | Credential$sourcesArgs<ExtArgs>
    socialOverrides?: boolean | Credential$socialOverridesArgs<ExtArgs>
    searchOverrides?: boolean | Credential$searchOverridesArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    kind?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    kind?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["credential"]>

  export type CredentialSelectScalar = {
    id?: boolean
    name?: boolean
    kind?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CredentialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "kind" | "data" | "createdAt" | "updatedAt", ExtArgs["result"]["credential"]>
  export type CredentialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | Credential$sourcesArgs<ExtArgs>
    socialOverrides?: boolean | Credential$socialOverridesArgs<ExtArgs>
    searchOverrides?: boolean | Credential$searchOverridesArgs<ExtArgs>
    _count?: boolean | CredentialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CredentialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CredentialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CredentialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Credential"
    objects: {
      sources: Prisma.$SourcePayload<ExtArgs>[]
      socialOverrides: Prisma.$SocialMediaSourceConfigPayload<ExtArgs>[]
      searchOverrides: Prisma.$SearchEngineSourceConfigPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      kind: string
      data: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["credential"]>
    composites: {}
  }

  type CredentialGetPayload<S extends boolean | null | undefined | CredentialDefaultArgs> = $Result.GetResult<Prisma.$CredentialPayload, S>

  type CredentialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CredentialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface CredentialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Credential'], meta: { name: 'Credential' } }
    /**
     * Find zero or one Credential that matches the filter.
     * @param {CredentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CredentialFindUniqueArgs>(args: SelectSubset<T, CredentialFindUniqueArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Credential that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CredentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CredentialFindUniqueOrThrowArgs>(args: SelectSubset<T, CredentialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CredentialFindFirstArgs>(args?: SelectSubset<T, CredentialFindFirstArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Credential that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CredentialFindFirstOrThrowArgs>(args?: SelectSubset<T, CredentialFindFirstOrThrowArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CredentialFindManyArgs>(args?: SelectSubset<T, CredentialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Credential.
     * @param {CredentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
     */
    create<T extends CredentialCreateArgs>(args: SelectSubset<T, CredentialCreateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Credentials.
     * @param {CredentialCreateManyArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CredentialCreateManyArgs>(args?: SelectSubset<T, CredentialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Credentials and returns the data saved in the database.
     * @param {CredentialCreateManyAndReturnArgs} args - Arguments to create many Credentials.
     * @example
     * // Create many Credentials
     * const credential = await prisma.credential.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CredentialCreateManyAndReturnArgs>(args?: SelectSubset<T, CredentialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Credential.
     * @param {CredentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
     */
    delete<T extends CredentialDeleteArgs>(args: SelectSubset<T, CredentialDeleteArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Credential.
     * @param {CredentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CredentialUpdateArgs>(args: SelectSubset<T, CredentialUpdateArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Credentials.
     * @param {CredentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CredentialDeleteManyArgs>(args?: SelectSubset<T, CredentialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CredentialUpdateManyArgs>(args: SelectSubset<T, CredentialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials and returns the data updated in the database.
     * @param {CredentialUpdateManyAndReturnArgs} args - Arguments to update many Credentials.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Credentials and only return the `id`
     * const credentialWithIdOnly = await prisma.credential.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CredentialUpdateManyAndReturnArgs>(args: SelectSubset<T, CredentialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Credential.
     * @param {CredentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
     */
    upsert<T extends CredentialUpsertArgs>(args: SelectSubset<T, CredentialUpsertArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends CredentialCountArgs>(
      args?: Subset<T, CredentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Credential model
   */
  readonly fields: CredentialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CredentialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sources<T extends Credential$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Credential$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialOverrides<T extends Credential$socialOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Credential$socialOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    searchOverrides<T extends Credential$searchOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Credential$searchOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Credential model
   */
  interface CredentialFieldRefs {
    readonly id: FieldRef<"Credential", 'String'>
    readonly name: FieldRef<"Credential", 'String'>
    readonly kind: FieldRef<"Credential", 'String'>
    readonly data: FieldRef<"Credential", 'Json'>
    readonly createdAt: FieldRef<"Credential", 'DateTime'>
    readonly updatedAt: FieldRef<"Credential", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Credential findUnique
   */
  export type CredentialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findUniqueOrThrow
   */
  export type CredentialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential findFirst
   */
  export type CredentialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findFirstOrThrow
   */
  export type CredentialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credential to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Credentials.
     */
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential findMany
   */
  export type CredentialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter, which Credentials to fetch.
     */
    where?: CredentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Credentials to fetch.
     */
    orderBy?: CredentialOrderByWithRelationInput | CredentialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Credentials.
     */
    cursor?: CredentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Credentials.
     */
    skip?: number
    distinct?: CredentialScalarFieldEnum | CredentialScalarFieldEnum[]
  }

  /**
   * Credential create
   */
  export type CredentialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to create a Credential.
     */
    data: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
  }

  /**
   * Credential createMany
   */
  export type CredentialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential createManyAndReturn
   */
  export type CredentialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to create many Credentials.
     */
    data: CredentialCreateManyInput | CredentialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Credential update
   */
  export type CredentialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The data needed to update a Credential.
     */
    data: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
    /**
     * Choose, which Credential to update.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential updateMany
   */
  export type CredentialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential updateManyAndReturn
   */
  export type CredentialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * The data used to update Credentials.
     */
    data: XOR<CredentialUpdateManyMutationInput, CredentialUncheckedUpdateManyInput>
    /**
     * Filter which Credentials to update
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to update.
     */
    limit?: number
  }

  /**
   * Credential upsert
   */
  export type CredentialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * The filter to search for the Credential to update in case it exists.
     */
    where: CredentialWhereUniqueInput
    /**
     * In case the Credential found by the `where` argument doesn't exist, create a new Credential with this data.
     */
    create: XOR<CredentialCreateInput, CredentialUncheckedCreateInput>
    /**
     * In case the Credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CredentialUpdateInput, CredentialUncheckedUpdateInput>
  }

  /**
   * Credential delete
   */
  export type CredentialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    /**
     * Filter which Credential to delete.
     */
    where: CredentialWhereUniqueInput
  }

  /**
   * Credential deleteMany
   */
  export type CredentialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Credentials to delete
     */
    where?: CredentialWhereInput
    /**
     * Limit how many Credentials to delete.
     */
    limit?: number
  }

  /**
   * Credential.sources
   */
  export type Credential$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    cursor?: SourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Credential.socialOverrides
   */
  export type Credential$socialOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    where?: SocialMediaSourceConfigWhereInput
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialMediaSourceConfigScalarFieldEnum | SocialMediaSourceConfigScalarFieldEnum[]
  }

  /**
   * Credential.searchOverrides
   */
  export type Credential$searchOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    where?: SearchEngineSourceConfigWhereInput
    orderBy?: SearchEngineSourceConfigOrderByWithRelationInput | SearchEngineSourceConfigOrderByWithRelationInput[]
    cursor?: SearchEngineSourceConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchEngineSourceConfigScalarFieldEnum | SearchEngineSourceConfigScalarFieldEnum[]
  }

  /**
   * Credential without action
   */
  export type CredentialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
  }


  /**
   * Model Source
   */

  export type AggregateSource = {
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  export type SourceAvgAggregateOutputType = {
    rateLimit: number | null
  }

  export type SourceSumAggregateOutputType = {
    rateLimit: number | null
  }

  export type SourceMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SourceType | null
    active: boolean | null
    rateLimit: number | null
    lastFetchedAt: Date | null
    lastStatus: string | null
    proxyId: string | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SourceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.SourceType | null
    active: boolean | null
    rateLimit: number | null
    lastFetchedAt: Date | null
    lastStatus: string | null
    proxyId: string | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SourceCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    active: number
    rateLimit: number
    lastFetchedAt: number
    lastStatus: number
    proxyId: number
    credentialId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SourceAvgAggregateInputType = {
    rateLimit?: true
  }

  export type SourceSumAggregateInputType = {
    rateLimit?: true
  }

  export type SourceMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    active?: true
    rateLimit?: true
    lastFetchedAt?: true
    lastStatus?: true
    proxyId?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SourceMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    active?: true
    rateLimit?: true
    lastFetchedAt?: true
    lastStatus?: true
    proxyId?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SourceCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    active?: true
    rateLimit?: true
    lastFetchedAt?: true
    lastStatus?: true
    proxyId?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Source to aggregate.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sources
    **/
    _count?: true | SourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceMaxAggregateInputType
  }

  export type GetSourceAggregateType<T extends SourceAggregateArgs> = {
        [P in keyof T & keyof AggregateSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSource[P]>
      : GetScalarType<T[P], AggregateSource[P]>
  }




  export type SourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithAggregationInput | SourceOrderByWithAggregationInput[]
    by: SourceScalarFieldEnum[] | SourceScalarFieldEnum
    having?: SourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceCountAggregateInputType | true
    _avg?: SourceAvgAggregateInputType
    _sum?: SourceSumAggregateInputType
    _min?: SourceMinAggregateInputType
    _max?: SourceMaxAggregateInputType
  }

  export type SourceGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.SourceType
    active: boolean
    rateLimit: number | null
    lastFetchedAt: Date | null
    lastStatus: string | null
    proxyId: string | null
    credentialId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SourceCountAggregateOutputType | null
    _avg: SourceAvgAggregateOutputType | null
    _sum: SourceSumAggregateOutputType | null
    _min: SourceMinAggregateOutputType | null
    _max: SourceMaxAggregateOutputType | null
  }

  type GetSourceGroupByPayload<T extends SourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceGroupByOutputType[P]>
            : GetScalarType<T[P], SourceGroupByOutputType[P]>
        }
      >
    >


  export type SourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    active?: boolean
    rateLimit?: boolean
    lastFetchedAt?: boolean
    lastStatus?: boolean
    proxyId?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
    web?: boolean | Source$webArgs<ExtArgs>
    darknet?: boolean | Source$darknetArgs<ExtArgs>
    search?: boolean | Source$searchArgs<ExtArgs>
    social?: boolean | Source$socialArgs<ExtArgs>
    queries?: boolean | Source$queriesArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    active?: boolean
    rateLimit?: boolean
    lastFetchedAt?: boolean
    lastStatus?: boolean
    proxyId?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    active?: boolean
    rateLimit?: boolean
    lastFetchedAt?: boolean
    lastStatus?: boolean
    proxyId?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["source"]>

  export type SourceSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    active?: boolean
    rateLimit?: boolean
    lastFetchedAt?: boolean
    lastStatus?: boolean
    proxyId?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "active" | "rateLimit" | "lastFetchedAt" | "lastStatus" | "proxyId" | "credentialId" | "createdAt" | "updatedAt", ExtArgs["result"]["source"]>
  export type SourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
    web?: boolean | Source$webArgs<ExtArgs>
    darknet?: boolean | Source$darknetArgs<ExtArgs>
    search?: boolean | Source$searchArgs<ExtArgs>
    social?: boolean | Source$socialArgs<ExtArgs>
    queries?: boolean | Source$queriesArgs<ExtArgs>
    _count?: boolean | SourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
  }
  export type SourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proxy?: boolean | Source$proxyArgs<ExtArgs>
    credential?: boolean | Source$credentialArgs<ExtArgs>
  }

  export type $SourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Source"
    objects: {
      proxy: Prisma.$ProxyPayload<ExtArgs> | null
      credential: Prisma.$CredentialPayload<ExtArgs> | null
      web: Prisma.$WebSourceConfigPayload<ExtArgs> | null
      darknet: Prisma.$DarknetSourceConfigPayload<ExtArgs> | null
      search: Prisma.$SearchEngineSourceConfigPayload<ExtArgs> | null
      social: Prisma.$SocialMediaSourceConfigPayload<ExtArgs> | null
      queries: Prisma.$QueryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.SourceType
      active: boolean
      rateLimit: number | null
      lastFetchedAt: Date | null
      lastStatus: string | null
      proxyId: string | null
      credentialId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["source"]>
    composites: {}
  }

  type SourceGetPayload<S extends boolean | null | undefined | SourceDefaultArgs> = $Result.GetResult<Prisma.$SourcePayload, S>

  type SourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceCountAggregateInputType | true
    }

  export interface SourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Source'], meta: { name: 'Source' } }
    /**
     * Find zero or one Source that matches the filter.
     * @param {SourceFindUniqueArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceFindUniqueArgs>(args: SelectSubset<T, SourceFindUniqueArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Source that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceFindUniqueOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Source that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceFindFirstArgs>(args?: SelectSubset<T, SourceFindFirstArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Source that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindFirstOrThrowArgs} args - Arguments to find a Source
     * @example
     * // Get one Source
     * const source = await prisma.source.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sources
     * const sources = await prisma.source.findMany()
     * 
     * // Get first 10 Sources
     * const sources = await prisma.source.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceWithIdOnly = await prisma.source.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceFindManyArgs>(args?: SelectSubset<T, SourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Source.
     * @param {SourceCreateArgs} args - Arguments to create a Source.
     * @example
     * // Create one Source
     * const Source = await prisma.source.create({
     *   data: {
     *     // ... data to create a Source
     *   }
     * })
     * 
     */
    create<T extends SourceCreateArgs>(args: SelectSubset<T, SourceCreateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sources.
     * @param {SourceCreateManyArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceCreateManyArgs>(args?: SelectSubset<T, SourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sources and returns the data saved in the database.
     * @param {SourceCreateManyAndReturnArgs} args - Arguments to create many Sources.
     * @example
     * // Create many Sources
     * const source = await prisma.source.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Source.
     * @param {SourceDeleteArgs} args - Arguments to delete one Source.
     * @example
     * // Delete one Source
     * const Source = await prisma.source.delete({
     *   where: {
     *     // ... filter to delete one Source
     *   }
     * })
     * 
     */
    delete<T extends SourceDeleteArgs>(args: SelectSubset<T, SourceDeleteArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Source.
     * @param {SourceUpdateArgs} args - Arguments to update one Source.
     * @example
     * // Update one Source
     * const source = await prisma.source.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceUpdateArgs>(args: SelectSubset<T, SourceUpdateArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sources.
     * @param {SourceDeleteManyArgs} args - Arguments to filter Sources to delete.
     * @example
     * // Delete a few Sources
     * const { count } = await prisma.source.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceDeleteManyArgs>(args?: SelectSubset<T, SourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceUpdateManyArgs>(args: SelectSubset<T, SourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sources and returns the data updated in the database.
     * @param {SourceUpdateManyAndReturnArgs} args - Arguments to update many Sources.
     * @example
     * // Update many Sources
     * const source = await prisma.source.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sources and only return the `id`
     * const sourceWithIdOnly = await prisma.source.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Source.
     * @param {SourceUpsertArgs} args - Arguments to update or create a Source.
     * @example
     * // Update or create a Source
     * const source = await prisma.source.upsert({
     *   create: {
     *     // ... data to create a Source
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Source we want to update
     *   }
     * })
     */
    upsert<T extends SourceUpsertArgs>(args: SelectSubset<T, SourceUpsertArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceCountArgs} args - Arguments to filter Sources to count.
     * @example
     * // Count the number of Sources
     * const count = await prisma.source.count({
     *   where: {
     *     // ... the filter for the Sources we want to count
     *   }
     * })
    **/
    count<T extends SourceCountArgs>(
      args?: Subset<T, SourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceAggregateArgs>(args: Subset<T, SourceAggregateArgs>): Prisma.PrismaPromise<GetSourceAggregateType<T>>

    /**
     * Group by Source.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceGroupByArgs['orderBy'] }
        : { orderBy?: SourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Source model
   */
  readonly fields: SourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Source.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proxy<T extends Source$proxyArgs<ExtArgs> = {}>(args?: Subset<T, Source$proxyArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    credential<T extends Source$credentialArgs<ExtArgs> = {}>(args?: Subset<T, Source$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    web<T extends Source$webArgs<ExtArgs> = {}>(args?: Subset<T, Source$webArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    darknet<T extends Source$darknetArgs<ExtArgs> = {}>(args?: Subset<T, Source$darknetArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    search<T extends Source$searchArgs<ExtArgs> = {}>(args?: Subset<T, Source$searchArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    social<T extends Source$socialArgs<ExtArgs> = {}>(args?: Subset<T, Source$socialArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    queries<T extends Source$queriesArgs<ExtArgs> = {}>(args?: Subset<T, Source$queriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Source model
   */
  interface SourceFieldRefs {
    readonly id: FieldRef<"Source", 'String'>
    readonly name: FieldRef<"Source", 'String'>
    readonly description: FieldRef<"Source", 'String'>
    readonly type: FieldRef<"Source", 'SourceType'>
    readonly active: FieldRef<"Source", 'Boolean'>
    readonly rateLimit: FieldRef<"Source", 'Int'>
    readonly lastFetchedAt: FieldRef<"Source", 'DateTime'>
    readonly lastStatus: FieldRef<"Source", 'String'>
    readonly proxyId: FieldRef<"Source", 'String'>
    readonly credentialId: FieldRef<"Source", 'String'>
    readonly createdAt: FieldRef<"Source", 'DateTime'>
    readonly updatedAt: FieldRef<"Source", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Source findUnique
   */
  export type SourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findUniqueOrThrow
   */
  export type SourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source findFirst
   */
  export type SourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findFirstOrThrow
   */
  export type SourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Source to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sources.
     */
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source findMany
   */
  export type SourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter, which Sources to fetch.
     */
    where?: SourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sources to fetch.
     */
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sources.
     */
    cursor?: SourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sources.
     */
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Source create
   */
  export type SourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Source.
     */
    data: XOR<SourceCreateInput, SourceUncheckedCreateInput>
  }

  /**
   * Source createMany
   */
  export type SourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Source createManyAndReturn
   */
  export type SourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to create many Sources.
     */
    data: SourceCreateManyInput | SourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Source update
   */
  export type SourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Source.
     */
    data: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
    /**
     * Choose, which Source to update.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source updateMany
   */
  export type SourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
  }

  /**
   * Source updateManyAndReturn
   */
  export type SourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * The data used to update Sources.
     */
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyInput>
    /**
     * Filter which Sources to update
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Source upsert
   */
  export type SourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Source to update in case it exists.
     */
    where: SourceWhereUniqueInput
    /**
     * In case the Source found by the `where` argument doesn't exist, create a new Source with this data.
     */
    create: XOR<SourceCreateInput, SourceUncheckedCreateInput>
    /**
     * In case the Source was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceUpdateInput, SourceUncheckedUpdateInput>
  }

  /**
   * Source delete
   */
  export type SourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    /**
     * Filter which Source to delete.
     */
    where: SourceWhereUniqueInput
  }

  /**
   * Source deleteMany
   */
  export type SourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sources to delete
     */
    where?: SourceWhereInput
    /**
     * Limit how many Sources to delete.
     */
    limit?: number
  }

  /**
   * Source.proxy
   */
  export type Source$proxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    where?: ProxyWhereInput
  }

  /**
   * Source.credential
   */
  export type Source$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * Source.web
   */
  export type Source$webArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    where?: WebSourceConfigWhereInput
  }

  /**
   * Source.darknet
   */
  export type Source$darknetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    where?: DarknetSourceConfigWhereInput
  }

  /**
   * Source.search
   */
  export type Source$searchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    where?: SearchEngineSourceConfigWhereInput
  }

  /**
   * Source.social
   */
  export type Source$socialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    where?: SocialMediaSourceConfigWhereInput
  }

  /**
   * Source.queries
   */
  export type Source$queriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    cursor?: QueryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Source without action
   */
  export type SourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
  }


  /**
   * Model WebSourceConfig
   */

  export type AggregateWebSourceConfig = {
    _count: WebSourceConfigCountAggregateOutputType | null
    _min: WebSourceConfigMinAggregateOutputType | null
    _max: WebSourceConfigMaxAggregateOutputType | null
  }

  export type WebSourceConfigMinAggregateOutputType = {
    sourceId: string | null
    url: string | null
    crawlerEngine: $Enums.CrawlerEngine | null
    render: boolean | null
    robotsRespect: boolean | null
    proxyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebSourceConfigMaxAggregateOutputType = {
    sourceId: string | null
    url: string | null
    crawlerEngine: $Enums.CrawlerEngine | null
    render: boolean | null
    robotsRespect: boolean | null
    proxyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WebSourceConfigCountAggregateOutputType = {
    sourceId: number
    url: number
    headers: number
    crawlerEngine: number
    render: number
    parseRules: number
    robotsRespect: number
    proxyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WebSourceConfigMinAggregateInputType = {
    sourceId?: true
    url?: true
    crawlerEngine?: true
    render?: true
    robotsRespect?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebSourceConfigMaxAggregateInputType = {
    sourceId?: true
    url?: true
    crawlerEngine?: true
    render?: true
    robotsRespect?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WebSourceConfigCountAggregateInputType = {
    sourceId?: true
    url?: true
    headers?: true
    crawlerEngine?: true
    render?: true
    parseRules?: true
    robotsRespect?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WebSourceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebSourceConfig to aggregate.
     */
    where?: WebSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSourceConfigs to fetch.
     */
    orderBy?: WebSourceConfigOrderByWithRelationInput | WebSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebSourceConfigs
    **/
    _count?: true | WebSourceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebSourceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebSourceConfigMaxAggregateInputType
  }

  export type GetWebSourceConfigAggregateType<T extends WebSourceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateWebSourceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebSourceConfig[P]>
      : GetScalarType<T[P], AggregateWebSourceConfig[P]>
  }




  export type WebSourceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebSourceConfigWhereInput
    orderBy?: WebSourceConfigOrderByWithAggregationInput | WebSourceConfigOrderByWithAggregationInput[]
    by: WebSourceConfigScalarFieldEnum[] | WebSourceConfigScalarFieldEnum
    having?: WebSourceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebSourceConfigCountAggregateInputType | true
    _min?: WebSourceConfigMinAggregateInputType
    _max?: WebSourceConfigMaxAggregateInputType
  }

  export type WebSourceConfigGroupByOutputType = {
    sourceId: string
    url: string
    headers: JsonValue | null
    crawlerEngine: $Enums.CrawlerEngine
    render: boolean
    parseRules: JsonValue | null
    robotsRespect: boolean
    proxyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WebSourceConfigCountAggregateOutputType | null
    _min: WebSourceConfigMinAggregateOutputType | null
    _max: WebSourceConfigMaxAggregateOutputType | null
  }

  type GetWebSourceConfigGroupByPayload<T extends WebSourceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebSourceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebSourceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebSourceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], WebSourceConfigGroupByOutputType[P]>
        }
      >
    >


  export type WebSourceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    render?: boolean
    parseRules?: boolean
    robotsRespect?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["webSourceConfig"]>

  export type WebSourceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    render?: boolean
    parseRules?: boolean
    robotsRespect?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["webSourceConfig"]>

  export type WebSourceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    render?: boolean
    parseRules?: boolean
    robotsRespect?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["webSourceConfig"]>

  export type WebSourceConfigSelectScalar = {
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    render?: boolean
    parseRules?: boolean
    robotsRespect?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WebSourceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sourceId" | "url" | "headers" | "crawlerEngine" | "render" | "parseRules" | "robotsRespect" | "proxyId" | "createdAt" | "updatedAt", ExtArgs["result"]["webSourceConfig"]>
  export type WebSourceConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }
  export type WebSourceConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }
  export type WebSourceConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | WebSourceConfig$proxyArgs<ExtArgs>
  }

  export type $WebSourceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebSourceConfig"
    objects: {
      source: Prisma.$SourcePayload<ExtArgs>
      proxy: Prisma.$ProxyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sourceId: string
      url: string
      headers: Prisma.JsonValue | null
      crawlerEngine: $Enums.CrawlerEngine
      render: boolean
      parseRules: Prisma.JsonValue | null
      robotsRespect: boolean
      proxyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["webSourceConfig"]>
    composites: {}
  }

  type WebSourceConfigGetPayload<S extends boolean | null | undefined | WebSourceConfigDefaultArgs> = $Result.GetResult<Prisma.$WebSourceConfigPayload, S>

  type WebSourceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WebSourceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WebSourceConfigCountAggregateInputType | true
    }

  export interface WebSourceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebSourceConfig'], meta: { name: 'WebSourceConfig' } }
    /**
     * Find zero or one WebSourceConfig that matches the filter.
     * @param {WebSourceConfigFindUniqueArgs} args - Arguments to find a WebSourceConfig
     * @example
     * // Get one WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebSourceConfigFindUniqueArgs>(args: SelectSubset<T, WebSourceConfigFindUniqueArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WebSourceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WebSourceConfigFindUniqueOrThrowArgs} args - Arguments to find a WebSourceConfig
     * @example
     * // Get one WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebSourceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, WebSourceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebSourceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigFindFirstArgs} args - Arguments to find a WebSourceConfig
     * @example
     * // Get one WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebSourceConfigFindFirstArgs>(args?: SelectSubset<T, WebSourceConfigFindFirstArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WebSourceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigFindFirstOrThrowArgs} args - Arguments to find a WebSourceConfig
     * @example
     * // Get one WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebSourceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, WebSourceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WebSourceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebSourceConfigs
     * const webSourceConfigs = await prisma.webSourceConfig.findMany()
     * 
     * // Get first 10 WebSourceConfigs
     * const webSourceConfigs = await prisma.webSourceConfig.findMany({ take: 10 })
     * 
     * // Only select the `sourceId`
     * const webSourceConfigWithSourceIdOnly = await prisma.webSourceConfig.findMany({ select: { sourceId: true } })
     * 
     */
    findMany<T extends WebSourceConfigFindManyArgs>(args?: SelectSubset<T, WebSourceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WebSourceConfig.
     * @param {WebSourceConfigCreateArgs} args - Arguments to create a WebSourceConfig.
     * @example
     * // Create one WebSourceConfig
     * const WebSourceConfig = await prisma.webSourceConfig.create({
     *   data: {
     *     // ... data to create a WebSourceConfig
     *   }
     * })
     * 
     */
    create<T extends WebSourceConfigCreateArgs>(args: SelectSubset<T, WebSourceConfigCreateArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WebSourceConfigs.
     * @param {WebSourceConfigCreateManyArgs} args - Arguments to create many WebSourceConfigs.
     * @example
     * // Create many WebSourceConfigs
     * const webSourceConfig = await prisma.webSourceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebSourceConfigCreateManyArgs>(args?: SelectSubset<T, WebSourceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebSourceConfigs and returns the data saved in the database.
     * @param {WebSourceConfigCreateManyAndReturnArgs} args - Arguments to create many WebSourceConfigs.
     * @example
     * // Create many WebSourceConfigs
     * const webSourceConfig = await prisma.webSourceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebSourceConfigs and only return the `sourceId`
     * const webSourceConfigWithSourceIdOnly = await prisma.webSourceConfig.createManyAndReturn({
     *   select: { sourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebSourceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, WebSourceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WebSourceConfig.
     * @param {WebSourceConfigDeleteArgs} args - Arguments to delete one WebSourceConfig.
     * @example
     * // Delete one WebSourceConfig
     * const WebSourceConfig = await prisma.webSourceConfig.delete({
     *   where: {
     *     // ... filter to delete one WebSourceConfig
     *   }
     * })
     * 
     */
    delete<T extends WebSourceConfigDeleteArgs>(args: SelectSubset<T, WebSourceConfigDeleteArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WebSourceConfig.
     * @param {WebSourceConfigUpdateArgs} args - Arguments to update one WebSourceConfig.
     * @example
     * // Update one WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebSourceConfigUpdateArgs>(args: SelectSubset<T, WebSourceConfigUpdateArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WebSourceConfigs.
     * @param {WebSourceConfigDeleteManyArgs} args - Arguments to filter WebSourceConfigs to delete.
     * @example
     * // Delete a few WebSourceConfigs
     * const { count } = await prisma.webSourceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebSourceConfigDeleteManyArgs>(args?: SelectSubset<T, WebSourceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebSourceConfigs
     * const webSourceConfig = await prisma.webSourceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebSourceConfigUpdateManyArgs>(args: SelectSubset<T, WebSourceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebSourceConfigs and returns the data updated in the database.
     * @param {WebSourceConfigUpdateManyAndReturnArgs} args - Arguments to update many WebSourceConfigs.
     * @example
     * // Update many WebSourceConfigs
     * const webSourceConfig = await prisma.webSourceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WebSourceConfigs and only return the `sourceId`
     * const webSourceConfigWithSourceIdOnly = await prisma.webSourceConfig.updateManyAndReturn({
     *   select: { sourceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WebSourceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, WebSourceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WebSourceConfig.
     * @param {WebSourceConfigUpsertArgs} args - Arguments to update or create a WebSourceConfig.
     * @example
     * // Update or create a WebSourceConfig
     * const webSourceConfig = await prisma.webSourceConfig.upsert({
     *   create: {
     *     // ... data to create a WebSourceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebSourceConfig we want to update
     *   }
     * })
     */
    upsert<T extends WebSourceConfigUpsertArgs>(args: SelectSubset<T, WebSourceConfigUpsertArgs<ExtArgs>>): Prisma__WebSourceConfigClient<$Result.GetResult<Prisma.$WebSourceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WebSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigCountArgs} args - Arguments to filter WebSourceConfigs to count.
     * @example
     * // Count the number of WebSourceConfigs
     * const count = await prisma.webSourceConfig.count({
     *   where: {
     *     // ... the filter for the WebSourceConfigs we want to count
     *   }
     * })
    **/
    count<T extends WebSourceConfigCountArgs>(
      args?: Subset<T, WebSourceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebSourceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebSourceConfigAggregateArgs>(args: Subset<T, WebSourceConfigAggregateArgs>): Prisma.PrismaPromise<GetWebSourceConfigAggregateType<T>>

    /**
     * Group by WebSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebSourceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebSourceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebSourceConfigGroupByArgs['orderBy'] }
        : { orderBy?: WebSourceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebSourceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebSourceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebSourceConfig model
   */
  readonly fields: WebSourceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebSourceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebSourceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proxy<T extends WebSourceConfig$proxyArgs<ExtArgs> = {}>(args?: Subset<T, WebSourceConfig$proxyArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebSourceConfig model
   */
  interface WebSourceConfigFieldRefs {
    readonly sourceId: FieldRef<"WebSourceConfig", 'String'>
    readonly url: FieldRef<"WebSourceConfig", 'String'>
    readonly headers: FieldRef<"WebSourceConfig", 'Json'>
    readonly crawlerEngine: FieldRef<"WebSourceConfig", 'CrawlerEngine'>
    readonly render: FieldRef<"WebSourceConfig", 'Boolean'>
    readonly parseRules: FieldRef<"WebSourceConfig", 'Json'>
    readonly robotsRespect: FieldRef<"WebSourceConfig", 'Boolean'>
    readonly proxyId: FieldRef<"WebSourceConfig", 'String'>
    readonly createdAt: FieldRef<"WebSourceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"WebSourceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebSourceConfig findUnique
   */
  export type WebSourceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebSourceConfig to fetch.
     */
    where: WebSourceConfigWhereUniqueInput
  }

  /**
   * WebSourceConfig findUniqueOrThrow
   */
  export type WebSourceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebSourceConfig to fetch.
     */
    where: WebSourceConfigWhereUniqueInput
  }

  /**
   * WebSourceConfig findFirst
   */
  export type WebSourceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebSourceConfig to fetch.
     */
    where?: WebSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSourceConfigs to fetch.
     */
    orderBy?: WebSourceConfigOrderByWithRelationInput | WebSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebSourceConfigs.
     */
    cursor?: WebSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebSourceConfigs.
     */
    distinct?: WebSourceConfigScalarFieldEnum | WebSourceConfigScalarFieldEnum[]
  }

  /**
   * WebSourceConfig findFirstOrThrow
   */
  export type WebSourceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebSourceConfig to fetch.
     */
    where?: WebSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSourceConfigs to fetch.
     */
    orderBy?: WebSourceConfigOrderByWithRelationInput | WebSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebSourceConfigs.
     */
    cursor?: WebSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebSourceConfigs.
     */
    distinct?: WebSourceConfigScalarFieldEnum | WebSourceConfigScalarFieldEnum[]
  }

  /**
   * WebSourceConfig findMany
   */
  export type WebSourceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which WebSourceConfigs to fetch.
     */
    where?: WebSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebSourceConfigs to fetch.
     */
    orderBy?: WebSourceConfigOrderByWithRelationInput | WebSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebSourceConfigs.
     */
    cursor?: WebSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebSourceConfigs.
     */
    skip?: number
    distinct?: WebSourceConfigScalarFieldEnum | WebSourceConfigScalarFieldEnum[]
  }

  /**
   * WebSourceConfig create
   */
  export type WebSourceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a WebSourceConfig.
     */
    data: XOR<WebSourceConfigCreateInput, WebSourceConfigUncheckedCreateInput>
  }

  /**
   * WebSourceConfig createMany
   */
  export type WebSourceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebSourceConfigs.
     */
    data: WebSourceConfigCreateManyInput | WebSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WebSourceConfig createManyAndReturn
   */
  export type WebSourceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many WebSourceConfigs.
     */
    data: WebSourceConfigCreateManyInput | WebSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebSourceConfig update
   */
  export type WebSourceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a WebSourceConfig.
     */
    data: XOR<WebSourceConfigUpdateInput, WebSourceConfigUncheckedUpdateInput>
    /**
     * Choose, which WebSourceConfig to update.
     */
    where: WebSourceConfigWhereUniqueInput
  }

  /**
   * WebSourceConfig updateMany
   */
  export type WebSourceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebSourceConfigs.
     */
    data: XOR<WebSourceConfigUpdateManyMutationInput, WebSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which WebSourceConfigs to update
     */
    where?: WebSourceConfigWhereInput
    /**
     * Limit how many WebSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * WebSourceConfig updateManyAndReturn
   */
  export type WebSourceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to update WebSourceConfigs.
     */
    data: XOR<WebSourceConfigUpdateManyMutationInput, WebSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which WebSourceConfigs to update
     */
    where?: WebSourceConfigWhereInput
    /**
     * Limit how many WebSourceConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebSourceConfig upsert
   */
  export type WebSourceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the WebSourceConfig to update in case it exists.
     */
    where: WebSourceConfigWhereUniqueInput
    /**
     * In case the WebSourceConfig found by the `where` argument doesn't exist, create a new WebSourceConfig with this data.
     */
    create: XOR<WebSourceConfigCreateInput, WebSourceConfigUncheckedCreateInput>
    /**
     * In case the WebSourceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebSourceConfigUpdateInput, WebSourceConfigUncheckedUpdateInput>
  }

  /**
   * WebSourceConfig delete
   */
  export type WebSourceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
    /**
     * Filter which WebSourceConfig to delete.
     */
    where: WebSourceConfigWhereUniqueInput
  }

  /**
   * WebSourceConfig deleteMany
   */
  export type WebSourceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebSourceConfigs to delete
     */
    where?: WebSourceConfigWhereInput
    /**
     * Limit how many WebSourceConfigs to delete.
     */
    limit?: number
  }

  /**
   * WebSourceConfig.proxy
   */
  export type WebSourceConfig$proxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    where?: ProxyWhereInput
  }

  /**
   * WebSourceConfig without action
   */
  export type WebSourceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebSourceConfig
     */
    select?: WebSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WebSourceConfig
     */
    omit?: WebSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebSourceConfigInclude<ExtArgs> | null
  }


  /**
   * Model DarknetSourceConfig
   */

  export type AggregateDarknetSourceConfig = {
    _count: DarknetSourceConfigCountAggregateOutputType | null
    _min: DarknetSourceConfigMinAggregateOutputType | null
    _max: DarknetSourceConfigMaxAggregateOutputType | null
  }

  export type DarknetSourceConfigMinAggregateOutputType = {
    sourceId: string | null
    url: string | null
    crawlerEngine: $Enums.CrawlerEngine | null
    proxyId: string | null
    render: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DarknetSourceConfigMaxAggregateOutputType = {
    sourceId: string | null
    url: string | null
    crawlerEngine: $Enums.CrawlerEngine | null
    proxyId: string | null
    render: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DarknetSourceConfigCountAggregateOutputType = {
    sourceId: number
    url: number
    headers: number
    crawlerEngine: number
    proxyId: number
    render: number
    parseRules: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DarknetSourceConfigMinAggregateInputType = {
    sourceId?: true
    url?: true
    crawlerEngine?: true
    proxyId?: true
    render?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DarknetSourceConfigMaxAggregateInputType = {
    sourceId?: true
    url?: true
    crawlerEngine?: true
    proxyId?: true
    render?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DarknetSourceConfigCountAggregateInputType = {
    sourceId?: true
    url?: true
    headers?: true
    crawlerEngine?: true
    proxyId?: true
    render?: true
    parseRules?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DarknetSourceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarknetSourceConfig to aggregate.
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarknetSourceConfigs to fetch.
     */
    orderBy?: DarknetSourceConfigOrderByWithRelationInput | DarknetSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DarknetSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarknetSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarknetSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DarknetSourceConfigs
    **/
    _count?: true | DarknetSourceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DarknetSourceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DarknetSourceConfigMaxAggregateInputType
  }

  export type GetDarknetSourceConfigAggregateType<T extends DarknetSourceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateDarknetSourceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDarknetSourceConfig[P]>
      : GetScalarType<T[P], AggregateDarknetSourceConfig[P]>
  }




  export type DarknetSourceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DarknetSourceConfigWhereInput
    orderBy?: DarknetSourceConfigOrderByWithAggregationInput | DarknetSourceConfigOrderByWithAggregationInput[]
    by: DarknetSourceConfigScalarFieldEnum[] | DarknetSourceConfigScalarFieldEnum
    having?: DarknetSourceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DarknetSourceConfigCountAggregateInputType | true
    _min?: DarknetSourceConfigMinAggregateInputType
    _max?: DarknetSourceConfigMaxAggregateInputType
  }

  export type DarknetSourceConfigGroupByOutputType = {
    sourceId: string
    url: string
    headers: JsonValue | null
    crawlerEngine: $Enums.CrawlerEngine
    proxyId: string
    render: boolean
    parseRules: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: DarknetSourceConfigCountAggregateOutputType | null
    _min: DarknetSourceConfigMinAggregateOutputType | null
    _max: DarknetSourceConfigMaxAggregateOutputType | null
  }

  type GetDarknetSourceConfigGroupByPayload<T extends DarknetSourceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DarknetSourceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DarknetSourceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DarknetSourceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], DarknetSourceConfigGroupByOutputType[P]>
        }
      >
    >


  export type DarknetSourceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    proxyId?: boolean
    render?: boolean
    parseRules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["darknetSourceConfig"]>

  export type DarknetSourceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    proxyId?: boolean
    render?: boolean
    parseRules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["darknetSourceConfig"]>

  export type DarknetSourceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    proxyId?: boolean
    render?: boolean
    parseRules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["darknetSourceConfig"]>

  export type DarknetSourceConfigSelectScalar = {
    sourceId?: boolean
    url?: boolean
    headers?: boolean
    crawlerEngine?: boolean
    proxyId?: boolean
    render?: boolean
    parseRules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DarknetSourceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sourceId" | "url" | "headers" | "crawlerEngine" | "proxyId" | "render" | "parseRules" | "createdAt" | "updatedAt", ExtArgs["result"]["darknetSourceConfig"]>
  export type DarknetSourceConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }
  export type DarknetSourceConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }
  export type DarknetSourceConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    proxy?: boolean | ProxyDefaultArgs<ExtArgs>
  }

  export type $DarknetSourceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DarknetSourceConfig"
    objects: {
      source: Prisma.$SourcePayload<ExtArgs>
      proxy: Prisma.$ProxyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sourceId: string
      url: string
      headers: Prisma.JsonValue | null
      crawlerEngine: $Enums.CrawlerEngine
      proxyId: string
      render: boolean
      parseRules: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["darknetSourceConfig"]>
    composites: {}
  }

  type DarknetSourceConfigGetPayload<S extends boolean | null | undefined | DarknetSourceConfigDefaultArgs> = $Result.GetResult<Prisma.$DarknetSourceConfigPayload, S>

  type DarknetSourceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DarknetSourceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DarknetSourceConfigCountAggregateInputType | true
    }

  export interface DarknetSourceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DarknetSourceConfig'], meta: { name: 'DarknetSourceConfig' } }
    /**
     * Find zero or one DarknetSourceConfig that matches the filter.
     * @param {DarknetSourceConfigFindUniqueArgs} args - Arguments to find a DarknetSourceConfig
     * @example
     * // Get one DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DarknetSourceConfigFindUniqueArgs>(args: SelectSubset<T, DarknetSourceConfigFindUniqueArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DarknetSourceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DarknetSourceConfigFindUniqueOrThrowArgs} args - Arguments to find a DarknetSourceConfig
     * @example
     * // Get one DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DarknetSourceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, DarknetSourceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DarknetSourceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigFindFirstArgs} args - Arguments to find a DarknetSourceConfig
     * @example
     * // Get one DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DarknetSourceConfigFindFirstArgs>(args?: SelectSubset<T, DarknetSourceConfigFindFirstArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DarknetSourceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigFindFirstOrThrowArgs} args - Arguments to find a DarknetSourceConfig
     * @example
     * // Get one DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DarknetSourceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, DarknetSourceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DarknetSourceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DarknetSourceConfigs
     * const darknetSourceConfigs = await prisma.darknetSourceConfig.findMany()
     * 
     * // Get first 10 DarknetSourceConfigs
     * const darknetSourceConfigs = await prisma.darknetSourceConfig.findMany({ take: 10 })
     * 
     * // Only select the `sourceId`
     * const darknetSourceConfigWithSourceIdOnly = await prisma.darknetSourceConfig.findMany({ select: { sourceId: true } })
     * 
     */
    findMany<T extends DarknetSourceConfigFindManyArgs>(args?: SelectSubset<T, DarknetSourceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DarknetSourceConfig.
     * @param {DarknetSourceConfigCreateArgs} args - Arguments to create a DarknetSourceConfig.
     * @example
     * // Create one DarknetSourceConfig
     * const DarknetSourceConfig = await prisma.darknetSourceConfig.create({
     *   data: {
     *     // ... data to create a DarknetSourceConfig
     *   }
     * })
     * 
     */
    create<T extends DarknetSourceConfigCreateArgs>(args: SelectSubset<T, DarknetSourceConfigCreateArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DarknetSourceConfigs.
     * @param {DarknetSourceConfigCreateManyArgs} args - Arguments to create many DarknetSourceConfigs.
     * @example
     * // Create many DarknetSourceConfigs
     * const darknetSourceConfig = await prisma.darknetSourceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DarknetSourceConfigCreateManyArgs>(args?: SelectSubset<T, DarknetSourceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DarknetSourceConfigs and returns the data saved in the database.
     * @param {DarknetSourceConfigCreateManyAndReturnArgs} args - Arguments to create many DarknetSourceConfigs.
     * @example
     * // Create many DarknetSourceConfigs
     * const darknetSourceConfig = await prisma.darknetSourceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DarknetSourceConfigs and only return the `sourceId`
     * const darknetSourceConfigWithSourceIdOnly = await prisma.darknetSourceConfig.createManyAndReturn({
     *   select: { sourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DarknetSourceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, DarknetSourceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DarknetSourceConfig.
     * @param {DarknetSourceConfigDeleteArgs} args - Arguments to delete one DarknetSourceConfig.
     * @example
     * // Delete one DarknetSourceConfig
     * const DarknetSourceConfig = await prisma.darknetSourceConfig.delete({
     *   where: {
     *     // ... filter to delete one DarknetSourceConfig
     *   }
     * })
     * 
     */
    delete<T extends DarknetSourceConfigDeleteArgs>(args: SelectSubset<T, DarknetSourceConfigDeleteArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DarknetSourceConfig.
     * @param {DarknetSourceConfigUpdateArgs} args - Arguments to update one DarknetSourceConfig.
     * @example
     * // Update one DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DarknetSourceConfigUpdateArgs>(args: SelectSubset<T, DarknetSourceConfigUpdateArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DarknetSourceConfigs.
     * @param {DarknetSourceConfigDeleteManyArgs} args - Arguments to filter DarknetSourceConfigs to delete.
     * @example
     * // Delete a few DarknetSourceConfigs
     * const { count } = await prisma.darknetSourceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DarknetSourceConfigDeleteManyArgs>(args?: SelectSubset<T, DarknetSourceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarknetSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DarknetSourceConfigs
     * const darknetSourceConfig = await prisma.darknetSourceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DarknetSourceConfigUpdateManyArgs>(args: SelectSubset<T, DarknetSourceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DarknetSourceConfigs and returns the data updated in the database.
     * @param {DarknetSourceConfigUpdateManyAndReturnArgs} args - Arguments to update many DarknetSourceConfigs.
     * @example
     * // Update many DarknetSourceConfigs
     * const darknetSourceConfig = await prisma.darknetSourceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DarknetSourceConfigs and only return the `sourceId`
     * const darknetSourceConfigWithSourceIdOnly = await prisma.darknetSourceConfig.updateManyAndReturn({
     *   select: { sourceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DarknetSourceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, DarknetSourceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DarknetSourceConfig.
     * @param {DarknetSourceConfigUpsertArgs} args - Arguments to update or create a DarknetSourceConfig.
     * @example
     * // Update or create a DarknetSourceConfig
     * const darknetSourceConfig = await prisma.darknetSourceConfig.upsert({
     *   create: {
     *     // ... data to create a DarknetSourceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DarknetSourceConfig we want to update
     *   }
     * })
     */
    upsert<T extends DarknetSourceConfigUpsertArgs>(args: SelectSubset<T, DarknetSourceConfigUpsertArgs<ExtArgs>>): Prisma__DarknetSourceConfigClient<$Result.GetResult<Prisma.$DarknetSourceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DarknetSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigCountArgs} args - Arguments to filter DarknetSourceConfigs to count.
     * @example
     * // Count the number of DarknetSourceConfigs
     * const count = await prisma.darknetSourceConfig.count({
     *   where: {
     *     // ... the filter for the DarknetSourceConfigs we want to count
     *   }
     * })
    **/
    count<T extends DarknetSourceConfigCountArgs>(
      args?: Subset<T, DarknetSourceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DarknetSourceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DarknetSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DarknetSourceConfigAggregateArgs>(args: Subset<T, DarknetSourceConfigAggregateArgs>): Prisma.PrismaPromise<GetDarknetSourceConfigAggregateType<T>>

    /**
     * Group by DarknetSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DarknetSourceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DarknetSourceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DarknetSourceConfigGroupByArgs['orderBy'] }
        : { orderBy?: DarknetSourceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DarknetSourceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDarknetSourceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DarknetSourceConfig model
   */
  readonly fields: DarknetSourceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DarknetSourceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DarknetSourceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    proxy<T extends ProxyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProxyDefaultArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DarknetSourceConfig model
   */
  interface DarknetSourceConfigFieldRefs {
    readonly sourceId: FieldRef<"DarknetSourceConfig", 'String'>
    readonly url: FieldRef<"DarknetSourceConfig", 'String'>
    readonly headers: FieldRef<"DarknetSourceConfig", 'Json'>
    readonly crawlerEngine: FieldRef<"DarknetSourceConfig", 'CrawlerEngine'>
    readonly proxyId: FieldRef<"DarknetSourceConfig", 'String'>
    readonly render: FieldRef<"DarknetSourceConfig", 'Boolean'>
    readonly parseRules: FieldRef<"DarknetSourceConfig", 'Json'>
    readonly createdAt: FieldRef<"DarknetSourceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"DarknetSourceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DarknetSourceConfig findUnique
   */
  export type DarknetSourceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which DarknetSourceConfig to fetch.
     */
    where: DarknetSourceConfigWhereUniqueInput
  }

  /**
   * DarknetSourceConfig findUniqueOrThrow
   */
  export type DarknetSourceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which DarknetSourceConfig to fetch.
     */
    where: DarknetSourceConfigWhereUniqueInput
  }

  /**
   * DarknetSourceConfig findFirst
   */
  export type DarknetSourceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which DarknetSourceConfig to fetch.
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarknetSourceConfigs to fetch.
     */
    orderBy?: DarknetSourceConfigOrderByWithRelationInput | DarknetSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarknetSourceConfigs.
     */
    cursor?: DarknetSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarknetSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarknetSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarknetSourceConfigs.
     */
    distinct?: DarknetSourceConfigScalarFieldEnum | DarknetSourceConfigScalarFieldEnum[]
  }

  /**
   * DarknetSourceConfig findFirstOrThrow
   */
  export type DarknetSourceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which DarknetSourceConfig to fetch.
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarknetSourceConfigs to fetch.
     */
    orderBy?: DarknetSourceConfigOrderByWithRelationInput | DarknetSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DarknetSourceConfigs.
     */
    cursor?: DarknetSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarknetSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarknetSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DarknetSourceConfigs.
     */
    distinct?: DarknetSourceConfigScalarFieldEnum | DarknetSourceConfigScalarFieldEnum[]
  }

  /**
   * DarknetSourceConfig findMany
   */
  export type DarknetSourceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which DarknetSourceConfigs to fetch.
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DarknetSourceConfigs to fetch.
     */
    orderBy?: DarknetSourceConfigOrderByWithRelationInput | DarknetSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DarknetSourceConfigs.
     */
    cursor?: DarknetSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DarknetSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DarknetSourceConfigs.
     */
    skip?: number
    distinct?: DarknetSourceConfigScalarFieldEnum | DarknetSourceConfigScalarFieldEnum[]
  }

  /**
   * DarknetSourceConfig create
   */
  export type DarknetSourceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a DarknetSourceConfig.
     */
    data: XOR<DarknetSourceConfigCreateInput, DarknetSourceConfigUncheckedCreateInput>
  }

  /**
   * DarknetSourceConfig createMany
   */
  export type DarknetSourceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DarknetSourceConfigs.
     */
    data: DarknetSourceConfigCreateManyInput | DarknetSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DarknetSourceConfig createManyAndReturn
   */
  export type DarknetSourceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many DarknetSourceConfigs.
     */
    data: DarknetSourceConfigCreateManyInput | DarknetSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DarknetSourceConfig update
   */
  export type DarknetSourceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a DarknetSourceConfig.
     */
    data: XOR<DarknetSourceConfigUpdateInput, DarknetSourceConfigUncheckedUpdateInput>
    /**
     * Choose, which DarknetSourceConfig to update.
     */
    where: DarknetSourceConfigWhereUniqueInput
  }

  /**
   * DarknetSourceConfig updateMany
   */
  export type DarknetSourceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DarknetSourceConfigs.
     */
    data: XOR<DarknetSourceConfigUpdateManyMutationInput, DarknetSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which DarknetSourceConfigs to update
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * Limit how many DarknetSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * DarknetSourceConfig updateManyAndReturn
   */
  export type DarknetSourceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to update DarknetSourceConfigs.
     */
    data: XOR<DarknetSourceConfigUpdateManyMutationInput, DarknetSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which DarknetSourceConfigs to update
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * Limit how many DarknetSourceConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DarknetSourceConfig upsert
   */
  export type DarknetSourceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the DarknetSourceConfig to update in case it exists.
     */
    where: DarknetSourceConfigWhereUniqueInput
    /**
     * In case the DarknetSourceConfig found by the `where` argument doesn't exist, create a new DarknetSourceConfig with this data.
     */
    create: XOR<DarknetSourceConfigCreateInput, DarknetSourceConfigUncheckedCreateInput>
    /**
     * In case the DarknetSourceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DarknetSourceConfigUpdateInput, DarknetSourceConfigUncheckedUpdateInput>
  }

  /**
   * DarknetSourceConfig delete
   */
  export type DarknetSourceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
    /**
     * Filter which DarknetSourceConfig to delete.
     */
    where: DarknetSourceConfigWhereUniqueInput
  }

  /**
   * DarknetSourceConfig deleteMany
   */
  export type DarknetSourceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DarknetSourceConfigs to delete
     */
    where?: DarknetSourceConfigWhereInput
    /**
     * Limit how many DarknetSourceConfigs to delete.
     */
    limit?: number
  }

  /**
   * DarknetSourceConfig without action
   */
  export type DarknetSourceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DarknetSourceConfig
     */
    select?: DarknetSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DarknetSourceConfig
     */
    omit?: DarknetSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DarknetSourceConfigInclude<ExtArgs> | null
  }


  /**
   * Model SearchEngineSourceConfig
   */

  export type AggregateSearchEngineSourceConfig = {
    _count: SearchEngineSourceConfigCountAggregateOutputType | null
    _min: SearchEngineSourceConfigMinAggregateOutputType | null
    _max: SearchEngineSourceConfigMaxAggregateOutputType | null
  }

  export type SearchEngineSourceConfigMinAggregateOutputType = {
    sourceId: string | null
    engine: $Enums.SearchEngineKind | null
    query: string | null
    region: string | null
    lang: string | null
    apiEndpoint: string | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchEngineSourceConfigMaxAggregateOutputType = {
    sourceId: string | null
    engine: $Enums.SearchEngineKind | null
    query: string | null
    region: string | null
    lang: string | null
    apiEndpoint: string | null
    credentialId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SearchEngineSourceConfigCountAggregateOutputType = {
    sourceId: number
    engine: number
    query: number
    region: number
    lang: number
    apiEndpoint: number
    options: number
    credentialId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SearchEngineSourceConfigMinAggregateInputType = {
    sourceId?: true
    engine?: true
    query?: true
    region?: true
    lang?: true
    apiEndpoint?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchEngineSourceConfigMaxAggregateInputType = {
    sourceId?: true
    engine?: true
    query?: true
    region?: true
    lang?: true
    apiEndpoint?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SearchEngineSourceConfigCountAggregateInputType = {
    sourceId?: true
    engine?: true
    query?: true
    region?: true
    lang?: true
    apiEndpoint?: true
    options?: true
    credentialId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SearchEngineSourceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchEngineSourceConfig to aggregate.
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchEngineSourceConfigs to fetch.
     */
    orderBy?: SearchEngineSourceConfigOrderByWithRelationInput | SearchEngineSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchEngineSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchEngineSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchEngineSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchEngineSourceConfigs
    **/
    _count?: true | SearchEngineSourceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchEngineSourceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchEngineSourceConfigMaxAggregateInputType
  }

  export type GetSearchEngineSourceConfigAggregateType<T extends SearchEngineSourceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchEngineSourceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchEngineSourceConfig[P]>
      : GetScalarType<T[P], AggregateSearchEngineSourceConfig[P]>
  }




  export type SearchEngineSourceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchEngineSourceConfigWhereInput
    orderBy?: SearchEngineSourceConfigOrderByWithAggregationInput | SearchEngineSourceConfigOrderByWithAggregationInput[]
    by: SearchEngineSourceConfigScalarFieldEnum[] | SearchEngineSourceConfigScalarFieldEnum
    having?: SearchEngineSourceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchEngineSourceConfigCountAggregateInputType | true
    _min?: SearchEngineSourceConfigMinAggregateInputType
    _max?: SearchEngineSourceConfigMaxAggregateInputType
  }

  export type SearchEngineSourceConfigGroupByOutputType = {
    sourceId: string
    engine: $Enums.SearchEngineKind
    query: string
    region: string | null
    lang: string | null
    apiEndpoint: string | null
    options: JsonValue | null
    credentialId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SearchEngineSourceConfigCountAggregateOutputType | null
    _min: SearchEngineSourceConfigMinAggregateOutputType | null
    _max: SearchEngineSourceConfigMaxAggregateOutputType | null
  }

  type GetSearchEngineSourceConfigGroupByPayload<T extends SearchEngineSourceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchEngineSourceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchEngineSourceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchEngineSourceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SearchEngineSourceConfigGroupByOutputType[P]>
        }
      >
    >


  export type SearchEngineSourceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    engine?: boolean
    query?: boolean
    region?: boolean
    lang?: boolean
    apiEndpoint?: boolean
    options?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["searchEngineSourceConfig"]>

  export type SearchEngineSourceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    engine?: boolean
    query?: boolean
    region?: boolean
    lang?: boolean
    apiEndpoint?: boolean
    options?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["searchEngineSourceConfig"]>

  export type SearchEngineSourceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    engine?: boolean
    query?: boolean
    region?: boolean
    lang?: boolean
    apiEndpoint?: boolean
    options?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }, ExtArgs["result"]["searchEngineSourceConfig"]>

  export type SearchEngineSourceConfigSelectScalar = {
    sourceId?: boolean
    engine?: boolean
    query?: boolean
    region?: boolean
    lang?: boolean
    apiEndpoint?: boolean
    options?: boolean
    credentialId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SearchEngineSourceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sourceId" | "engine" | "query" | "region" | "lang" | "apiEndpoint" | "options" | "credentialId" | "createdAt" | "updatedAt", ExtArgs["result"]["searchEngineSourceConfig"]>
  export type SearchEngineSourceConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }
  export type SearchEngineSourceConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }
  export type SearchEngineSourceConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SearchEngineSourceConfig$credentialArgs<ExtArgs>
  }

  export type $SearchEngineSourceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchEngineSourceConfig"
    objects: {
      source: Prisma.$SourcePayload<ExtArgs>
      credential: Prisma.$CredentialPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sourceId: string
      engine: $Enums.SearchEngineKind
      query: string
      region: string | null
      lang: string | null
      apiEndpoint: string | null
      options: Prisma.JsonValue | null
      credentialId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["searchEngineSourceConfig"]>
    composites: {}
  }

  type SearchEngineSourceConfigGetPayload<S extends boolean | null | undefined | SearchEngineSourceConfigDefaultArgs> = $Result.GetResult<Prisma.$SearchEngineSourceConfigPayload, S>

  type SearchEngineSourceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchEngineSourceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchEngineSourceConfigCountAggregateInputType | true
    }

  export interface SearchEngineSourceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchEngineSourceConfig'], meta: { name: 'SearchEngineSourceConfig' } }
    /**
     * Find zero or one SearchEngineSourceConfig that matches the filter.
     * @param {SearchEngineSourceConfigFindUniqueArgs} args - Arguments to find a SearchEngineSourceConfig
     * @example
     * // Get one SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchEngineSourceConfigFindUniqueArgs>(args: SelectSubset<T, SearchEngineSourceConfigFindUniqueArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchEngineSourceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchEngineSourceConfigFindUniqueOrThrowArgs} args - Arguments to find a SearchEngineSourceConfig
     * @example
     * // Get one SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchEngineSourceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchEngineSourceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchEngineSourceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigFindFirstArgs} args - Arguments to find a SearchEngineSourceConfig
     * @example
     * // Get one SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchEngineSourceConfigFindFirstArgs>(args?: SelectSubset<T, SearchEngineSourceConfigFindFirstArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchEngineSourceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigFindFirstOrThrowArgs} args - Arguments to find a SearchEngineSourceConfig
     * @example
     * // Get one SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchEngineSourceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchEngineSourceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchEngineSourceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchEngineSourceConfigs
     * const searchEngineSourceConfigs = await prisma.searchEngineSourceConfig.findMany()
     * 
     * // Get first 10 SearchEngineSourceConfigs
     * const searchEngineSourceConfigs = await prisma.searchEngineSourceConfig.findMany({ take: 10 })
     * 
     * // Only select the `sourceId`
     * const searchEngineSourceConfigWithSourceIdOnly = await prisma.searchEngineSourceConfig.findMany({ select: { sourceId: true } })
     * 
     */
    findMany<T extends SearchEngineSourceConfigFindManyArgs>(args?: SelectSubset<T, SearchEngineSourceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchEngineSourceConfig.
     * @param {SearchEngineSourceConfigCreateArgs} args - Arguments to create a SearchEngineSourceConfig.
     * @example
     * // Create one SearchEngineSourceConfig
     * const SearchEngineSourceConfig = await prisma.searchEngineSourceConfig.create({
     *   data: {
     *     // ... data to create a SearchEngineSourceConfig
     *   }
     * })
     * 
     */
    create<T extends SearchEngineSourceConfigCreateArgs>(args: SelectSubset<T, SearchEngineSourceConfigCreateArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchEngineSourceConfigs.
     * @param {SearchEngineSourceConfigCreateManyArgs} args - Arguments to create many SearchEngineSourceConfigs.
     * @example
     * // Create many SearchEngineSourceConfigs
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchEngineSourceConfigCreateManyArgs>(args?: SelectSubset<T, SearchEngineSourceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchEngineSourceConfigs and returns the data saved in the database.
     * @param {SearchEngineSourceConfigCreateManyAndReturnArgs} args - Arguments to create many SearchEngineSourceConfigs.
     * @example
     * // Create many SearchEngineSourceConfigs
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchEngineSourceConfigs and only return the `sourceId`
     * const searchEngineSourceConfigWithSourceIdOnly = await prisma.searchEngineSourceConfig.createManyAndReturn({
     *   select: { sourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchEngineSourceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchEngineSourceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SearchEngineSourceConfig.
     * @param {SearchEngineSourceConfigDeleteArgs} args - Arguments to delete one SearchEngineSourceConfig.
     * @example
     * // Delete one SearchEngineSourceConfig
     * const SearchEngineSourceConfig = await prisma.searchEngineSourceConfig.delete({
     *   where: {
     *     // ... filter to delete one SearchEngineSourceConfig
     *   }
     * })
     * 
     */
    delete<T extends SearchEngineSourceConfigDeleteArgs>(args: SelectSubset<T, SearchEngineSourceConfigDeleteArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchEngineSourceConfig.
     * @param {SearchEngineSourceConfigUpdateArgs} args - Arguments to update one SearchEngineSourceConfig.
     * @example
     * // Update one SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchEngineSourceConfigUpdateArgs>(args: SelectSubset<T, SearchEngineSourceConfigUpdateArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchEngineSourceConfigs.
     * @param {SearchEngineSourceConfigDeleteManyArgs} args - Arguments to filter SearchEngineSourceConfigs to delete.
     * @example
     * // Delete a few SearchEngineSourceConfigs
     * const { count } = await prisma.searchEngineSourceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchEngineSourceConfigDeleteManyArgs>(args?: SelectSubset<T, SearchEngineSourceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchEngineSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchEngineSourceConfigs
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchEngineSourceConfigUpdateManyArgs>(args: SelectSubset<T, SearchEngineSourceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchEngineSourceConfigs and returns the data updated in the database.
     * @param {SearchEngineSourceConfigUpdateManyAndReturnArgs} args - Arguments to update many SearchEngineSourceConfigs.
     * @example
     * // Update many SearchEngineSourceConfigs
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SearchEngineSourceConfigs and only return the `sourceId`
     * const searchEngineSourceConfigWithSourceIdOnly = await prisma.searchEngineSourceConfig.updateManyAndReturn({
     *   select: { sourceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SearchEngineSourceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SearchEngineSourceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SearchEngineSourceConfig.
     * @param {SearchEngineSourceConfigUpsertArgs} args - Arguments to update or create a SearchEngineSourceConfig.
     * @example
     * // Update or create a SearchEngineSourceConfig
     * const searchEngineSourceConfig = await prisma.searchEngineSourceConfig.upsert({
     *   create: {
     *     // ... data to create a SearchEngineSourceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchEngineSourceConfig we want to update
     *   }
     * })
     */
    upsert<T extends SearchEngineSourceConfigUpsertArgs>(args: SelectSubset<T, SearchEngineSourceConfigUpsertArgs<ExtArgs>>): Prisma__SearchEngineSourceConfigClient<$Result.GetResult<Prisma.$SearchEngineSourceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchEngineSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigCountArgs} args - Arguments to filter SearchEngineSourceConfigs to count.
     * @example
     * // Count the number of SearchEngineSourceConfigs
     * const count = await prisma.searchEngineSourceConfig.count({
     *   where: {
     *     // ... the filter for the SearchEngineSourceConfigs we want to count
     *   }
     * })
    **/
    count<T extends SearchEngineSourceConfigCountArgs>(
      args?: Subset<T, SearchEngineSourceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchEngineSourceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchEngineSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchEngineSourceConfigAggregateArgs>(args: Subset<T, SearchEngineSourceConfigAggregateArgs>): Prisma.PrismaPromise<GetSearchEngineSourceConfigAggregateType<T>>

    /**
     * Group by SearchEngineSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchEngineSourceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchEngineSourceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchEngineSourceConfigGroupByArgs['orderBy'] }
        : { orderBy?: SearchEngineSourceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchEngineSourceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchEngineSourceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchEngineSourceConfig model
   */
  readonly fields: SearchEngineSourceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchEngineSourceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchEngineSourceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credential<T extends SearchEngineSourceConfig$credentialArgs<ExtArgs> = {}>(args?: Subset<T, SearchEngineSourceConfig$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchEngineSourceConfig model
   */
  interface SearchEngineSourceConfigFieldRefs {
    readonly sourceId: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly engine: FieldRef<"SearchEngineSourceConfig", 'SearchEngineKind'>
    readonly query: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly region: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly lang: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly apiEndpoint: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly options: FieldRef<"SearchEngineSourceConfig", 'Json'>
    readonly credentialId: FieldRef<"SearchEngineSourceConfig", 'String'>
    readonly createdAt: FieldRef<"SearchEngineSourceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SearchEngineSourceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SearchEngineSourceConfig findUnique
   */
  export type SearchEngineSourceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SearchEngineSourceConfig to fetch.
     */
    where: SearchEngineSourceConfigWhereUniqueInput
  }

  /**
   * SearchEngineSourceConfig findUniqueOrThrow
   */
  export type SearchEngineSourceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SearchEngineSourceConfig to fetch.
     */
    where: SearchEngineSourceConfigWhereUniqueInput
  }

  /**
   * SearchEngineSourceConfig findFirst
   */
  export type SearchEngineSourceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SearchEngineSourceConfig to fetch.
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchEngineSourceConfigs to fetch.
     */
    orderBy?: SearchEngineSourceConfigOrderByWithRelationInput | SearchEngineSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchEngineSourceConfigs.
     */
    cursor?: SearchEngineSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchEngineSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchEngineSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchEngineSourceConfigs.
     */
    distinct?: SearchEngineSourceConfigScalarFieldEnum | SearchEngineSourceConfigScalarFieldEnum[]
  }

  /**
   * SearchEngineSourceConfig findFirstOrThrow
   */
  export type SearchEngineSourceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SearchEngineSourceConfig to fetch.
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchEngineSourceConfigs to fetch.
     */
    orderBy?: SearchEngineSourceConfigOrderByWithRelationInput | SearchEngineSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchEngineSourceConfigs.
     */
    cursor?: SearchEngineSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchEngineSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchEngineSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchEngineSourceConfigs.
     */
    distinct?: SearchEngineSourceConfigScalarFieldEnum | SearchEngineSourceConfigScalarFieldEnum[]
  }

  /**
   * SearchEngineSourceConfig findMany
   */
  export type SearchEngineSourceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SearchEngineSourceConfigs to fetch.
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchEngineSourceConfigs to fetch.
     */
    orderBy?: SearchEngineSourceConfigOrderByWithRelationInput | SearchEngineSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchEngineSourceConfigs.
     */
    cursor?: SearchEngineSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchEngineSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchEngineSourceConfigs.
     */
    skip?: number
    distinct?: SearchEngineSourceConfigScalarFieldEnum | SearchEngineSourceConfigScalarFieldEnum[]
  }

  /**
   * SearchEngineSourceConfig create
   */
  export type SearchEngineSourceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchEngineSourceConfig.
     */
    data: XOR<SearchEngineSourceConfigCreateInput, SearchEngineSourceConfigUncheckedCreateInput>
  }

  /**
   * SearchEngineSourceConfig createMany
   */
  export type SearchEngineSourceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchEngineSourceConfigs.
     */
    data: SearchEngineSourceConfigCreateManyInput | SearchEngineSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchEngineSourceConfig createManyAndReturn
   */
  export type SearchEngineSourceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SearchEngineSourceConfigs.
     */
    data: SearchEngineSourceConfigCreateManyInput | SearchEngineSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchEngineSourceConfig update
   */
  export type SearchEngineSourceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchEngineSourceConfig.
     */
    data: XOR<SearchEngineSourceConfigUpdateInput, SearchEngineSourceConfigUncheckedUpdateInput>
    /**
     * Choose, which SearchEngineSourceConfig to update.
     */
    where: SearchEngineSourceConfigWhereUniqueInput
  }

  /**
   * SearchEngineSourceConfig updateMany
   */
  export type SearchEngineSourceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchEngineSourceConfigs.
     */
    data: XOR<SearchEngineSourceConfigUpdateManyMutationInput, SearchEngineSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which SearchEngineSourceConfigs to update
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * Limit how many SearchEngineSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * SearchEngineSourceConfig updateManyAndReturn
   */
  export type SearchEngineSourceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to update SearchEngineSourceConfigs.
     */
    data: XOR<SearchEngineSourceConfigUpdateManyMutationInput, SearchEngineSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which SearchEngineSourceConfigs to update
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * Limit how many SearchEngineSourceConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchEngineSourceConfig upsert
   */
  export type SearchEngineSourceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchEngineSourceConfig to update in case it exists.
     */
    where: SearchEngineSourceConfigWhereUniqueInput
    /**
     * In case the SearchEngineSourceConfig found by the `where` argument doesn't exist, create a new SearchEngineSourceConfig with this data.
     */
    create: XOR<SearchEngineSourceConfigCreateInput, SearchEngineSourceConfigUncheckedCreateInput>
    /**
     * In case the SearchEngineSourceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchEngineSourceConfigUpdateInput, SearchEngineSourceConfigUncheckedUpdateInput>
  }

  /**
   * SearchEngineSourceConfig delete
   */
  export type SearchEngineSourceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
    /**
     * Filter which SearchEngineSourceConfig to delete.
     */
    where: SearchEngineSourceConfigWhereUniqueInput
  }

  /**
   * SearchEngineSourceConfig deleteMany
   */
  export type SearchEngineSourceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchEngineSourceConfigs to delete
     */
    where?: SearchEngineSourceConfigWhereInput
    /**
     * Limit how many SearchEngineSourceConfigs to delete.
     */
    limit?: number
  }

  /**
   * SearchEngineSourceConfig.credential
   */
  export type SearchEngineSourceConfig$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * SearchEngineSourceConfig without action
   */
  export type SearchEngineSourceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchEngineSourceConfig
     */
    select?: SearchEngineSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchEngineSourceConfig
     */
    omit?: SearchEngineSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchEngineSourceConfigInclude<ExtArgs> | null
  }


  /**
   * Model SocialMediaSourceConfig
   */

  export type AggregateSocialMediaSourceConfig = {
    _count: SocialMediaSourceConfigCountAggregateOutputType | null
    _min: SocialMediaSourceConfigMinAggregateOutputType | null
    _max: SocialMediaSourceConfigMaxAggregateOutputType | null
  }

  export type SocialMediaSourceConfigMinAggregateOutputType = {
    sourceId: string | null
    platform: $Enums.SocialPlatform | null
    credentialId: string | null
    proxyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaSourceConfigMaxAggregateOutputType = {
    sourceId: string | null
    platform: $Enums.SocialPlatform | null
    credentialId: string | null
    proxyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaSourceConfigCountAggregateOutputType = {
    sourceId: number
    platform: number
    config: number
    credentialId: number
    proxyId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialMediaSourceConfigMinAggregateInputType = {
    sourceId?: true
    platform?: true
    credentialId?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaSourceConfigMaxAggregateInputType = {
    sourceId?: true
    platform?: true
    credentialId?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaSourceConfigCountAggregateInputType = {
    sourceId?: true
    platform?: true
    config?: true
    credentialId?: true
    proxyId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialMediaSourceConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaSourceConfig to aggregate.
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaSourceConfigs to fetch.
     */
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialMediaSourceConfigs
    **/
    _count?: true | SocialMediaSourceConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMediaSourceConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMediaSourceConfigMaxAggregateInputType
  }

  export type GetSocialMediaSourceConfigAggregateType<T extends SocialMediaSourceConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialMediaSourceConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialMediaSourceConfig[P]>
      : GetScalarType<T[P], AggregateSocialMediaSourceConfig[P]>
  }




  export type SocialMediaSourceConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaSourceConfigWhereInput
    orderBy?: SocialMediaSourceConfigOrderByWithAggregationInput | SocialMediaSourceConfigOrderByWithAggregationInput[]
    by: SocialMediaSourceConfigScalarFieldEnum[] | SocialMediaSourceConfigScalarFieldEnum
    having?: SocialMediaSourceConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialMediaSourceConfigCountAggregateInputType | true
    _min?: SocialMediaSourceConfigMinAggregateInputType
    _max?: SocialMediaSourceConfigMaxAggregateInputType
  }

  export type SocialMediaSourceConfigGroupByOutputType = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonValue
    credentialId: string | null
    proxyId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SocialMediaSourceConfigCountAggregateOutputType | null
    _min: SocialMediaSourceConfigMinAggregateOutputType | null
    _max: SocialMediaSourceConfigMaxAggregateOutputType | null
  }

  type GetSocialMediaSourceConfigGroupByPayload<T extends SocialMediaSourceConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialMediaSourceConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialMediaSourceConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialMediaSourceConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SocialMediaSourceConfigGroupByOutputType[P]>
        }
      >
    >


  export type SocialMediaSourceConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    platform?: boolean
    config?: boolean
    credentialId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaSourceConfig"]>

  export type SocialMediaSourceConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    platform?: boolean
    config?: boolean
    credentialId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaSourceConfig"]>

  export type SocialMediaSourceConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sourceId?: boolean
    platform?: boolean
    config?: boolean
    credentialId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaSourceConfig"]>

  export type SocialMediaSourceConfigSelectScalar = {
    sourceId?: boolean
    platform?: boolean
    config?: boolean
    credentialId?: boolean
    proxyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialMediaSourceConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sourceId" | "platform" | "config" | "credentialId" | "proxyId" | "createdAt" | "updatedAt", ExtArgs["result"]["socialMediaSourceConfig"]>
  export type SocialMediaSourceConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }
  export type SocialMediaSourceConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }
  export type SocialMediaSourceConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    source?: boolean | SourceDefaultArgs<ExtArgs>
    credential?: boolean | SocialMediaSourceConfig$credentialArgs<ExtArgs>
    proxy?: boolean | SocialMediaSourceConfig$proxyArgs<ExtArgs>
  }

  export type $SocialMediaSourceConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialMediaSourceConfig"
    objects: {
      source: Prisma.$SourcePayload<ExtArgs>
      credential: Prisma.$CredentialPayload<ExtArgs> | null
      proxy: Prisma.$ProxyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      sourceId: string
      platform: $Enums.SocialPlatform
      config: Prisma.JsonValue
      credentialId: string | null
      proxyId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialMediaSourceConfig"]>
    composites: {}
  }

  type SocialMediaSourceConfigGetPayload<S extends boolean | null | undefined | SocialMediaSourceConfigDefaultArgs> = $Result.GetResult<Prisma.$SocialMediaSourceConfigPayload, S>

  type SocialMediaSourceConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialMediaSourceConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialMediaSourceConfigCountAggregateInputType | true
    }

  export interface SocialMediaSourceConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialMediaSourceConfig'], meta: { name: 'SocialMediaSourceConfig' } }
    /**
     * Find zero or one SocialMediaSourceConfig that matches the filter.
     * @param {SocialMediaSourceConfigFindUniqueArgs} args - Arguments to find a SocialMediaSourceConfig
     * @example
     * // Get one SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialMediaSourceConfigFindUniqueArgs>(args: SelectSubset<T, SocialMediaSourceConfigFindUniqueArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialMediaSourceConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialMediaSourceConfigFindUniqueOrThrowArgs} args - Arguments to find a SocialMediaSourceConfig
     * @example
     * // Get one SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialMediaSourceConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialMediaSourceConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaSourceConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigFindFirstArgs} args - Arguments to find a SocialMediaSourceConfig
     * @example
     * // Get one SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialMediaSourceConfigFindFirstArgs>(args?: SelectSubset<T, SocialMediaSourceConfigFindFirstArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaSourceConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigFindFirstOrThrowArgs} args - Arguments to find a SocialMediaSourceConfig
     * @example
     * // Get one SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialMediaSourceConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialMediaSourceConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialMediaSourceConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialMediaSourceConfigs
     * const socialMediaSourceConfigs = await prisma.socialMediaSourceConfig.findMany()
     * 
     * // Get first 10 SocialMediaSourceConfigs
     * const socialMediaSourceConfigs = await prisma.socialMediaSourceConfig.findMany({ take: 10 })
     * 
     * // Only select the `sourceId`
     * const socialMediaSourceConfigWithSourceIdOnly = await prisma.socialMediaSourceConfig.findMany({ select: { sourceId: true } })
     * 
     */
    findMany<T extends SocialMediaSourceConfigFindManyArgs>(args?: SelectSubset<T, SocialMediaSourceConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialMediaSourceConfig.
     * @param {SocialMediaSourceConfigCreateArgs} args - Arguments to create a SocialMediaSourceConfig.
     * @example
     * // Create one SocialMediaSourceConfig
     * const SocialMediaSourceConfig = await prisma.socialMediaSourceConfig.create({
     *   data: {
     *     // ... data to create a SocialMediaSourceConfig
     *   }
     * })
     * 
     */
    create<T extends SocialMediaSourceConfigCreateArgs>(args: SelectSubset<T, SocialMediaSourceConfigCreateArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialMediaSourceConfigs.
     * @param {SocialMediaSourceConfigCreateManyArgs} args - Arguments to create many SocialMediaSourceConfigs.
     * @example
     * // Create many SocialMediaSourceConfigs
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialMediaSourceConfigCreateManyArgs>(args?: SelectSubset<T, SocialMediaSourceConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialMediaSourceConfigs and returns the data saved in the database.
     * @param {SocialMediaSourceConfigCreateManyAndReturnArgs} args - Arguments to create many SocialMediaSourceConfigs.
     * @example
     * // Create many SocialMediaSourceConfigs
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialMediaSourceConfigs and only return the `sourceId`
     * const socialMediaSourceConfigWithSourceIdOnly = await prisma.socialMediaSourceConfig.createManyAndReturn({
     *   select: { sourceId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialMediaSourceConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialMediaSourceConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialMediaSourceConfig.
     * @param {SocialMediaSourceConfigDeleteArgs} args - Arguments to delete one SocialMediaSourceConfig.
     * @example
     * // Delete one SocialMediaSourceConfig
     * const SocialMediaSourceConfig = await prisma.socialMediaSourceConfig.delete({
     *   where: {
     *     // ... filter to delete one SocialMediaSourceConfig
     *   }
     * })
     * 
     */
    delete<T extends SocialMediaSourceConfigDeleteArgs>(args: SelectSubset<T, SocialMediaSourceConfigDeleteArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialMediaSourceConfig.
     * @param {SocialMediaSourceConfigUpdateArgs} args - Arguments to update one SocialMediaSourceConfig.
     * @example
     * // Update one SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialMediaSourceConfigUpdateArgs>(args: SelectSubset<T, SocialMediaSourceConfigUpdateArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialMediaSourceConfigs.
     * @param {SocialMediaSourceConfigDeleteManyArgs} args - Arguments to filter SocialMediaSourceConfigs to delete.
     * @example
     * // Delete a few SocialMediaSourceConfigs
     * const { count } = await prisma.socialMediaSourceConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialMediaSourceConfigDeleteManyArgs>(args?: SelectSubset<T, SocialMediaSourceConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialMediaSourceConfigs
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialMediaSourceConfigUpdateManyArgs>(args: SelectSubset<T, SocialMediaSourceConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaSourceConfigs and returns the data updated in the database.
     * @param {SocialMediaSourceConfigUpdateManyAndReturnArgs} args - Arguments to update many SocialMediaSourceConfigs.
     * @example
     * // Update many SocialMediaSourceConfigs
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialMediaSourceConfigs and only return the `sourceId`
     * const socialMediaSourceConfigWithSourceIdOnly = await prisma.socialMediaSourceConfig.updateManyAndReturn({
     *   select: { sourceId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialMediaSourceConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialMediaSourceConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialMediaSourceConfig.
     * @param {SocialMediaSourceConfigUpsertArgs} args - Arguments to update or create a SocialMediaSourceConfig.
     * @example
     * // Update or create a SocialMediaSourceConfig
     * const socialMediaSourceConfig = await prisma.socialMediaSourceConfig.upsert({
     *   create: {
     *     // ... data to create a SocialMediaSourceConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialMediaSourceConfig we want to update
     *   }
     * })
     */
    upsert<T extends SocialMediaSourceConfigUpsertArgs>(args: SelectSubset<T, SocialMediaSourceConfigUpsertArgs<ExtArgs>>): Prisma__SocialMediaSourceConfigClient<$Result.GetResult<Prisma.$SocialMediaSourceConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialMediaSourceConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigCountArgs} args - Arguments to filter SocialMediaSourceConfigs to count.
     * @example
     * // Count the number of SocialMediaSourceConfigs
     * const count = await prisma.socialMediaSourceConfig.count({
     *   where: {
     *     // ... the filter for the SocialMediaSourceConfigs we want to count
     *   }
     * })
    **/
    count<T extends SocialMediaSourceConfigCountArgs>(
      args?: Subset<T, SocialMediaSourceConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialMediaSourceConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialMediaSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialMediaSourceConfigAggregateArgs>(args: Subset<T, SocialMediaSourceConfigAggregateArgs>): Prisma.PrismaPromise<GetSocialMediaSourceConfigAggregateType<T>>

    /**
     * Group by SocialMediaSourceConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaSourceConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialMediaSourceConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialMediaSourceConfigGroupByArgs['orderBy'] }
        : { orderBy?: SocialMediaSourceConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialMediaSourceConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialMediaSourceConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialMediaSourceConfig model
   */
  readonly fields: SocialMediaSourceConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialMediaSourceConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialMediaSourceConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    source<T extends SourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SourceDefaultArgs<ExtArgs>>): Prisma__SourceClient<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    credential<T extends SocialMediaSourceConfig$credentialArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaSourceConfig$credentialArgs<ExtArgs>>): Prisma__CredentialClient<$Result.GetResult<Prisma.$CredentialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    proxy<T extends SocialMediaSourceConfig$proxyArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaSourceConfig$proxyArgs<ExtArgs>>): Prisma__ProxyClient<$Result.GetResult<Prisma.$ProxyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialMediaSourceConfig model
   */
  interface SocialMediaSourceConfigFieldRefs {
    readonly sourceId: FieldRef<"SocialMediaSourceConfig", 'String'>
    readonly platform: FieldRef<"SocialMediaSourceConfig", 'SocialPlatform'>
    readonly config: FieldRef<"SocialMediaSourceConfig", 'Json'>
    readonly credentialId: FieldRef<"SocialMediaSourceConfig", 'String'>
    readonly proxyId: FieldRef<"SocialMediaSourceConfig", 'String'>
    readonly createdAt: FieldRef<"SocialMediaSourceConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialMediaSourceConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialMediaSourceConfig findUnique
   */
  export type SocialMediaSourceConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaSourceConfig to fetch.
     */
    where: SocialMediaSourceConfigWhereUniqueInput
  }

  /**
   * SocialMediaSourceConfig findUniqueOrThrow
   */
  export type SocialMediaSourceConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaSourceConfig to fetch.
     */
    where: SocialMediaSourceConfigWhereUniqueInput
  }

  /**
   * SocialMediaSourceConfig findFirst
   */
  export type SocialMediaSourceConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaSourceConfig to fetch.
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaSourceConfigs to fetch.
     */
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaSourceConfigs.
     */
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaSourceConfigs.
     */
    distinct?: SocialMediaSourceConfigScalarFieldEnum | SocialMediaSourceConfigScalarFieldEnum[]
  }

  /**
   * SocialMediaSourceConfig findFirstOrThrow
   */
  export type SocialMediaSourceConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaSourceConfig to fetch.
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaSourceConfigs to fetch.
     */
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaSourceConfigs.
     */
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaSourceConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaSourceConfigs.
     */
    distinct?: SocialMediaSourceConfigScalarFieldEnum | SocialMediaSourceConfigScalarFieldEnum[]
  }

  /**
   * SocialMediaSourceConfig findMany
   */
  export type SocialMediaSourceConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaSourceConfigs to fetch.
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaSourceConfigs to fetch.
     */
    orderBy?: SocialMediaSourceConfigOrderByWithRelationInput | SocialMediaSourceConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialMediaSourceConfigs.
     */
    cursor?: SocialMediaSourceConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaSourceConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaSourceConfigs.
     */
    skip?: number
    distinct?: SocialMediaSourceConfigScalarFieldEnum | SocialMediaSourceConfigScalarFieldEnum[]
  }

  /**
   * SocialMediaSourceConfig create
   */
  export type SocialMediaSourceConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialMediaSourceConfig.
     */
    data: XOR<SocialMediaSourceConfigCreateInput, SocialMediaSourceConfigUncheckedCreateInput>
  }

  /**
   * SocialMediaSourceConfig createMany
   */
  export type SocialMediaSourceConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialMediaSourceConfigs.
     */
    data: SocialMediaSourceConfigCreateManyInput | SocialMediaSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaSourceConfig createManyAndReturn
   */
  export type SocialMediaSourceConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SocialMediaSourceConfigs.
     */
    data: SocialMediaSourceConfigCreateManyInput | SocialMediaSourceConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMediaSourceConfig update
   */
  export type SocialMediaSourceConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialMediaSourceConfig.
     */
    data: XOR<SocialMediaSourceConfigUpdateInput, SocialMediaSourceConfigUncheckedUpdateInput>
    /**
     * Choose, which SocialMediaSourceConfig to update.
     */
    where: SocialMediaSourceConfigWhereUniqueInput
  }

  /**
   * SocialMediaSourceConfig updateMany
   */
  export type SocialMediaSourceConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialMediaSourceConfigs.
     */
    data: XOR<SocialMediaSourceConfigUpdateManyMutationInput, SocialMediaSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaSourceConfigs to update
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * Limit how many SocialMediaSourceConfigs to update.
     */
    limit?: number
  }

  /**
   * SocialMediaSourceConfig updateManyAndReturn
   */
  export type SocialMediaSourceConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * The data used to update SocialMediaSourceConfigs.
     */
    data: XOR<SocialMediaSourceConfigUpdateManyMutationInput, SocialMediaSourceConfigUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaSourceConfigs to update
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * Limit how many SocialMediaSourceConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMediaSourceConfig upsert
   */
  export type SocialMediaSourceConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialMediaSourceConfig to update in case it exists.
     */
    where: SocialMediaSourceConfigWhereUniqueInput
    /**
     * In case the SocialMediaSourceConfig found by the `where` argument doesn't exist, create a new SocialMediaSourceConfig with this data.
     */
    create: XOR<SocialMediaSourceConfigCreateInput, SocialMediaSourceConfigUncheckedCreateInput>
    /**
     * In case the SocialMediaSourceConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialMediaSourceConfigUpdateInput, SocialMediaSourceConfigUncheckedUpdateInput>
  }

  /**
   * SocialMediaSourceConfig delete
   */
  export type SocialMediaSourceConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
    /**
     * Filter which SocialMediaSourceConfig to delete.
     */
    where: SocialMediaSourceConfigWhereUniqueInput
  }

  /**
   * SocialMediaSourceConfig deleteMany
   */
  export type SocialMediaSourceConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaSourceConfigs to delete
     */
    where?: SocialMediaSourceConfigWhereInput
    /**
     * Limit how many SocialMediaSourceConfigs to delete.
     */
    limit?: number
  }

  /**
   * SocialMediaSourceConfig.credential
   */
  export type SocialMediaSourceConfig$credentialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Credential
     */
    select?: CredentialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Credential
     */
    omit?: CredentialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CredentialInclude<ExtArgs> | null
    where?: CredentialWhereInput
  }

  /**
   * SocialMediaSourceConfig.proxy
   */
  export type SocialMediaSourceConfig$proxyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proxy
     */
    select?: ProxySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Proxy
     */
    omit?: ProxyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyInclude<ExtArgs> | null
    where?: ProxyWhereInput
  }

  /**
   * SocialMediaSourceConfig without action
   */
  export type SocialMediaSourceConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaSourceConfig
     */
    select?: SocialMediaSourceConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaSourceConfig
     */
    omit?: SocialMediaSourceConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaSourceConfigInclude<ExtArgs> | null
  }


  /**
   * Model Query
   */

  export type AggregateQuery = {
    _count: QueryCountAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  export type QueryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    frequency: $Enums.QueryFrequency | null
    cronSchedule: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    enabled: boolean | null
    frequency: $Enums.QueryFrequency | null
    cronSchedule: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    enabled: number
    frequency: number
    cronSchedule: number
    rules: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    enabled?: true
    frequency?: true
    cronSchedule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    enabled?: true
    frequency?: true
    cronSchedule?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    enabled?: true
    frequency?: true
    cronSchedule?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Query to aggregate.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Queries
    **/
    _count?: true | QueryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryMaxAggregateInputType
  }

  export type GetQueryAggregateType<T extends QueryAggregateArgs> = {
        [P in keyof T & keyof AggregateQuery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuery[P]>
      : GetScalarType<T[P], AggregateQuery[P]>
  }




  export type QueryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryWhereInput
    orderBy?: QueryOrderByWithAggregationInput | QueryOrderByWithAggregationInput[]
    by: QueryScalarFieldEnum[] | QueryScalarFieldEnum
    having?: QueryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryCountAggregateInputType | true
    _min?: QueryMinAggregateInputType
    _max?: QueryMaxAggregateInputType
  }

  export type QueryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    enabled: boolean
    frequency: $Enums.QueryFrequency
    cronSchedule: string | null
    rules: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QueryCountAggregateOutputType | null
    _min: QueryMinAggregateOutputType | null
    _max: QueryMaxAggregateOutputType | null
  }

  type GetQueryGroupByPayload<T extends QueryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryGroupByOutputType[P]>
            : GetScalarType<T[P], QueryGroupByOutputType[P]>
        }
      >
    >


  export type QuerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    frequency?: boolean
    cronSchedule?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keywords?: boolean | Query$keywordsArgs<ExtArgs>
    sources?: boolean | Query$sourcesArgs<ExtArgs>
    queryRuns?: boolean | Query$queryRunsArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["query"]>

  export type QuerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    frequency?: boolean
    cronSchedule?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["query"]>

  export type QuerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    frequency?: boolean
    cronSchedule?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["query"]>

  export type QuerySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    enabled?: boolean
    frequency?: boolean
    cronSchedule?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "enabled" | "frequency" | "cronSchedule" | "rules" | "createdAt" | "updatedAt", ExtArgs["result"]["query"]>
  export type QueryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | Query$keywordsArgs<ExtArgs>
    sources?: boolean | Query$sourcesArgs<ExtArgs>
    queryRuns?: boolean | Query$queryRunsArgs<ExtArgs>
    _count?: boolean | QueryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QueryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QueryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Query"
    objects: {
      keywords: Prisma.$KeywordPayload<ExtArgs>[]
      sources: Prisma.$SourcePayload<ExtArgs>[]
      queryRuns: Prisma.$QueryRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      enabled: boolean
      frequency: $Enums.QueryFrequency
      cronSchedule: string | null
      rules: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["query"]>
    composites: {}
  }

  type QueryGetPayload<S extends boolean | null | undefined | QueryDefaultArgs> = $Result.GetResult<Prisma.$QueryPayload, S>

  type QueryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryCountAggregateInputType | true
    }

  export interface QueryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Query'], meta: { name: 'Query' } }
    /**
     * Find zero or one Query that matches the filter.
     * @param {QueryFindUniqueArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryFindUniqueArgs>(args: SelectSubset<T, QueryFindUniqueArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Query that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryFindUniqueOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryFindFirstArgs>(args?: SelectSubset<T, QueryFindFirstArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Query that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindFirstOrThrowArgs} args - Arguments to find a Query
     * @example
     * // Get one Query
     * const query = await prisma.query.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Queries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queries
     * const queries = await prisma.query.findMany()
     * 
     * // Get first 10 Queries
     * const queries = await prisma.query.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryWithIdOnly = await prisma.query.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryFindManyArgs>(args?: SelectSubset<T, QueryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Query.
     * @param {QueryCreateArgs} args - Arguments to create a Query.
     * @example
     * // Create one Query
     * const Query = await prisma.query.create({
     *   data: {
     *     // ... data to create a Query
     *   }
     * })
     * 
     */
    create<T extends QueryCreateArgs>(args: SelectSubset<T, QueryCreateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Queries.
     * @param {QueryCreateManyArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryCreateManyArgs>(args?: SelectSubset<T, QueryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Queries and returns the data saved in the database.
     * @param {QueryCreateManyAndReturnArgs} args - Arguments to create many Queries.
     * @example
     * // Create many Queries
     * const query = await prisma.query.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Query.
     * @param {QueryDeleteArgs} args - Arguments to delete one Query.
     * @example
     * // Delete one Query
     * const Query = await prisma.query.delete({
     *   where: {
     *     // ... filter to delete one Query
     *   }
     * })
     * 
     */
    delete<T extends QueryDeleteArgs>(args: SelectSubset<T, QueryDeleteArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Query.
     * @param {QueryUpdateArgs} args - Arguments to update one Query.
     * @example
     * // Update one Query
     * const query = await prisma.query.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryUpdateArgs>(args: SelectSubset<T, QueryUpdateArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Queries.
     * @param {QueryDeleteManyArgs} args - Arguments to filter Queries to delete.
     * @example
     * // Delete a few Queries
     * const { count } = await prisma.query.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryDeleteManyArgs>(args?: SelectSubset<T, QueryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryUpdateManyArgs>(args: SelectSubset<T, QueryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Queries and returns the data updated in the database.
     * @param {QueryUpdateManyAndReturnArgs} args - Arguments to update many Queries.
     * @example
     * // Update many Queries
     * const query = await prisma.query.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Queries and only return the `id`
     * const queryWithIdOnly = await prisma.query.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Query.
     * @param {QueryUpsertArgs} args - Arguments to update or create a Query.
     * @example
     * // Update or create a Query
     * const query = await prisma.query.upsert({
     *   create: {
     *     // ... data to create a Query
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Query we want to update
     *   }
     * })
     */
    upsert<T extends QueryUpsertArgs>(args: SelectSubset<T, QueryUpsertArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Queries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryCountArgs} args - Arguments to filter Queries to count.
     * @example
     * // Count the number of Queries
     * const count = await prisma.query.count({
     *   where: {
     *     // ... the filter for the Queries we want to count
     *   }
     * })
    **/
    count<T extends QueryCountArgs>(
      args?: Subset<T, QueryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryAggregateArgs>(args: Subset<T, QueryAggregateArgs>): Prisma.PrismaPromise<GetQueryAggregateType<T>>

    /**
     * Group by Query.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryGroupByArgs['orderBy'] }
        : { orderBy?: QueryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Query model
   */
  readonly fields: QueryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Query.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords<T extends Query$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Query$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends Query$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Query$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queryRuns<T extends Query$queryRunsArgs<ExtArgs> = {}>(args?: Subset<T, Query$queryRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Query model
   */
  interface QueryFieldRefs {
    readonly id: FieldRef<"Query", 'String'>
    readonly name: FieldRef<"Query", 'String'>
    readonly description: FieldRef<"Query", 'String'>
    readonly enabled: FieldRef<"Query", 'Boolean'>
    readonly frequency: FieldRef<"Query", 'QueryFrequency'>
    readonly cronSchedule: FieldRef<"Query", 'String'>
    readonly rules: FieldRef<"Query", 'Json'>
    readonly createdAt: FieldRef<"Query", 'DateTime'>
    readonly updatedAt: FieldRef<"Query", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Query findUnique
   */
  export type QueryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findUniqueOrThrow
   */
  export type QueryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query findFirst
   */
  export type QueryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findFirstOrThrow
   */
  export type QueryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Query to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Queries.
     */
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query findMany
   */
  export type QueryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter, which Queries to fetch.
     */
    where?: QueryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Queries to fetch.
     */
    orderBy?: QueryOrderByWithRelationInput | QueryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Queries.
     */
    cursor?: QueryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Queries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Queries.
     */
    skip?: number
    distinct?: QueryScalarFieldEnum | QueryScalarFieldEnum[]
  }

  /**
   * Query create
   */
  export type QueryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to create a Query.
     */
    data: XOR<QueryCreateInput, QueryUncheckedCreateInput>
  }

  /**
   * Query createMany
   */
  export type QueryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Query createManyAndReturn
   */
  export type QueryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to create many Queries.
     */
    data: QueryCreateManyInput | QueryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Query update
   */
  export type QueryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The data needed to update a Query.
     */
    data: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
    /**
     * Choose, which Query to update.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query updateMany
   */
  export type QueryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
  }

  /**
   * Query updateManyAndReturn
   */
  export type QueryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * The data used to update Queries.
     */
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyInput>
    /**
     * Filter which Queries to update
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to update.
     */
    limit?: number
  }

  /**
   * Query upsert
   */
  export type QueryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * The filter to search for the Query to update in case it exists.
     */
    where: QueryWhereUniqueInput
    /**
     * In case the Query found by the `where` argument doesn't exist, create a new Query with this data.
     */
    create: XOR<QueryCreateInput, QueryUncheckedCreateInput>
    /**
     * In case the Query was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryUpdateInput, QueryUncheckedUpdateInput>
  }

  /**
   * Query delete
   */
  export type QueryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
    /**
     * Filter which Query to delete.
     */
    where: QueryWhereUniqueInput
  }

  /**
   * Query deleteMany
   */
  export type QueryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Queries to delete
     */
    where?: QueryWhereInput
    /**
     * Limit how many Queries to delete.
     */
    limit?: number
  }

  /**
   * Query.keywords
   */
  export type Query$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Keyword
     */
    select?: KeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Keyword
     */
    omit?: KeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KeywordInclude<ExtArgs> | null
    where?: KeywordWhereInput
    orderBy?: KeywordOrderByWithRelationInput | KeywordOrderByWithRelationInput[]
    cursor?: KeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KeywordScalarFieldEnum | KeywordScalarFieldEnum[]
  }

  /**
   * Query.sources
   */
  export type Query$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Source
     */
    select?: SourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Source
     */
    omit?: SourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceInclude<ExtArgs> | null
    where?: SourceWhereInput
    orderBy?: SourceOrderByWithRelationInput | SourceOrderByWithRelationInput[]
    cursor?: SourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceScalarFieldEnum | SourceScalarFieldEnum[]
  }

  /**
   * Query.queryRuns
   */
  export type Query$queryRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    where?: QueryRunWhereInput
    orderBy?: QueryRunOrderByWithRelationInput | QueryRunOrderByWithRelationInput[]
    cursor?: QueryRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueryRunScalarFieldEnum | QueryRunScalarFieldEnum[]
  }

  /**
   * Query without action
   */
  export type QueryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Query
     */
    select?: QuerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Query
     */
    omit?: QueryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryInclude<ExtArgs> | null
  }


  /**
   * Model QueryRun
   */

  export type AggregateQueryRun = {
    _count: QueryRunCountAggregateOutputType | null
    _avg: QueryRunAvgAggregateOutputType | null
    _sum: QueryRunSumAggregateOutputType | null
    _min: QueryRunMinAggregateOutputType | null
    _max: QueryRunMaxAggregateOutputType | null
  }

  export type QueryRunAvgAggregateOutputType = {
    progress: number | null
  }

  export type QueryRunSumAggregateOutputType = {
    progress: number | null
  }

  export type QueryRunMinAggregateOutputType = {
    id: string | null
    queryId: string | null
    status: $Enums.TaskStatus | null
    progress: number | null
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryRunMaxAggregateOutputType = {
    id: string | null
    queryId: string | null
    status: $Enums.TaskStatus | null
    progress: number | null
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueryRunCountAggregateOutputType = {
    id: number
    queryId: number
    status: number
    progress: number
    error: number
    startedAt: number
    finishedAt: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueryRunAvgAggregateInputType = {
    progress?: true
  }

  export type QueryRunSumAggregateInputType = {
    progress?: true
  }

  export type QueryRunMinAggregateInputType = {
    id?: true
    queryId?: true
    status?: true
    progress?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryRunMaxAggregateInputType = {
    id?: true
    queryId?: true
    status?: true
    progress?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueryRunCountAggregateInputType = {
    id?: true
    queryId?: true
    status?: true
    progress?: true
    error?: true
    startedAt?: true
    finishedAt?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueryRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryRun to aggregate.
     */
    where?: QueryRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryRuns to fetch.
     */
    orderBy?: QueryRunOrderByWithRelationInput | QueryRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueryRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueryRuns
    **/
    _count?: true | QueryRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueryRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueryRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueryRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueryRunMaxAggregateInputType
  }

  export type GetQueryRunAggregateType<T extends QueryRunAggregateArgs> = {
        [P in keyof T & keyof AggregateQueryRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueryRun[P]>
      : GetScalarType<T[P], AggregateQueryRun[P]>
  }




  export type QueryRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueryRunWhereInput
    orderBy?: QueryRunOrderByWithAggregationInput | QueryRunOrderByWithAggregationInput[]
    by: QueryRunScalarFieldEnum[] | QueryRunScalarFieldEnum
    having?: QueryRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueryRunCountAggregateInputType | true
    _avg?: QueryRunAvgAggregateInputType
    _sum?: QueryRunSumAggregateInputType
    _min?: QueryRunMinAggregateInputType
    _max?: QueryRunMaxAggregateInputType
  }

  export type QueryRunGroupByOutputType = {
    id: string
    queryId: string
    status: $Enums.TaskStatus
    progress: number
    error: string | null
    startedAt: Date | null
    finishedAt: Date | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QueryRunCountAggregateOutputType | null
    _avg: QueryRunAvgAggregateOutputType | null
    _sum: QueryRunSumAggregateOutputType | null
    _min: QueryRunMinAggregateOutputType | null
    _max: QueryRunMaxAggregateOutputType | null
  }

  type GetQueryRunGroupByPayload<T extends QueryRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueryRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueryRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueryRunGroupByOutputType[P]>
            : GetScalarType<T[P], QueryRunGroupByOutputType[P]>
        }
      >
    >


  export type QueryRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    status?: boolean
    progress?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
    events?: boolean | QueryRun$eventsArgs<ExtArgs>
    _count?: boolean | QueryRunCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryRun"]>

  export type QueryRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    status?: boolean
    progress?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryRun"]>

  export type QueryRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queryId?: boolean
    status?: boolean
    progress?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queryRun"]>

  export type QueryRunSelectScalar = {
    id?: boolean
    queryId?: boolean
    status?: boolean
    progress?: boolean
    error?: boolean
    startedAt?: boolean
    finishedAt?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueryRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queryId" | "status" | "progress" | "error" | "startedAt" | "finishedAt" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["queryRun"]>
  export type QueryRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
    events?: boolean | QueryRun$eventsArgs<ExtArgs>
    _count?: boolean | QueryRunCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueryRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }
  export type QueryRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    query?: boolean | QueryDefaultArgs<ExtArgs>
  }

  export type $QueryRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueryRun"
    objects: {
      query: Prisma.$QueryPayload<ExtArgs>
      events: Prisma.$TaskEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      queryId: string
      status: $Enums.TaskStatus
      progress: number
      error: string | null
      startedAt: Date | null
      finishedAt: Date | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["queryRun"]>
    composites: {}
  }

  type QueryRunGetPayload<S extends boolean | null | undefined | QueryRunDefaultArgs> = $Result.GetResult<Prisma.$QueryRunPayload, S>

  type QueryRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueryRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueryRunCountAggregateInputType | true
    }

  export interface QueryRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueryRun'], meta: { name: 'QueryRun' } }
    /**
     * Find zero or one QueryRun that matches the filter.
     * @param {QueryRunFindUniqueArgs} args - Arguments to find a QueryRun
     * @example
     * // Get one QueryRun
     * const queryRun = await prisma.queryRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueryRunFindUniqueArgs>(args: SelectSubset<T, QueryRunFindUniqueArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueryRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueryRunFindUniqueOrThrowArgs} args - Arguments to find a QueryRun
     * @example
     * // Get one QueryRun
     * const queryRun = await prisma.queryRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueryRunFindUniqueOrThrowArgs>(args: SelectSubset<T, QueryRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueryRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunFindFirstArgs} args - Arguments to find a QueryRun
     * @example
     * // Get one QueryRun
     * const queryRun = await prisma.queryRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueryRunFindFirstArgs>(args?: SelectSubset<T, QueryRunFindFirstArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueryRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunFindFirstOrThrowArgs} args - Arguments to find a QueryRun
     * @example
     * // Get one QueryRun
     * const queryRun = await prisma.queryRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueryRunFindFirstOrThrowArgs>(args?: SelectSubset<T, QueryRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueryRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueryRuns
     * const queryRuns = await prisma.queryRun.findMany()
     * 
     * // Get first 10 QueryRuns
     * const queryRuns = await prisma.queryRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queryRunWithIdOnly = await prisma.queryRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueryRunFindManyArgs>(args?: SelectSubset<T, QueryRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueryRun.
     * @param {QueryRunCreateArgs} args - Arguments to create a QueryRun.
     * @example
     * // Create one QueryRun
     * const QueryRun = await prisma.queryRun.create({
     *   data: {
     *     // ... data to create a QueryRun
     *   }
     * })
     * 
     */
    create<T extends QueryRunCreateArgs>(args: SelectSubset<T, QueryRunCreateArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueryRuns.
     * @param {QueryRunCreateManyArgs} args - Arguments to create many QueryRuns.
     * @example
     * // Create many QueryRuns
     * const queryRun = await prisma.queryRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueryRunCreateManyArgs>(args?: SelectSubset<T, QueryRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueryRuns and returns the data saved in the database.
     * @param {QueryRunCreateManyAndReturnArgs} args - Arguments to create many QueryRuns.
     * @example
     * // Create many QueryRuns
     * const queryRun = await prisma.queryRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueryRuns and only return the `id`
     * const queryRunWithIdOnly = await prisma.queryRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueryRunCreateManyAndReturnArgs>(args?: SelectSubset<T, QueryRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueryRun.
     * @param {QueryRunDeleteArgs} args - Arguments to delete one QueryRun.
     * @example
     * // Delete one QueryRun
     * const QueryRun = await prisma.queryRun.delete({
     *   where: {
     *     // ... filter to delete one QueryRun
     *   }
     * })
     * 
     */
    delete<T extends QueryRunDeleteArgs>(args: SelectSubset<T, QueryRunDeleteArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueryRun.
     * @param {QueryRunUpdateArgs} args - Arguments to update one QueryRun.
     * @example
     * // Update one QueryRun
     * const queryRun = await prisma.queryRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueryRunUpdateArgs>(args: SelectSubset<T, QueryRunUpdateArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueryRuns.
     * @param {QueryRunDeleteManyArgs} args - Arguments to filter QueryRuns to delete.
     * @example
     * // Delete a few QueryRuns
     * const { count } = await prisma.queryRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueryRunDeleteManyArgs>(args?: SelectSubset<T, QueryRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueryRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueryRuns
     * const queryRun = await prisma.queryRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueryRunUpdateManyArgs>(args: SelectSubset<T, QueryRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueryRuns and returns the data updated in the database.
     * @param {QueryRunUpdateManyAndReturnArgs} args - Arguments to update many QueryRuns.
     * @example
     * // Update many QueryRuns
     * const queryRun = await prisma.queryRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueryRuns and only return the `id`
     * const queryRunWithIdOnly = await prisma.queryRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueryRunUpdateManyAndReturnArgs>(args: SelectSubset<T, QueryRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueryRun.
     * @param {QueryRunUpsertArgs} args - Arguments to update or create a QueryRun.
     * @example
     * // Update or create a QueryRun
     * const queryRun = await prisma.queryRun.upsert({
     *   create: {
     *     // ... data to create a QueryRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueryRun we want to update
     *   }
     * })
     */
    upsert<T extends QueryRunUpsertArgs>(args: SelectSubset<T, QueryRunUpsertArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueryRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunCountArgs} args - Arguments to filter QueryRuns to count.
     * @example
     * // Count the number of QueryRuns
     * const count = await prisma.queryRun.count({
     *   where: {
     *     // ... the filter for the QueryRuns we want to count
     *   }
     * })
    **/
    count<T extends QueryRunCountArgs>(
      args?: Subset<T, QueryRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueryRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueryRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueryRunAggregateArgs>(args: Subset<T, QueryRunAggregateArgs>): Prisma.PrismaPromise<GetQueryRunAggregateType<T>>

    /**
     * Group by QueryRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueryRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueryRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueryRunGroupByArgs['orderBy'] }
        : { orderBy?: QueryRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueryRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueryRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueryRun model
   */
  readonly fields: QueryRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueryRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueryRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    query<T extends QueryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryDefaultArgs<ExtArgs>>): Prisma__QueryClient<$Result.GetResult<Prisma.$QueryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    events<T extends QueryRun$eventsArgs<ExtArgs> = {}>(args?: Subset<T, QueryRun$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueryRun model
   */
  interface QueryRunFieldRefs {
    readonly id: FieldRef<"QueryRun", 'String'>
    readonly queryId: FieldRef<"QueryRun", 'String'>
    readonly status: FieldRef<"QueryRun", 'TaskStatus'>
    readonly progress: FieldRef<"QueryRun", 'Int'>
    readonly error: FieldRef<"QueryRun", 'String'>
    readonly startedAt: FieldRef<"QueryRun", 'DateTime'>
    readonly finishedAt: FieldRef<"QueryRun", 'DateTime'>
    readonly meta: FieldRef<"QueryRun", 'Json'>
    readonly createdAt: FieldRef<"QueryRun", 'DateTime'>
    readonly updatedAt: FieldRef<"QueryRun", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueryRun findUnique
   */
  export type QueryRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter, which QueryRun to fetch.
     */
    where: QueryRunWhereUniqueInput
  }

  /**
   * QueryRun findUniqueOrThrow
   */
  export type QueryRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter, which QueryRun to fetch.
     */
    where: QueryRunWhereUniqueInput
  }

  /**
   * QueryRun findFirst
   */
  export type QueryRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter, which QueryRun to fetch.
     */
    where?: QueryRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryRuns to fetch.
     */
    orderBy?: QueryRunOrderByWithRelationInput | QueryRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryRuns.
     */
    cursor?: QueryRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryRuns.
     */
    distinct?: QueryRunScalarFieldEnum | QueryRunScalarFieldEnum[]
  }

  /**
   * QueryRun findFirstOrThrow
   */
  export type QueryRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter, which QueryRun to fetch.
     */
    where?: QueryRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryRuns to fetch.
     */
    orderBy?: QueryRunOrderByWithRelationInput | QueryRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueryRuns.
     */
    cursor?: QueryRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueryRuns.
     */
    distinct?: QueryRunScalarFieldEnum | QueryRunScalarFieldEnum[]
  }

  /**
   * QueryRun findMany
   */
  export type QueryRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter, which QueryRuns to fetch.
     */
    where?: QueryRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueryRuns to fetch.
     */
    orderBy?: QueryRunOrderByWithRelationInput | QueryRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueryRuns.
     */
    cursor?: QueryRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueryRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueryRuns.
     */
    skip?: number
    distinct?: QueryRunScalarFieldEnum | QueryRunScalarFieldEnum[]
  }

  /**
   * QueryRun create
   */
  export type QueryRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * The data needed to create a QueryRun.
     */
    data: XOR<QueryRunCreateInput, QueryRunUncheckedCreateInput>
  }

  /**
   * QueryRun createMany
   */
  export type QueryRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueryRuns.
     */
    data: QueryRunCreateManyInput | QueryRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueryRun createManyAndReturn
   */
  export type QueryRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * The data used to create many QueryRuns.
     */
    data: QueryRunCreateManyInput | QueryRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueryRun update
   */
  export type QueryRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * The data needed to update a QueryRun.
     */
    data: XOR<QueryRunUpdateInput, QueryRunUncheckedUpdateInput>
    /**
     * Choose, which QueryRun to update.
     */
    where: QueryRunWhereUniqueInput
  }

  /**
   * QueryRun updateMany
   */
  export type QueryRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueryRuns.
     */
    data: XOR<QueryRunUpdateManyMutationInput, QueryRunUncheckedUpdateManyInput>
    /**
     * Filter which QueryRuns to update
     */
    where?: QueryRunWhereInput
    /**
     * Limit how many QueryRuns to update.
     */
    limit?: number
  }

  /**
   * QueryRun updateManyAndReturn
   */
  export type QueryRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * The data used to update QueryRuns.
     */
    data: XOR<QueryRunUpdateManyMutationInput, QueryRunUncheckedUpdateManyInput>
    /**
     * Filter which QueryRuns to update
     */
    where?: QueryRunWhereInput
    /**
     * Limit how many QueryRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueryRun upsert
   */
  export type QueryRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * The filter to search for the QueryRun to update in case it exists.
     */
    where: QueryRunWhereUniqueInput
    /**
     * In case the QueryRun found by the `where` argument doesn't exist, create a new QueryRun with this data.
     */
    create: XOR<QueryRunCreateInput, QueryRunUncheckedCreateInput>
    /**
     * In case the QueryRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueryRunUpdateInput, QueryRunUncheckedUpdateInput>
  }

  /**
   * QueryRun delete
   */
  export type QueryRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
    /**
     * Filter which QueryRun to delete.
     */
    where: QueryRunWhereUniqueInput
  }

  /**
   * QueryRun deleteMany
   */
  export type QueryRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueryRuns to delete
     */
    where?: QueryRunWhereInput
    /**
     * Limit how many QueryRuns to delete.
     */
    limit?: number
  }

  /**
   * QueryRun.events
   */
  export type QueryRun$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    where?: TaskEventWhereInput
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    cursor?: TaskEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * QueryRun without action
   */
  export type QueryRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueryRun
     */
    select?: QueryRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueryRun
     */
    omit?: QueryRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueryRunInclude<ExtArgs> | null
  }


  /**
   * Model TaskEvent
   */

  export type AggregateTaskEvent = {
    _count: TaskEventCountAggregateOutputType | null
    _min: TaskEventMinAggregateOutputType | null
    _max: TaskEventMaxAggregateOutputType | null
  }

  export type TaskEventMinAggregateOutputType = {
    id: string | null
    runId: string | null
    type: string | null
    message: string | null
    createdAt: Date | null
  }

  export type TaskEventMaxAggregateOutputType = {
    id: string | null
    runId: string | null
    type: string | null
    message: string | null
    createdAt: Date | null
  }

  export type TaskEventCountAggregateOutputType = {
    id: number
    runId: number
    type: number
    message: number
    data: number
    createdAt: number
    _all: number
  }


  export type TaskEventMinAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type TaskEventMaxAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    message?: true
    createdAt?: true
  }

  export type TaskEventCountAggregateInputType = {
    id?: true
    runId?: true
    type?: true
    message?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type TaskEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvent to aggregate.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskEvents
    **/
    _count?: true | TaskEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskEventMaxAggregateInputType
  }

  export type GetTaskEventAggregateType<T extends TaskEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskEvent[P]>
      : GetScalarType<T[P], AggregateTaskEvent[P]>
  }




  export type TaskEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskEventWhereInput
    orderBy?: TaskEventOrderByWithAggregationInput | TaskEventOrderByWithAggregationInput[]
    by: TaskEventScalarFieldEnum[] | TaskEventScalarFieldEnum
    having?: TaskEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskEventCountAggregateInputType | true
    _min?: TaskEventMinAggregateInputType
    _max?: TaskEventMaxAggregateInputType
  }

  export type TaskEventGroupByOutputType = {
    id: string
    runId: string
    type: string
    message: string
    data: JsonValue | null
    createdAt: Date
    _count: TaskEventCountAggregateOutputType | null
    _min: TaskEventMinAggregateOutputType | null
    _max: TaskEventMaxAggregateOutputType | null
  }

  type GetTaskEventGroupByPayload<T extends TaskEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskEventGroupByOutputType[P]>
            : GetScalarType<T[P], TaskEventGroupByOutputType[P]>
        }
      >
    >


  export type TaskEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    createdAt?: boolean
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    createdAt?: boolean
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    createdAt?: boolean
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskEvent"]>

  export type TaskEventSelectScalar = {
    id?: boolean
    runId?: boolean
    type?: boolean
    message?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type TaskEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runId" | "type" | "message" | "data" | "createdAt", ExtArgs["result"]["taskEvent"]>
  export type TaskEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }
  export type TaskEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }
  export type TaskEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    run?: boolean | QueryRunDefaultArgs<ExtArgs>
  }

  export type $TaskEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskEvent"
    objects: {
      run: Prisma.$QueryRunPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runId: string
      type: string
      message: string
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["taskEvent"]>
    composites: {}
  }

  type TaskEventGetPayload<S extends boolean | null | undefined | TaskEventDefaultArgs> = $Result.GetResult<Prisma.$TaskEventPayload, S>

  type TaskEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskEventCountAggregateInputType | true
    }

  export interface TaskEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskEvent'], meta: { name: 'TaskEvent' } }
    /**
     * Find zero or one TaskEvent that matches the filter.
     * @param {TaskEventFindUniqueArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskEventFindUniqueArgs>(args: SelectSubset<T, TaskEventFindUniqueArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskEventFindUniqueOrThrowArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindFirstArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskEventFindFirstArgs>(args?: SelectSubset<T, TaskEventFindFirstArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindFirstOrThrowArgs} args - Arguments to find a TaskEvent
     * @example
     * // Get one TaskEvent
     * const taskEvent = await prisma.taskEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskEvents
     * const taskEvents = await prisma.taskEvent.findMany()
     * 
     * // Get first 10 TaskEvents
     * const taskEvents = await prisma.taskEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskEventFindManyArgs>(args?: SelectSubset<T, TaskEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskEvent.
     * @param {TaskEventCreateArgs} args - Arguments to create a TaskEvent.
     * @example
     * // Create one TaskEvent
     * const TaskEvent = await prisma.taskEvent.create({
     *   data: {
     *     // ... data to create a TaskEvent
     *   }
     * })
     * 
     */
    create<T extends TaskEventCreateArgs>(args: SelectSubset<T, TaskEventCreateArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskEvents.
     * @param {TaskEventCreateManyArgs} args - Arguments to create many TaskEvents.
     * @example
     * // Create many TaskEvents
     * const taskEvent = await prisma.taskEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskEventCreateManyArgs>(args?: SelectSubset<T, TaskEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskEvents and returns the data saved in the database.
     * @param {TaskEventCreateManyAndReturnArgs} args - Arguments to create many TaskEvents.
     * @example
     * // Create many TaskEvents
     * const taskEvent = await prisma.taskEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskEvents and only return the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskEventCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskEvent.
     * @param {TaskEventDeleteArgs} args - Arguments to delete one TaskEvent.
     * @example
     * // Delete one TaskEvent
     * const TaskEvent = await prisma.taskEvent.delete({
     *   where: {
     *     // ... filter to delete one TaskEvent
     *   }
     * })
     * 
     */
    delete<T extends TaskEventDeleteArgs>(args: SelectSubset<T, TaskEventDeleteArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskEvent.
     * @param {TaskEventUpdateArgs} args - Arguments to update one TaskEvent.
     * @example
     * // Update one TaskEvent
     * const taskEvent = await prisma.taskEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskEventUpdateArgs>(args: SelectSubset<T, TaskEventUpdateArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskEvents.
     * @param {TaskEventDeleteManyArgs} args - Arguments to filter TaskEvents to delete.
     * @example
     * // Delete a few TaskEvents
     * const { count } = await prisma.taskEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskEventDeleteManyArgs>(args?: SelectSubset<T, TaskEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskEvents
     * const taskEvent = await prisma.taskEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskEventUpdateManyArgs>(args: SelectSubset<T, TaskEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskEvents and returns the data updated in the database.
     * @param {TaskEventUpdateManyAndReturnArgs} args - Arguments to update many TaskEvents.
     * @example
     * // Update many TaskEvents
     * const taskEvent = await prisma.taskEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskEvents and only return the `id`
     * const taskEventWithIdOnly = await prisma.taskEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskEventUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskEvent.
     * @param {TaskEventUpsertArgs} args - Arguments to update or create a TaskEvent.
     * @example
     * // Update or create a TaskEvent
     * const taskEvent = await prisma.taskEvent.upsert({
     *   create: {
     *     // ... data to create a TaskEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskEvent we want to update
     *   }
     * })
     */
    upsert<T extends TaskEventUpsertArgs>(args: SelectSubset<T, TaskEventUpsertArgs<ExtArgs>>): Prisma__TaskEventClient<$Result.GetResult<Prisma.$TaskEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventCountArgs} args - Arguments to filter TaskEvents to count.
     * @example
     * // Count the number of TaskEvents
     * const count = await prisma.taskEvent.count({
     *   where: {
     *     // ... the filter for the TaskEvents we want to count
     *   }
     * })
    **/
    count<T extends TaskEventCountArgs>(
      args?: Subset<T, TaskEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskEventAggregateArgs>(args: Subset<T, TaskEventAggregateArgs>): Prisma.PrismaPromise<GetTaskEventAggregateType<T>>

    /**
     * Group by TaskEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskEventGroupByArgs['orderBy'] }
        : { orderBy?: TaskEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskEvent model
   */
  readonly fields: TaskEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    run<T extends QueryRunDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueryRunDefaultArgs<ExtArgs>>): Prisma__QueryRunClient<$Result.GetResult<Prisma.$QueryRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskEvent model
   */
  interface TaskEventFieldRefs {
    readonly id: FieldRef<"TaskEvent", 'String'>
    readonly runId: FieldRef<"TaskEvent", 'String'>
    readonly type: FieldRef<"TaskEvent", 'String'>
    readonly message: FieldRef<"TaskEvent", 'String'>
    readonly data: FieldRef<"TaskEvent", 'Json'>
    readonly createdAt: FieldRef<"TaskEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskEvent findUnique
   */
  export type TaskEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent findUniqueOrThrow
   */
  export type TaskEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent findFirst
   */
  export type TaskEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvents.
     */
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent findFirstOrThrow
   */
  export type TaskEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvent to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskEvents.
     */
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent findMany
   */
  export type TaskEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter, which TaskEvents to fetch.
     */
    where?: TaskEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskEvents to fetch.
     */
    orderBy?: TaskEventOrderByWithRelationInput | TaskEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskEvents.
     */
    cursor?: TaskEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskEvents.
     */
    skip?: number
    distinct?: TaskEventScalarFieldEnum | TaskEventScalarFieldEnum[]
  }

  /**
   * TaskEvent create
   */
  export type TaskEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskEvent.
     */
    data: XOR<TaskEventCreateInput, TaskEventUncheckedCreateInput>
  }

  /**
   * TaskEvent createMany
   */
  export type TaskEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskEvents.
     */
    data: TaskEventCreateManyInput | TaskEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskEvent createManyAndReturn
   */
  export type TaskEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * The data used to create many TaskEvents.
     */
    data: TaskEventCreateManyInput | TaskEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskEvent update
   */
  export type TaskEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskEvent.
     */
    data: XOR<TaskEventUpdateInput, TaskEventUncheckedUpdateInput>
    /**
     * Choose, which TaskEvent to update.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent updateMany
   */
  export type TaskEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskEvents.
     */
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyInput>
    /**
     * Filter which TaskEvents to update
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to update.
     */
    limit?: number
  }

  /**
   * TaskEvent updateManyAndReturn
   */
  export type TaskEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * The data used to update TaskEvents.
     */
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyInput>
    /**
     * Filter which TaskEvents to update
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskEvent upsert
   */
  export type TaskEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskEvent to update in case it exists.
     */
    where: TaskEventWhereUniqueInput
    /**
     * In case the TaskEvent found by the `where` argument doesn't exist, create a new TaskEvent with this data.
     */
    create: XOR<TaskEventCreateInput, TaskEventUncheckedCreateInput>
    /**
     * In case the TaskEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskEventUpdateInput, TaskEventUncheckedUpdateInput>
  }

  /**
   * TaskEvent delete
   */
  export type TaskEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
    /**
     * Filter which TaskEvent to delete.
     */
    where: TaskEventWhereUniqueInput
  }

  /**
   * TaskEvent deleteMany
   */
  export type TaskEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskEvents to delete
     */
    where?: TaskEventWhereInput
    /**
     * Limit how many TaskEvents to delete.
     */
    limit?: number
  }

  /**
   * TaskEvent without action
   */
  export type TaskEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskEvent
     */
    select?: TaskEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskEvent
     */
    omit?: TaskEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskEventInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    markdown: string | null
    platform: string | null
    type: $Enums.ContentType | null
    time: Date | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    markdown: string | null
    platform: string | null
    type: $Enums.ContentType | null
    time: Date | null
    url: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    markdown: number
    platform: number
    type: number
    time: number
    url: number
    meta: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    markdown?: true
    platform?: true
    type?: true
    time?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    markdown?: true
    platform?: true
    type?: true
    time?: true
    url?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    markdown?: true
    platform?: true
    type?: true
    time?: true
    url?: true
    meta?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date
    url: string | null
    meta: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContentCountAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    markdown?: boolean
    platform?: boolean
    type?: boolean
    time?: boolean
    url?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    keywords?: boolean | Content$keywordsArgs<ExtArgs>
    entities?: boolean | Content$entitiesArgs<ExtArgs>
    favorites?: boolean | Content$favoritesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    markdown?: boolean
    platform?: boolean
    type?: boolean
    time?: boolean
    url?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    markdown?: boolean
    platform?: boolean
    type?: boolean
    time?: boolean
    url?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    markdown?: boolean
    platform?: boolean
    type?: boolean
    time?: boolean
    url?: boolean
    meta?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "summary" | "markdown" | "platform" | "type" | "time" | "url" | "meta" | "createdAt" | "updatedAt", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | Content$keywordsArgs<ExtArgs>
    entities?: boolean | Content$entitiesArgs<ExtArgs>
    favorites?: boolean | Content$favoritesArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      keywords: Prisma.$ContentKeywordPayload<ExtArgs>[]
      entities: Prisma.$ContentEntityPayload<ExtArgs> | null
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string
      markdown: string
      platform: string
      type: $Enums.ContentType
      time: Date
      url: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords<T extends Content$keywordsArgs<ExtArgs> = {}>(args?: Subset<T, Content$keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entities<T extends Content$entitiesArgs<ExtArgs> = {}>(args?: Subset<T, Content$entitiesArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    favorites<T extends Content$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Content$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'String'>
    readonly title: FieldRef<"Content", 'String'>
    readonly summary: FieldRef<"Content", 'String'>
    readonly markdown: FieldRef<"Content", 'String'>
    readonly platform: FieldRef<"Content", 'String'>
    readonly type: FieldRef<"Content", 'ContentType'>
    readonly time: FieldRef<"Content", 'DateTime'>
    readonly url: FieldRef<"Content", 'String'>
    readonly meta: FieldRef<"Content", 'Json'>
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.keywords
   */
  export type Content$keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    where?: ContentKeywordWhereInput
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    cursor?: ContentKeywordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentKeywordScalarFieldEnum | ContentKeywordScalarFieldEnum[]
  }

  /**
   * Content.entities
   */
  export type Content$entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    where?: ContentEntityWhereInput
  }

  /**
   * Content.favorites
   */
  export type Content$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentKeyword
   */

  export type AggregateContentKeyword = {
    _count: ContentKeywordCountAggregateOutputType | null
    _min: ContentKeywordMinAggregateOutputType | null
    _max: ContentKeywordMaxAggregateOutputType | null
  }

  export type ContentKeywordMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    keywordId: string | null
  }

  export type ContentKeywordMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    keywordId: string | null
  }

  export type ContentKeywordCountAggregateOutputType = {
    id: number
    contentId: number
    keywordId: number
    _all: number
  }


  export type ContentKeywordMinAggregateInputType = {
    id?: true
    contentId?: true
    keywordId?: true
  }

  export type ContentKeywordMaxAggregateInputType = {
    id?: true
    contentId?: true
    keywordId?: true
  }

  export type ContentKeywordCountAggregateInputType = {
    id?: true
    contentId?: true
    keywordId?: true
    _all?: true
  }

  export type ContentKeywordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentKeyword to aggregate.
     */
    where?: ContentKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentKeywords to fetch.
     */
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentKeywords
    **/
    _count?: true | ContentKeywordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentKeywordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentKeywordMaxAggregateInputType
  }

  export type GetContentKeywordAggregateType<T extends ContentKeywordAggregateArgs> = {
        [P in keyof T & keyof AggregateContentKeyword]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentKeyword[P]>
      : GetScalarType<T[P], AggregateContentKeyword[P]>
  }




  export type ContentKeywordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentKeywordWhereInput
    orderBy?: ContentKeywordOrderByWithAggregationInput | ContentKeywordOrderByWithAggregationInput[]
    by: ContentKeywordScalarFieldEnum[] | ContentKeywordScalarFieldEnum
    having?: ContentKeywordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentKeywordCountAggregateInputType | true
    _min?: ContentKeywordMinAggregateInputType
    _max?: ContentKeywordMaxAggregateInputType
  }

  export type ContentKeywordGroupByOutputType = {
    id: string
    contentId: string
    keywordId: string
    _count: ContentKeywordCountAggregateOutputType | null
    _min: ContentKeywordMinAggregateOutputType | null
    _max: ContentKeywordMaxAggregateOutputType | null
  }

  type GetContentKeywordGroupByPayload<T extends ContentKeywordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentKeywordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentKeywordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentKeywordGroupByOutputType[P]>
            : GetScalarType<T[P], ContentKeywordGroupByOutputType[P]>
        }
      >
    >


  export type ContentKeywordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    keywordId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentKeyword"]>

  export type ContentKeywordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    keywordId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentKeyword"]>

  export type ContentKeywordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    keywordId?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentKeyword"]>

  export type ContentKeywordSelectScalar = {
    id?: boolean
    contentId?: boolean
    keywordId?: boolean
  }

  export type ContentKeywordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "keywordId", ExtArgs["result"]["contentKeyword"]>
  export type ContentKeywordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }
  export type ContentKeywordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }
  export type ContentKeywordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    keyword?: boolean | KeywordDefaultArgs<ExtArgs>
  }

  export type $ContentKeywordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentKeyword"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      keyword: Prisma.$KeywordPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      keywordId: string
    }, ExtArgs["result"]["contentKeyword"]>
    composites: {}
  }

  type ContentKeywordGetPayload<S extends boolean | null | undefined | ContentKeywordDefaultArgs> = $Result.GetResult<Prisma.$ContentKeywordPayload, S>

  type ContentKeywordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentKeywordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentKeywordCountAggregateInputType | true
    }

  export interface ContentKeywordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentKeyword'], meta: { name: 'ContentKeyword' } }
    /**
     * Find zero or one ContentKeyword that matches the filter.
     * @param {ContentKeywordFindUniqueArgs} args - Arguments to find a ContentKeyword
     * @example
     * // Get one ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentKeywordFindUniqueArgs>(args: SelectSubset<T, ContentKeywordFindUniqueArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentKeyword that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentKeywordFindUniqueOrThrowArgs} args - Arguments to find a ContentKeyword
     * @example
     * // Get one ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentKeywordFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentKeywordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentKeyword that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordFindFirstArgs} args - Arguments to find a ContentKeyword
     * @example
     * // Get one ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentKeywordFindFirstArgs>(args?: SelectSubset<T, ContentKeywordFindFirstArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentKeyword that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordFindFirstOrThrowArgs} args - Arguments to find a ContentKeyword
     * @example
     * // Get one ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentKeywordFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentKeywordFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentKeywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentKeywords
     * const contentKeywords = await prisma.contentKeyword.findMany()
     * 
     * // Get first 10 ContentKeywords
     * const contentKeywords = await prisma.contentKeyword.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentKeywordWithIdOnly = await prisma.contentKeyword.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentKeywordFindManyArgs>(args?: SelectSubset<T, ContentKeywordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentKeyword.
     * @param {ContentKeywordCreateArgs} args - Arguments to create a ContentKeyword.
     * @example
     * // Create one ContentKeyword
     * const ContentKeyword = await prisma.contentKeyword.create({
     *   data: {
     *     // ... data to create a ContentKeyword
     *   }
     * })
     * 
     */
    create<T extends ContentKeywordCreateArgs>(args: SelectSubset<T, ContentKeywordCreateArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentKeywords.
     * @param {ContentKeywordCreateManyArgs} args - Arguments to create many ContentKeywords.
     * @example
     * // Create many ContentKeywords
     * const contentKeyword = await prisma.contentKeyword.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentKeywordCreateManyArgs>(args?: SelectSubset<T, ContentKeywordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentKeywords and returns the data saved in the database.
     * @param {ContentKeywordCreateManyAndReturnArgs} args - Arguments to create many ContentKeywords.
     * @example
     * // Create many ContentKeywords
     * const contentKeyword = await prisma.contentKeyword.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentKeywords and only return the `id`
     * const contentKeywordWithIdOnly = await prisma.contentKeyword.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentKeywordCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentKeywordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentKeyword.
     * @param {ContentKeywordDeleteArgs} args - Arguments to delete one ContentKeyword.
     * @example
     * // Delete one ContentKeyword
     * const ContentKeyword = await prisma.contentKeyword.delete({
     *   where: {
     *     // ... filter to delete one ContentKeyword
     *   }
     * })
     * 
     */
    delete<T extends ContentKeywordDeleteArgs>(args: SelectSubset<T, ContentKeywordDeleteArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentKeyword.
     * @param {ContentKeywordUpdateArgs} args - Arguments to update one ContentKeyword.
     * @example
     * // Update one ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentKeywordUpdateArgs>(args: SelectSubset<T, ContentKeywordUpdateArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentKeywords.
     * @param {ContentKeywordDeleteManyArgs} args - Arguments to filter ContentKeywords to delete.
     * @example
     * // Delete a few ContentKeywords
     * const { count } = await prisma.contentKeyword.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentKeywordDeleteManyArgs>(args?: SelectSubset<T, ContentKeywordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentKeywords
     * const contentKeyword = await prisma.contentKeyword.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentKeywordUpdateManyArgs>(args: SelectSubset<T, ContentKeywordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentKeywords and returns the data updated in the database.
     * @param {ContentKeywordUpdateManyAndReturnArgs} args - Arguments to update many ContentKeywords.
     * @example
     * // Update many ContentKeywords
     * const contentKeyword = await prisma.contentKeyword.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentKeywords and only return the `id`
     * const contentKeywordWithIdOnly = await prisma.contentKeyword.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentKeywordUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentKeywordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentKeyword.
     * @param {ContentKeywordUpsertArgs} args - Arguments to update or create a ContentKeyword.
     * @example
     * // Update or create a ContentKeyword
     * const contentKeyword = await prisma.contentKeyword.upsert({
     *   create: {
     *     // ... data to create a ContentKeyword
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentKeyword we want to update
     *   }
     * })
     */
    upsert<T extends ContentKeywordUpsertArgs>(args: SelectSubset<T, ContentKeywordUpsertArgs<ExtArgs>>): Prisma__ContentKeywordClient<$Result.GetResult<Prisma.$ContentKeywordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentKeywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordCountArgs} args - Arguments to filter ContentKeywords to count.
     * @example
     * // Count the number of ContentKeywords
     * const count = await prisma.contentKeyword.count({
     *   where: {
     *     // ... the filter for the ContentKeywords we want to count
     *   }
     * })
    **/
    count<T extends ContentKeywordCountArgs>(
      args?: Subset<T, ContentKeywordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentKeywordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentKeywordAggregateArgs>(args: Subset<T, ContentKeywordAggregateArgs>): Prisma.PrismaPromise<GetContentKeywordAggregateType<T>>

    /**
     * Group by ContentKeyword.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentKeywordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentKeywordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentKeywordGroupByArgs['orderBy'] }
        : { orderBy?: ContentKeywordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentKeywordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentKeywordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentKeyword model
   */
  readonly fields: ContentKeywordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentKeyword.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentKeywordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    keyword<T extends KeywordDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KeywordDefaultArgs<ExtArgs>>): Prisma__KeywordClient<$Result.GetResult<Prisma.$KeywordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentKeyword model
   */
  interface ContentKeywordFieldRefs {
    readonly id: FieldRef<"ContentKeyword", 'String'>
    readonly contentId: FieldRef<"ContentKeyword", 'String'>
    readonly keywordId: FieldRef<"ContentKeyword", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContentKeyword findUnique
   */
  export type ContentKeywordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter, which ContentKeyword to fetch.
     */
    where: ContentKeywordWhereUniqueInput
  }

  /**
   * ContentKeyword findUniqueOrThrow
   */
  export type ContentKeywordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter, which ContentKeyword to fetch.
     */
    where: ContentKeywordWhereUniqueInput
  }

  /**
   * ContentKeyword findFirst
   */
  export type ContentKeywordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter, which ContentKeyword to fetch.
     */
    where?: ContentKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentKeywords to fetch.
     */
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentKeywords.
     */
    cursor?: ContentKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentKeywords.
     */
    distinct?: ContentKeywordScalarFieldEnum | ContentKeywordScalarFieldEnum[]
  }

  /**
   * ContentKeyword findFirstOrThrow
   */
  export type ContentKeywordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter, which ContentKeyword to fetch.
     */
    where?: ContentKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentKeywords to fetch.
     */
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentKeywords.
     */
    cursor?: ContentKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentKeywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentKeywords.
     */
    distinct?: ContentKeywordScalarFieldEnum | ContentKeywordScalarFieldEnum[]
  }

  /**
   * ContentKeyword findMany
   */
  export type ContentKeywordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter, which ContentKeywords to fetch.
     */
    where?: ContentKeywordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentKeywords to fetch.
     */
    orderBy?: ContentKeywordOrderByWithRelationInput | ContentKeywordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentKeywords.
     */
    cursor?: ContentKeywordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentKeywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentKeywords.
     */
    skip?: number
    distinct?: ContentKeywordScalarFieldEnum | ContentKeywordScalarFieldEnum[]
  }

  /**
   * ContentKeyword create
   */
  export type ContentKeywordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentKeyword.
     */
    data: XOR<ContentKeywordCreateInput, ContentKeywordUncheckedCreateInput>
  }

  /**
   * ContentKeyword createMany
   */
  export type ContentKeywordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentKeywords.
     */
    data: ContentKeywordCreateManyInput | ContentKeywordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentKeyword createManyAndReturn
   */
  export type ContentKeywordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * The data used to create many ContentKeywords.
     */
    data: ContentKeywordCreateManyInput | ContentKeywordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentKeyword update
   */
  export type ContentKeywordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentKeyword.
     */
    data: XOR<ContentKeywordUpdateInput, ContentKeywordUncheckedUpdateInput>
    /**
     * Choose, which ContentKeyword to update.
     */
    where: ContentKeywordWhereUniqueInput
  }

  /**
   * ContentKeyword updateMany
   */
  export type ContentKeywordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentKeywords.
     */
    data: XOR<ContentKeywordUpdateManyMutationInput, ContentKeywordUncheckedUpdateManyInput>
    /**
     * Filter which ContentKeywords to update
     */
    where?: ContentKeywordWhereInput
    /**
     * Limit how many ContentKeywords to update.
     */
    limit?: number
  }

  /**
   * ContentKeyword updateManyAndReturn
   */
  export type ContentKeywordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * The data used to update ContentKeywords.
     */
    data: XOR<ContentKeywordUpdateManyMutationInput, ContentKeywordUncheckedUpdateManyInput>
    /**
     * Filter which ContentKeywords to update
     */
    where?: ContentKeywordWhereInput
    /**
     * Limit how many ContentKeywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentKeyword upsert
   */
  export type ContentKeywordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentKeyword to update in case it exists.
     */
    where: ContentKeywordWhereUniqueInput
    /**
     * In case the ContentKeyword found by the `where` argument doesn't exist, create a new ContentKeyword with this data.
     */
    create: XOR<ContentKeywordCreateInput, ContentKeywordUncheckedCreateInput>
    /**
     * In case the ContentKeyword was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentKeywordUpdateInput, ContentKeywordUncheckedUpdateInput>
  }

  /**
   * ContentKeyword delete
   */
  export type ContentKeywordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
    /**
     * Filter which ContentKeyword to delete.
     */
    where: ContentKeywordWhereUniqueInput
  }

  /**
   * ContentKeyword deleteMany
   */
  export type ContentKeywordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentKeywords to delete
     */
    where?: ContentKeywordWhereInput
    /**
     * Limit how many ContentKeywords to delete.
     */
    limit?: number
  }

  /**
   * ContentKeyword without action
   */
  export type ContentKeywordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentKeyword
     */
    select?: ContentKeywordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentKeyword
     */
    omit?: ContentKeywordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentKeywordInclude<ExtArgs> | null
  }


  /**
   * Model ContentEntity
   */

  export type AggregateContentEntity = {
    _count: ContentEntityCountAggregateOutputType | null
    _min: ContentEntityMinAggregateOutputType | null
    _max: ContentEntityMaxAggregateOutputType | null
  }

  export type ContentEntityMinAggregateOutputType = {
    id: string | null
    contentId: string | null
  }

  export type ContentEntityMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
  }

  export type ContentEntityCountAggregateOutputType = {
    id: number
    contentId: number
    persons: number
    orgs: number
    locations: number
    _all: number
  }


  export type ContentEntityMinAggregateInputType = {
    id?: true
    contentId?: true
  }

  export type ContentEntityMaxAggregateInputType = {
    id?: true
    contentId?: true
  }

  export type ContentEntityCountAggregateInputType = {
    id?: true
    contentId?: true
    persons?: true
    orgs?: true
    locations?: true
    _all?: true
  }

  export type ContentEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentEntity to aggregate.
     */
    where?: ContentEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentEntities to fetch.
     */
    orderBy?: ContentEntityOrderByWithRelationInput | ContentEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentEntities
    **/
    _count?: true | ContentEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentEntityMaxAggregateInputType
  }

  export type GetContentEntityAggregateType<T extends ContentEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateContentEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentEntity[P]>
      : GetScalarType<T[P], AggregateContentEntity[P]>
  }




  export type ContentEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentEntityWhereInput
    orderBy?: ContentEntityOrderByWithAggregationInput | ContentEntityOrderByWithAggregationInput[]
    by: ContentEntityScalarFieldEnum[] | ContentEntityScalarFieldEnum
    having?: ContentEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentEntityCountAggregateInputType | true
    _min?: ContentEntityMinAggregateInputType
    _max?: ContentEntityMaxAggregateInputType
  }

  export type ContentEntityGroupByOutputType = {
    id: string
    contentId: string
    persons: string[]
    orgs: string[]
    locations: string[]
    _count: ContentEntityCountAggregateOutputType | null
    _min: ContentEntityMinAggregateOutputType | null
    _max: ContentEntityMaxAggregateOutputType | null
  }

  type GetContentEntityGroupByPayload<T extends ContentEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentEntityGroupByOutputType[P]>
            : GetScalarType<T[P], ContentEntityGroupByOutputType[P]>
        }
      >
    >


  export type ContentEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    persons?: boolean
    orgs?: boolean
    locations?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentEntity"]>

  export type ContentEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    persons?: boolean
    orgs?: boolean
    locations?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentEntity"]>

  export type ContentEntitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    persons?: boolean
    orgs?: boolean
    locations?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentEntity"]>

  export type ContentEntitySelectScalar = {
    id?: boolean
    contentId?: boolean
    persons?: boolean
    orgs?: boolean
    locations?: boolean
  }

  export type ContentEntityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "persons" | "orgs" | "locations", ExtArgs["result"]["contentEntity"]>
  export type ContentEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentEntityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type ContentEntityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }

  export type $ContentEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentEntity"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      persons: string[]
      orgs: string[]
      locations: string[]
    }, ExtArgs["result"]["contentEntity"]>
    composites: {}
  }

  type ContentEntityGetPayload<S extends boolean | null | undefined | ContentEntityDefaultArgs> = $Result.GetResult<Prisma.$ContentEntityPayload, S>

  type ContentEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentEntityCountAggregateInputType | true
    }

  export interface ContentEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentEntity'], meta: { name: 'ContentEntity' } }
    /**
     * Find zero or one ContentEntity that matches the filter.
     * @param {ContentEntityFindUniqueArgs} args - Arguments to find a ContentEntity
     * @example
     * // Get one ContentEntity
     * const contentEntity = await prisma.contentEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentEntityFindUniqueArgs>(args: SelectSubset<T, ContentEntityFindUniqueArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentEntityFindUniqueOrThrowArgs} args - Arguments to find a ContentEntity
     * @example
     * // Get one ContentEntity
     * const contentEntity = await prisma.contentEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityFindFirstArgs} args - Arguments to find a ContentEntity
     * @example
     * // Get one ContentEntity
     * const contentEntity = await prisma.contentEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentEntityFindFirstArgs>(args?: SelectSubset<T, ContentEntityFindFirstArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityFindFirstOrThrowArgs} args - Arguments to find a ContentEntity
     * @example
     * // Get one ContentEntity
     * const contentEntity = await prisma.contentEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentEntities
     * const contentEntities = await prisma.contentEntity.findMany()
     * 
     * // Get first 10 ContentEntities
     * const contentEntities = await prisma.contentEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentEntityWithIdOnly = await prisma.contentEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentEntityFindManyArgs>(args?: SelectSubset<T, ContentEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentEntity.
     * @param {ContentEntityCreateArgs} args - Arguments to create a ContentEntity.
     * @example
     * // Create one ContentEntity
     * const ContentEntity = await prisma.contentEntity.create({
     *   data: {
     *     // ... data to create a ContentEntity
     *   }
     * })
     * 
     */
    create<T extends ContentEntityCreateArgs>(args: SelectSubset<T, ContentEntityCreateArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentEntities.
     * @param {ContentEntityCreateManyArgs} args - Arguments to create many ContentEntities.
     * @example
     * // Create many ContentEntities
     * const contentEntity = await prisma.contentEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentEntityCreateManyArgs>(args?: SelectSubset<T, ContentEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentEntities and returns the data saved in the database.
     * @param {ContentEntityCreateManyAndReturnArgs} args - Arguments to create many ContentEntities.
     * @example
     * // Create many ContentEntities
     * const contentEntity = await prisma.contentEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentEntities and only return the `id`
     * const contentEntityWithIdOnly = await prisma.contentEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentEntity.
     * @param {ContentEntityDeleteArgs} args - Arguments to delete one ContentEntity.
     * @example
     * // Delete one ContentEntity
     * const ContentEntity = await prisma.contentEntity.delete({
     *   where: {
     *     // ... filter to delete one ContentEntity
     *   }
     * })
     * 
     */
    delete<T extends ContentEntityDeleteArgs>(args: SelectSubset<T, ContentEntityDeleteArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentEntity.
     * @param {ContentEntityUpdateArgs} args - Arguments to update one ContentEntity.
     * @example
     * // Update one ContentEntity
     * const contentEntity = await prisma.contentEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentEntityUpdateArgs>(args: SelectSubset<T, ContentEntityUpdateArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentEntities.
     * @param {ContentEntityDeleteManyArgs} args - Arguments to filter ContentEntities to delete.
     * @example
     * // Delete a few ContentEntities
     * const { count } = await prisma.contentEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentEntityDeleteManyArgs>(args?: SelectSubset<T, ContentEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentEntities
     * const contentEntity = await prisma.contentEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentEntityUpdateManyArgs>(args: SelectSubset<T, ContentEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentEntities and returns the data updated in the database.
     * @param {ContentEntityUpdateManyAndReturnArgs} args - Arguments to update many ContentEntities.
     * @example
     * // Update many ContentEntities
     * const contentEntity = await prisma.contentEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentEntities and only return the `id`
     * const contentEntityWithIdOnly = await prisma.contentEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentEntityUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentEntity.
     * @param {ContentEntityUpsertArgs} args - Arguments to update or create a ContentEntity.
     * @example
     * // Update or create a ContentEntity
     * const contentEntity = await prisma.contentEntity.upsert({
     *   create: {
     *     // ... data to create a ContentEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentEntity we want to update
     *   }
     * })
     */
    upsert<T extends ContentEntityUpsertArgs>(args: SelectSubset<T, ContentEntityUpsertArgs<ExtArgs>>): Prisma__ContentEntityClient<$Result.GetResult<Prisma.$ContentEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityCountArgs} args - Arguments to filter ContentEntities to count.
     * @example
     * // Count the number of ContentEntities
     * const count = await prisma.contentEntity.count({
     *   where: {
     *     // ... the filter for the ContentEntities we want to count
     *   }
     * })
    **/
    count<T extends ContentEntityCountArgs>(
      args?: Subset<T, ContentEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentEntityAggregateArgs>(args: Subset<T, ContentEntityAggregateArgs>): Prisma.PrismaPromise<GetContentEntityAggregateType<T>>

    /**
     * Group by ContentEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentEntityGroupByArgs['orderBy'] }
        : { orderBy?: ContentEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentEntity model
   */
  readonly fields: ContentEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentEntity model
   */
  interface ContentEntityFieldRefs {
    readonly id: FieldRef<"ContentEntity", 'String'>
    readonly contentId: FieldRef<"ContentEntity", 'String'>
    readonly persons: FieldRef<"ContentEntity", 'String[]'>
    readonly orgs: FieldRef<"ContentEntity", 'String[]'>
    readonly locations: FieldRef<"ContentEntity", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * ContentEntity findUnique
   */
  export type ContentEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter, which ContentEntity to fetch.
     */
    where: ContentEntityWhereUniqueInput
  }

  /**
   * ContentEntity findUniqueOrThrow
   */
  export type ContentEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter, which ContentEntity to fetch.
     */
    where: ContentEntityWhereUniqueInput
  }

  /**
   * ContentEntity findFirst
   */
  export type ContentEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter, which ContentEntity to fetch.
     */
    where?: ContentEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentEntities to fetch.
     */
    orderBy?: ContentEntityOrderByWithRelationInput | ContentEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentEntities.
     */
    cursor?: ContentEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentEntities.
     */
    distinct?: ContentEntityScalarFieldEnum | ContentEntityScalarFieldEnum[]
  }

  /**
   * ContentEntity findFirstOrThrow
   */
  export type ContentEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter, which ContentEntity to fetch.
     */
    where?: ContentEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentEntities to fetch.
     */
    orderBy?: ContentEntityOrderByWithRelationInput | ContentEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentEntities.
     */
    cursor?: ContentEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentEntities.
     */
    distinct?: ContentEntityScalarFieldEnum | ContentEntityScalarFieldEnum[]
  }

  /**
   * ContentEntity findMany
   */
  export type ContentEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter, which ContentEntities to fetch.
     */
    where?: ContentEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentEntities to fetch.
     */
    orderBy?: ContentEntityOrderByWithRelationInput | ContentEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentEntities.
     */
    cursor?: ContentEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentEntities.
     */
    skip?: number
    distinct?: ContentEntityScalarFieldEnum | ContentEntityScalarFieldEnum[]
  }

  /**
   * ContentEntity create
   */
  export type ContentEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentEntity.
     */
    data: XOR<ContentEntityCreateInput, ContentEntityUncheckedCreateInput>
  }

  /**
   * ContentEntity createMany
   */
  export type ContentEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentEntities.
     */
    data: ContentEntityCreateManyInput | ContentEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentEntity createManyAndReturn
   */
  export type ContentEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * The data used to create many ContentEntities.
     */
    data: ContentEntityCreateManyInput | ContentEntityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentEntity update
   */
  export type ContentEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentEntity.
     */
    data: XOR<ContentEntityUpdateInput, ContentEntityUncheckedUpdateInput>
    /**
     * Choose, which ContentEntity to update.
     */
    where: ContentEntityWhereUniqueInput
  }

  /**
   * ContentEntity updateMany
   */
  export type ContentEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentEntities.
     */
    data: XOR<ContentEntityUpdateManyMutationInput, ContentEntityUncheckedUpdateManyInput>
    /**
     * Filter which ContentEntities to update
     */
    where?: ContentEntityWhereInput
    /**
     * Limit how many ContentEntities to update.
     */
    limit?: number
  }

  /**
   * ContentEntity updateManyAndReturn
   */
  export type ContentEntityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * The data used to update ContentEntities.
     */
    data: XOR<ContentEntityUpdateManyMutationInput, ContentEntityUncheckedUpdateManyInput>
    /**
     * Filter which ContentEntities to update
     */
    where?: ContentEntityWhereInput
    /**
     * Limit how many ContentEntities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentEntity upsert
   */
  export type ContentEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentEntity to update in case it exists.
     */
    where: ContentEntityWhereUniqueInput
    /**
     * In case the ContentEntity found by the `where` argument doesn't exist, create a new ContentEntity with this data.
     */
    create: XOR<ContentEntityCreateInput, ContentEntityUncheckedCreateInput>
    /**
     * In case the ContentEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentEntityUpdateInput, ContentEntityUncheckedUpdateInput>
  }

  /**
   * ContentEntity delete
   */
  export type ContentEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
    /**
     * Filter which ContentEntity to delete.
     */
    where: ContentEntityWhereUniqueInput
  }

  /**
   * ContentEntity deleteMany
   */
  export type ContentEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentEntities to delete
     */
    where?: ContentEntityWhereInput
    /**
     * Limit how many ContentEntities to delete.
     */
    limit?: number
  }

  /**
   * ContentEntity without action
   */
  export type ContentEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentEntity
     */
    select?: ContentEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentEntity
     */
    omit?: ContentEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentEntityInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteMinAggregateOutputType = {
    id: string | null
    userId: string | null
    contentId: string | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    contentId: string | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    id: number
    userId: number
    contentId: number
    createdAt: number
    _all: number
  }


  export type FavoriteMinAggregateInputType = {
    id?: true
    userId?: true
    contentId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    id?: true
    userId?: true
    contentId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    id?: true
    userId?: true
    contentId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    id: string
    userId: string
    contentId: string
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentId?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentId?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    contentId?: boolean
    createdAt?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    id?: boolean
    userId?: boolean
    contentId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "contentId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      contentId: string
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteWithIdOnly = await prisma.favorite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `id`
     * const favoriteWithIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */
  interface FavoriteFieldRefs {
    readonly id: FieldRef<"Favorite", 'String'>
    readonly userId: FieldRef<"Favorite", 'String'>
    readonly contentId: FieldRef<"Favorite", 'String'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model ReportTemplate
   */

  export type AggregateReportTemplate = {
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  export type ReportTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    markdown: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    markdown: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    markdown: number
    metadata: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    markdown?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    markdown?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    markdown?: true
    metadata?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplate to aggregate.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportTemplates
    **/
    _count?: true | ReportTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type GetReportTemplateAggregateType<T extends ReportTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateReportTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportTemplate[P]>
      : GetScalarType<T[P], AggregateReportTemplate[P]>
  }




  export type ReportTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportTemplateWhereInput
    orderBy?: ReportTemplateOrderByWithAggregationInput | ReportTemplateOrderByWithAggregationInput[]
    by: ReportTemplateScalarFieldEnum[] | ReportTemplateScalarFieldEnum
    having?: ReportTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportTemplateCountAggregateInputType | true
    _min?: ReportTemplateMinAggregateInputType
    _max?: ReportTemplateMaxAggregateInputType
  }

  export type ReportTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    markdown: string | null
    metadata: JsonValue | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReportTemplateCountAggregateOutputType | null
    _min: ReportTemplateMinAggregateOutputType | null
    _max: ReportTemplateMaxAggregateOutputType | null
  }

  type GetReportTemplateGroupByPayload<T extends ReportTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ReportTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ReportTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    markdown?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    markdown?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    markdown?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["reportTemplate"]>

  export type ReportTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    markdown?: boolean
    metadata?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "markdown" | "metadata" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["reportTemplate"]>
  export type ReportTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | ReportTemplate$reportsArgs<ExtArgs>
    _count?: boolean | ReportTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ReportTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ReportTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportTemplate"
    objects: {
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      markdown: string | null
      metadata: Prisma.JsonValue | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reportTemplate"]>
    composites: {}
  }

  type ReportTemplateGetPayload<S extends boolean | null | undefined | ReportTemplateDefaultArgs> = $Result.GetResult<Prisma.$ReportTemplatePayload, S>

  type ReportTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportTemplateCountAggregateInputType | true
    }

  export interface ReportTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportTemplate'], meta: { name: 'ReportTemplate' } }
    /**
     * Find zero or one ReportTemplate that matches the filter.
     * @param {ReportTemplateFindUniqueArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportTemplateFindUniqueArgs>(args: SelectSubset<T, ReportTemplateFindUniqueArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportTemplateFindUniqueOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportTemplateFindFirstArgs>(args?: SelectSubset<T, ReportTemplateFindFirstArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindFirstOrThrowArgs} args - Arguments to find a ReportTemplate
     * @example
     * // Get one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany()
     * 
     * // Get first 10 ReportTemplates
     * const reportTemplates = await prisma.reportTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportTemplateFindManyArgs>(args?: SelectSubset<T, ReportTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportTemplate.
     * @param {ReportTemplateCreateArgs} args - Arguments to create a ReportTemplate.
     * @example
     * // Create one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.create({
     *   data: {
     *     // ... data to create a ReportTemplate
     *   }
     * })
     * 
     */
    create<T extends ReportTemplateCreateArgs>(args: SelectSubset<T, ReportTemplateCreateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportTemplates.
     * @param {ReportTemplateCreateManyArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportTemplateCreateManyArgs>(args?: SelectSubset<T, ReportTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportTemplates and returns the data saved in the database.
     * @param {ReportTemplateCreateManyAndReturnArgs} args - Arguments to create many ReportTemplates.
     * @example
     * // Create many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportTemplate.
     * @param {ReportTemplateDeleteArgs} args - Arguments to delete one ReportTemplate.
     * @example
     * // Delete one ReportTemplate
     * const ReportTemplate = await prisma.reportTemplate.delete({
     *   where: {
     *     // ... filter to delete one ReportTemplate
     *   }
     * })
     * 
     */
    delete<T extends ReportTemplateDeleteArgs>(args: SelectSubset<T, ReportTemplateDeleteArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportTemplate.
     * @param {ReportTemplateUpdateArgs} args - Arguments to update one ReportTemplate.
     * @example
     * // Update one ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportTemplateUpdateArgs>(args: SelectSubset<T, ReportTemplateUpdateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportTemplates.
     * @param {ReportTemplateDeleteManyArgs} args - Arguments to filter ReportTemplates to delete.
     * @example
     * // Delete a few ReportTemplates
     * const { count } = await prisma.reportTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportTemplateDeleteManyArgs>(args?: SelectSubset<T, ReportTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportTemplateUpdateManyArgs>(args: SelectSubset<T, ReportTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportTemplates and returns the data updated in the database.
     * @param {ReportTemplateUpdateManyAndReturnArgs} args - Arguments to update many ReportTemplates.
     * @example
     * // Update many ReportTemplates
     * const reportTemplate = await prisma.reportTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportTemplates and only return the `id`
     * const reportTemplateWithIdOnly = await prisma.reportTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportTemplate.
     * @param {ReportTemplateUpsertArgs} args - Arguments to update or create a ReportTemplate.
     * @example
     * // Update or create a ReportTemplate
     * const reportTemplate = await prisma.reportTemplate.upsert({
     *   create: {
     *     // ... data to create a ReportTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ReportTemplateUpsertArgs>(args: SelectSubset<T, ReportTemplateUpsertArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateCountArgs} args - Arguments to filter ReportTemplates to count.
     * @example
     * // Count the number of ReportTemplates
     * const count = await prisma.reportTemplate.count({
     *   where: {
     *     // ... the filter for the ReportTemplates we want to count
     *   }
     * })
    **/
    count<T extends ReportTemplateCountArgs>(
      args?: Subset<T, ReportTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportTemplateAggregateArgs>(args: Subset<T, ReportTemplateAggregateArgs>): Prisma.PrismaPromise<GetReportTemplateAggregateType<T>>

    /**
     * Group by ReportTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ReportTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportTemplate model
   */
  readonly fields: ReportTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends ReportTemplate$reportsArgs<ExtArgs> = {}>(args?: Subset<T, ReportTemplate$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportTemplate model
   */
  interface ReportTemplateFieldRefs {
    readonly id: FieldRef<"ReportTemplate", 'String'>
    readonly name: FieldRef<"ReportTemplate", 'String'>
    readonly description: FieldRef<"ReportTemplate", 'String'>
    readonly markdown: FieldRef<"ReportTemplate", 'String'>
    readonly metadata: FieldRef<"ReportTemplate", 'Json'>
    readonly createdBy: FieldRef<"ReportTemplate", 'String'>
    readonly createdAt: FieldRef<"ReportTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ReportTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportTemplate findUnique
   */
  export type ReportTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findUniqueOrThrow
   */
  export type ReportTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate findFirst
   */
  export type ReportTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findFirstOrThrow
   */
  export type ReportTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplate to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportTemplates.
     */
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate findMany
   */
  export type ReportTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ReportTemplates to fetch.
     */
    where?: ReportTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportTemplates to fetch.
     */
    orderBy?: ReportTemplateOrderByWithRelationInput | ReportTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportTemplates.
     */
    cursor?: ReportTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportTemplates.
     */
    skip?: number
    distinct?: ReportTemplateScalarFieldEnum | ReportTemplateScalarFieldEnum[]
  }

  /**
   * ReportTemplate create
   */
  export type ReportTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportTemplate.
     */
    data: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
  }

  /**
   * ReportTemplate createMany
   */
  export type ReportTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate createManyAndReturn
   */
  export type ReportTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ReportTemplates.
     */
    data: ReportTemplateCreateManyInput | ReportTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportTemplate update
   */
  export type ReportTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportTemplate.
     */
    data: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
    /**
     * Choose, which ReportTemplate to update.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate updateMany
   */
  export type ReportTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
  }

  /**
   * ReportTemplate updateManyAndReturn
   */
  export type ReportTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ReportTemplates.
     */
    data: XOR<ReportTemplateUpdateManyMutationInput, ReportTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ReportTemplates to update
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to update.
     */
    limit?: number
  }

  /**
   * ReportTemplate upsert
   */
  export type ReportTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportTemplate to update in case it exists.
     */
    where: ReportTemplateWhereUniqueInput
    /**
     * In case the ReportTemplate found by the `where` argument doesn't exist, create a new ReportTemplate with this data.
     */
    create: XOR<ReportTemplateCreateInput, ReportTemplateUncheckedCreateInput>
    /**
     * In case the ReportTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportTemplateUpdateInput, ReportTemplateUncheckedUpdateInput>
  }

  /**
   * ReportTemplate delete
   */
  export type ReportTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    /**
     * Filter which ReportTemplate to delete.
     */
    where: ReportTemplateWhereUniqueInput
  }

  /**
   * ReportTemplate deleteMany
   */
  export type ReportTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportTemplates to delete
     */
    where?: ReportTemplateWhereInput
    /**
     * Limit how many ReportTemplates to delete.
     */
    limit?: number
  }

  /**
   * ReportTemplate.reports
   */
  export type ReportTemplate$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * ReportTemplate without action
   */
  export type ReportTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    version: number | null
  }

  export type ReportSumAggregateOutputType = {
    version: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.ReportStatus | null
    templateId: string | null
    authorId: string | null
    markdown: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    title: string | null
    summary: string | null
    status: $Enums.ReportStatus | null
    templateId: string | null
    authorId: string | null
    markdown: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    title: number
    summary: number
    status: number
    templateId: number
    authorId: number
    markdown: number
    metadata: number
    version: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    version?: true
  }

  export type ReportSumAggregateInputType = {
    version?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    templateId?: true
    authorId?: true
    markdown?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    templateId?: true
    authorId?: true
    markdown?: true
    version?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    title?: true
    summary?: true
    status?: true
    templateId?: true
    authorId?: true
    markdown?: true
    metadata?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    title: string
    summary: string | null
    status: $Enums.ReportStatus
    templateId: string | null
    authorId: string | null
    markdown: string | null
    metadata: JsonValue | null
    version: number
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    templateId?: boolean
    authorId?: boolean
    markdown?: boolean
    metadata?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | Report$templateArgs<ExtArgs>
    materials?: boolean | Report$materialsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    templateId?: boolean
    authorId?: boolean
    markdown?: boolean
    metadata?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | Report$templateArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    templateId?: boolean
    authorId?: boolean
    markdown?: boolean
    metadata?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | Report$templateArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    title?: boolean
    summary?: boolean
    status?: boolean
    templateId?: boolean
    authorId?: boolean
    markdown?: boolean
    metadata?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "summary" | "status" | "templateId" | "authorId" | "markdown" | "metadata" | "version" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Report$templateArgs<ExtArgs>
    materials?: boolean | Report$materialsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Report$templateArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | Report$templateArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      template: Prisma.$ReportTemplatePayload<ExtArgs> | null
      materials: Prisma.$ReportMaterialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      summary: string | null
      status: $Enums.ReportStatus
      templateId: string | null
      authorId: string | null
      markdown: string | null
      metadata: Prisma.JsonValue | null
      version: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends Report$templateArgs<ExtArgs> = {}>(args?: Subset<T, Report$templateArgs<ExtArgs>>): Prisma__ReportTemplateClient<$Result.GetResult<Prisma.$ReportTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    materials<T extends Report$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Report$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly title: FieldRef<"Report", 'String'>
    readonly summary: FieldRef<"Report", 'String'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly templateId: FieldRef<"Report", 'String'>
    readonly authorId: FieldRef<"Report", 'String'>
    readonly markdown: FieldRef<"Report", 'String'>
    readonly metadata: FieldRef<"Report", 'Json'>
    readonly version: FieldRef<"Report", 'Int'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.template
   */
  export type Report$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportTemplate
     */
    select?: ReportTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportTemplate
     */
    omit?: ReportTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportTemplateInclude<ExtArgs> | null
    where?: ReportTemplateWhereInput
  }

  /**
   * Report.materials
   */
  export type Report$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    where?: ReportMaterialWhereInput
    orderBy?: ReportMaterialOrderByWithRelationInput | ReportMaterialOrderByWithRelationInput[]
    cursor?: ReportMaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportMaterialScalarFieldEnum | ReportMaterialScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportMaterial
   */

  export type AggregateReportMaterial = {
    _count: ReportMaterialCountAggregateOutputType | null
    _min: ReportMaterialMinAggregateOutputType | null
    _max: ReportMaterialMaxAggregateOutputType | null
  }

  export type ReportMaterialMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    sourceType: $Enums.MaterialSource | null
    sourceId: string | null
    title: string | null
    snippet: string | null
    createdAt: Date | null
  }

  export type ReportMaterialMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    sourceType: $Enums.MaterialSource | null
    sourceId: string | null
    title: string | null
    snippet: string | null
    createdAt: Date | null
  }

  export type ReportMaterialCountAggregateOutputType = {
    id: number
    reportId: number
    sourceType: number
    sourceId: number
    title: number
    snippet: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type ReportMaterialMinAggregateInputType = {
    id?: true
    reportId?: true
    sourceType?: true
    sourceId?: true
    title?: true
    snippet?: true
    createdAt?: true
  }

  export type ReportMaterialMaxAggregateInputType = {
    id?: true
    reportId?: true
    sourceType?: true
    sourceId?: true
    title?: true
    snippet?: true
    createdAt?: true
  }

  export type ReportMaterialCountAggregateInputType = {
    id?: true
    reportId?: true
    sourceType?: true
    sourceId?: true
    title?: true
    snippet?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type ReportMaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportMaterial to aggregate.
     */
    where?: ReportMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportMaterials to fetch.
     */
    orderBy?: ReportMaterialOrderByWithRelationInput | ReportMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportMaterials
    **/
    _count?: true | ReportMaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaterialMaxAggregateInputType
  }

  export type GetReportMaterialAggregateType<T extends ReportMaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateReportMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportMaterial[P]>
      : GetScalarType<T[P], AggregateReportMaterial[P]>
  }




  export type ReportMaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportMaterialWhereInput
    orderBy?: ReportMaterialOrderByWithAggregationInput | ReportMaterialOrderByWithAggregationInput[]
    by: ReportMaterialScalarFieldEnum[] | ReportMaterialScalarFieldEnum
    having?: ReportMaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportMaterialCountAggregateInputType | true
    _min?: ReportMaterialMinAggregateInputType
    _max?: ReportMaterialMaxAggregateInputType
  }

  export type ReportMaterialGroupByOutputType = {
    id: string
    reportId: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title: string | null
    snippet: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: ReportMaterialCountAggregateOutputType | null
    _min: ReportMaterialMinAggregateOutputType | null
    _max: ReportMaterialMaxAggregateOutputType | null
  }

  type GetReportMaterialGroupByPayload<T extends ReportMaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportMaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportMaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportMaterialGroupByOutputType[P]>
            : GetScalarType<T[P], ReportMaterialGroupByOutputType[P]>
        }
      >
    >


  export type ReportMaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    title?: boolean
    snippet?: boolean
    metadata?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportMaterial"]>

  export type ReportMaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    title?: boolean
    snippet?: boolean
    metadata?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportMaterial"]>

  export type ReportMaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    title?: boolean
    snippet?: boolean
    metadata?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportMaterial"]>

  export type ReportMaterialSelectScalar = {
    id?: boolean
    reportId?: boolean
    sourceType?: boolean
    sourceId?: boolean
    title?: boolean
    snippet?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type ReportMaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportId" | "sourceType" | "sourceId" | "title" | "snippet" | "metadata" | "createdAt", ExtArgs["result"]["reportMaterial"]>
  export type ReportMaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportMaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportMaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $ReportMaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportMaterial"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      sourceType: $Enums.MaterialSource
      sourceId: string
      title: string | null
      snippet: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["reportMaterial"]>
    composites: {}
  }

  type ReportMaterialGetPayload<S extends boolean | null | undefined | ReportMaterialDefaultArgs> = $Result.GetResult<Prisma.$ReportMaterialPayload, S>

  type ReportMaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportMaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportMaterialCountAggregateInputType | true
    }

  export interface ReportMaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportMaterial'], meta: { name: 'ReportMaterial' } }
    /**
     * Find zero or one ReportMaterial that matches the filter.
     * @param {ReportMaterialFindUniqueArgs} args - Arguments to find a ReportMaterial
     * @example
     * // Get one ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportMaterialFindUniqueArgs>(args: SelectSubset<T, ReportMaterialFindUniqueArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportMaterial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportMaterialFindUniqueOrThrowArgs} args - Arguments to find a ReportMaterial
     * @example
     * // Get one ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportMaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportMaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportMaterial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialFindFirstArgs} args - Arguments to find a ReportMaterial
     * @example
     * // Get one ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportMaterialFindFirstArgs>(args?: SelectSubset<T, ReportMaterialFindFirstArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportMaterial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialFindFirstOrThrowArgs} args - Arguments to find a ReportMaterial
     * @example
     * // Get one ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportMaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportMaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportMaterials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportMaterials
     * const reportMaterials = await prisma.reportMaterial.findMany()
     * 
     * // Get first 10 ReportMaterials
     * const reportMaterials = await prisma.reportMaterial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportMaterialWithIdOnly = await prisma.reportMaterial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportMaterialFindManyArgs>(args?: SelectSubset<T, ReportMaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportMaterial.
     * @param {ReportMaterialCreateArgs} args - Arguments to create a ReportMaterial.
     * @example
     * // Create one ReportMaterial
     * const ReportMaterial = await prisma.reportMaterial.create({
     *   data: {
     *     // ... data to create a ReportMaterial
     *   }
     * })
     * 
     */
    create<T extends ReportMaterialCreateArgs>(args: SelectSubset<T, ReportMaterialCreateArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportMaterials.
     * @param {ReportMaterialCreateManyArgs} args - Arguments to create many ReportMaterials.
     * @example
     * // Create many ReportMaterials
     * const reportMaterial = await prisma.reportMaterial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportMaterialCreateManyArgs>(args?: SelectSubset<T, ReportMaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportMaterials and returns the data saved in the database.
     * @param {ReportMaterialCreateManyAndReturnArgs} args - Arguments to create many ReportMaterials.
     * @example
     * // Create many ReportMaterials
     * const reportMaterial = await prisma.reportMaterial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportMaterials and only return the `id`
     * const reportMaterialWithIdOnly = await prisma.reportMaterial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportMaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportMaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportMaterial.
     * @param {ReportMaterialDeleteArgs} args - Arguments to delete one ReportMaterial.
     * @example
     * // Delete one ReportMaterial
     * const ReportMaterial = await prisma.reportMaterial.delete({
     *   where: {
     *     // ... filter to delete one ReportMaterial
     *   }
     * })
     * 
     */
    delete<T extends ReportMaterialDeleteArgs>(args: SelectSubset<T, ReportMaterialDeleteArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportMaterial.
     * @param {ReportMaterialUpdateArgs} args - Arguments to update one ReportMaterial.
     * @example
     * // Update one ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportMaterialUpdateArgs>(args: SelectSubset<T, ReportMaterialUpdateArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportMaterials.
     * @param {ReportMaterialDeleteManyArgs} args - Arguments to filter ReportMaterials to delete.
     * @example
     * // Delete a few ReportMaterials
     * const { count } = await prisma.reportMaterial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportMaterialDeleteManyArgs>(args?: SelectSubset<T, ReportMaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportMaterials
     * const reportMaterial = await prisma.reportMaterial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportMaterialUpdateManyArgs>(args: SelectSubset<T, ReportMaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportMaterials and returns the data updated in the database.
     * @param {ReportMaterialUpdateManyAndReturnArgs} args - Arguments to update many ReportMaterials.
     * @example
     * // Update many ReportMaterials
     * const reportMaterial = await prisma.reportMaterial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportMaterials and only return the `id`
     * const reportMaterialWithIdOnly = await prisma.reportMaterial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportMaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportMaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportMaterial.
     * @param {ReportMaterialUpsertArgs} args - Arguments to update or create a ReportMaterial.
     * @example
     * // Update or create a ReportMaterial
     * const reportMaterial = await prisma.reportMaterial.upsert({
     *   create: {
     *     // ... data to create a ReportMaterial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportMaterial we want to update
     *   }
     * })
     */
    upsert<T extends ReportMaterialUpsertArgs>(args: SelectSubset<T, ReportMaterialUpsertArgs<ExtArgs>>): Prisma__ReportMaterialClient<$Result.GetResult<Prisma.$ReportMaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportMaterials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialCountArgs} args - Arguments to filter ReportMaterials to count.
     * @example
     * // Count the number of ReportMaterials
     * const count = await prisma.reportMaterial.count({
     *   where: {
     *     // ... the filter for the ReportMaterials we want to count
     *   }
     * })
    **/
    count<T extends ReportMaterialCountArgs>(
      args?: Subset<T, ReportMaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportMaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportMaterialAggregateArgs>(args: Subset<T, ReportMaterialAggregateArgs>): Prisma.PrismaPromise<GetReportMaterialAggregateType<T>>

    /**
     * Group by ReportMaterial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportMaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportMaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportMaterialGroupByArgs['orderBy'] }
        : { orderBy?: ReportMaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportMaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportMaterial model
   */
  readonly fields: ReportMaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportMaterial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportMaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportMaterial model
   */
  interface ReportMaterialFieldRefs {
    readonly id: FieldRef<"ReportMaterial", 'String'>
    readonly reportId: FieldRef<"ReportMaterial", 'String'>
    readonly sourceType: FieldRef<"ReportMaterial", 'MaterialSource'>
    readonly sourceId: FieldRef<"ReportMaterial", 'String'>
    readonly title: FieldRef<"ReportMaterial", 'String'>
    readonly snippet: FieldRef<"ReportMaterial", 'String'>
    readonly metadata: FieldRef<"ReportMaterial", 'Json'>
    readonly createdAt: FieldRef<"ReportMaterial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportMaterial findUnique
   */
  export type ReportMaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ReportMaterial to fetch.
     */
    where: ReportMaterialWhereUniqueInput
  }

  /**
   * ReportMaterial findUniqueOrThrow
   */
  export type ReportMaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ReportMaterial to fetch.
     */
    where: ReportMaterialWhereUniqueInput
  }

  /**
   * ReportMaterial findFirst
   */
  export type ReportMaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ReportMaterial to fetch.
     */
    where?: ReportMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportMaterials to fetch.
     */
    orderBy?: ReportMaterialOrderByWithRelationInput | ReportMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportMaterials.
     */
    cursor?: ReportMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportMaterials.
     */
    distinct?: ReportMaterialScalarFieldEnum | ReportMaterialScalarFieldEnum[]
  }

  /**
   * ReportMaterial findFirstOrThrow
   */
  export type ReportMaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ReportMaterial to fetch.
     */
    where?: ReportMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportMaterials to fetch.
     */
    orderBy?: ReportMaterialOrderByWithRelationInput | ReportMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportMaterials.
     */
    cursor?: ReportMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportMaterials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportMaterials.
     */
    distinct?: ReportMaterialScalarFieldEnum | ReportMaterialScalarFieldEnum[]
  }

  /**
   * ReportMaterial findMany
   */
  export type ReportMaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter, which ReportMaterials to fetch.
     */
    where?: ReportMaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportMaterials to fetch.
     */
    orderBy?: ReportMaterialOrderByWithRelationInput | ReportMaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportMaterials.
     */
    cursor?: ReportMaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportMaterials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportMaterials.
     */
    skip?: number
    distinct?: ReportMaterialScalarFieldEnum | ReportMaterialScalarFieldEnum[]
  }

  /**
   * ReportMaterial create
   */
  export type ReportMaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportMaterial.
     */
    data: XOR<ReportMaterialCreateInput, ReportMaterialUncheckedCreateInput>
  }

  /**
   * ReportMaterial createMany
   */
  export type ReportMaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportMaterials.
     */
    data: ReportMaterialCreateManyInput | ReportMaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportMaterial createManyAndReturn
   */
  export type ReportMaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * The data used to create many ReportMaterials.
     */
    data: ReportMaterialCreateManyInput | ReportMaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportMaterial update
   */
  export type ReportMaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportMaterial.
     */
    data: XOR<ReportMaterialUpdateInput, ReportMaterialUncheckedUpdateInput>
    /**
     * Choose, which ReportMaterial to update.
     */
    where: ReportMaterialWhereUniqueInput
  }

  /**
   * ReportMaterial updateMany
   */
  export type ReportMaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportMaterials.
     */
    data: XOR<ReportMaterialUpdateManyMutationInput, ReportMaterialUncheckedUpdateManyInput>
    /**
     * Filter which ReportMaterials to update
     */
    where?: ReportMaterialWhereInput
    /**
     * Limit how many ReportMaterials to update.
     */
    limit?: number
  }

  /**
   * ReportMaterial updateManyAndReturn
   */
  export type ReportMaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * The data used to update ReportMaterials.
     */
    data: XOR<ReportMaterialUpdateManyMutationInput, ReportMaterialUncheckedUpdateManyInput>
    /**
     * Filter which ReportMaterials to update
     */
    where?: ReportMaterialWhereInput
    /**
     * Limit how many ReportMaterials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportMaterial upsert
   */
  export type ReportMaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportMaterial to update in case it exists.
     */
    where: ReportMaterialWhereUniqueInput
    /**
     * In case the ReportMaterial found by the `where` argument doesn't exist, create a new ReportMaterial with this data.
     */
    create: XOR<ReportMaterialCreateInput, ReportMaterialUncheckedCreateInput>
    /**
     * In case the ReportMaterial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportMaterialUpdateInput, ReportMaterialUncheckedUpdateInput>
  }

  /**
   * ReportMaterial delete
   */
  export type ReportMaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
    /**
     * Filter which ReportMaterial to delete.
     */
    where: ReportMaterialWhereUniqueInput
  }

  /**
   * ReportMaterial deleteMany
   */
  export type ReportMaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportMaterials to delete
     */
    where?: ReportMaterialWhereInput
    /**
     * Limit how many ReportMaterials to delete.
     */
    limit?: number
  }

  /**
   * ReportMaterial without action
   */
  export type ReportMaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportMaterial
     */
    select?: ReportMaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportMaterial
     */
    omit?: ReportMaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportMaterialInclude<ExtArgs> | null
  }


  /**
   * Model Knowledge
   */

  export type AggregateKnowledge = {
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  export type KnowledgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledge to aggregate.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Knowledges
    **/
    _count?: true | KnowledgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeMaxAggregateInputType
  }

  export type GetKnowledgeAggregateType<T extends KnowledgeAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledge[P]>
      : GetScalarType<T[P], AggregateKnowledge[P]>
  }




  export type KnowledgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeWhereInput
    orderBy?: KnowledgeOrderByWithAggregationInput | KnowledgeOrderByWithAggregationInput[]
    by: KnowledgeScalarFieldEnum[] | KnowledgeScalarFieldEnum
    having?: KnowledgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeCountAggregateInputType | true
    _min?: KnowledgeMinAggregateInputType
    _max?: KnowledgeMaxAggregateInputType
  }

  export type KnowledgeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeCountAggregateOutputType | null
    _min: KnowledgeMinAggregateOutputType | null
    _max: KnowledgeMaxAggregateOutputType | null
  }

  type GetKnowledgeGroupByPayload<T extends KnowledgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    files?: boolean | Knowledge$filesArgs<ExtArgs>
    knowledgeChunks?: boolean | Knowledge$knowledgeChunksArgs<ExtArgs>
    _count?: boolean | KnowledgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledge"]>

  export type KnowledgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledge"]>

  export type KnowledgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledge"]>

  export type KnowledgeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledge"]>
  export type KnowledgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | Knowledge$filesArgs<ExtArgs>
    knowledgeChunks?: boolean | Knowledge$knowledgeChunksArgs<ExtArgs>
    _count?: boolean | KnowledgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type KnowledgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $KnowledgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Knowledge"
    objects: {
      files: Prisma.$KnowledgeFilePayload<ExtArgs>[]
      knowledgeChunks: Prisma.$KnowledgeChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledge"]>
    composites: {}
  }

  type KnowledgeGetPayload<S extends boolean | null | undefined | KnowledgeDefaultArgs> = $Result.GetResult<Prisma.$KnowledgePayload, S>

  type KnowledgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeCountAggregateInputType | true
    }

  export interface KnowledgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Knowledge'], meta: { name: 'Knowledge' } }
    /**
     * Find zero or one Knowledge that matches the filter.
     * @param {KnowledgeFindUniqueArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeFindUniqueArgs>(args: SelectSubset<T, KnowledgeFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Knowledge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeFindUniqueOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Knowledge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeFindFirstArgs>(args?: SelectSubset<T, KnowledgeFindFirstArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Knowledge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindFirstOrThrowArgs} args - Arguments to find a Knowledge
     * @example
     * // Get one Knowledge
     * const knowledge = await prisma.knowledge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Knowledges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Knowledges
     * const knowledges = await prisma.knowledge.findMany()
     * 
     * // Get first 10 Knowledges
     * const knowledges = await prisma.knowledge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeWithIdOnly = await prisma.knowledge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeFindManyArgs>(args?: SelectSubset<T, KnowledgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Knowledge.
     * @param {KnowledgeCreateArgs} args - Arguments to create a Knowledge.
     * @example
     * // Create one Knowledge
     * const Knowledge = await prisma.knowledge.create({
     *   data: {
     *     // ... data to create a Knowledge
     *   }
     * })
     * 
     */
    create<T extends KnowledgeCreateArgs>(args: SelectSubset<T, KnowledgeCreateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Knowledges.
     * @param {KnowledgeCreateManyArgs} args - Arguments to create many Knowledges.
     * @example
     * // Create many Knowledges
     * const knowledge = await prisma.knowledge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeCreateManyArgs>(args?: SelectSubset<T, KnowledgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Knowledges and returns the data saved in the database.
     * @param {KnowledgeCreateManyAndReturnArgs} args - Arguments to create many Knowledges.
     * @example
     * // Create many Knowledges
     * const knowledge = await prisma.knowledge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Knowledges and only return the `id`
     * const knowledgeWithIdOnly = await prisma.knowledge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Knowledge.
     * @param {KnowledgeDeleteArgs} args - Arguments to delete one Knowledge.
     * @example
     * // Delete one Knowledge
     * const Knowledge = await prisma.knowledge.delete({
     *   where: {
     *     // ... filter to delete one Knowledge
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeDeleteArgs>(args: SelectSubset<T, KnowledgeDeleteArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Knowledge.
     * @param {KnowledgeUpdateArgs} args - Arguments to update one Knowledge.
     * @example
     * // Update one Knowledge
     * const knowledge = await prisma.knowledge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeUpdateArgs>(args: SelectSubset<T, KnowledgeUpdateArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Knowledges.
     * @param {KnowledgeDeleteManyArgs} args - Arguments to filter Knowledges to delete.
     * @example
     * // Delete a few Knowledges
     * const { count } = await prisma.knowledge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeDeleteManyArgs>(args?: SelectSubset<T, KnowledgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Knowledges
     * const knowledge = await prisma.knowledge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeUpdateManyArgs>(args: SelectSubset<T, KnowledgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Knowledges and returns the data updated in the database.
     * @param {KnowledgeUpdateManyAndReturnArgs} args - Arguments to update many Knowledges.
     * @example
     * // Update many Knowledges
     * const knowledge = await prisma.knowledge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Knowledges and only return the `id`
     * const knowledgeWithIdOnly = await prisma.knowledge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Knowledge.
     * @param {KnowledgeUpsertArgs} args - Arguments to update or create a Knowledge.
     * @example
     * // Update or create a Knowledge
     * const knowledge = await prisma.knowledge.upsert({
     *   create: {
     *     // ... data to create a Knowledge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Knowledge we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeUpsertArgs>(args: SelectSubset<T, KnowledgeUpsertArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Knowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeCountArgs} args - Arguments to filter Knowledges to count.
     * @example
     * // Count the number of Knowledges
     * const count = await prisma.knowledge.count({
     *   where: {
     *     // ... the filter for the Knowledges we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeCountArgs>(
      args?: Subset<T, KnowledgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeAggregateArgs>(args: Subset<T, KnowledgeAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeAggregateType<T>>

    /**
     * Group by Knowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Knowledge model
   */
  readonly fields: KnowledgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Knowledge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    files<T extends Knowledge$filesArgs<ExtArgs> = {}>(args?: Subset<T, Knowledge$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    knowledgeChunks<T extends Knowledge$knowledgeChunksArgs<ExtArgs> = {}>(args?: Subset<T, Knowledge$knowledgeChunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Knowledge model
   */
  interface KnowledgeFieldRefs {
    readonly id: FieldRef<"Knowledge", 'String'>
    readonly name: FieldRef<"Knowledge", 'String'>
    readonly description: FieldRef<"Knowledge", 'String'>
    readonly ownerId: FieldRef<"Knowledge", 'String'>
    readonly createdAt: FieldRef<"Knowledge", 'DateTime'>
    readonly updatedAt: FieldRef<"Knowledge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Knowledge findUnique
   */
  export type KnowledgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findUniqueOrThrow
   */
  export type KnowledgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge findFirst
   */
  export type KnowledgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findFirstOrThrow
   */
  export type KnowledgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledge to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Knowledges.
     */
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge findMany
   */
  export type KnowledgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which Knowledges to fetch.
     */
    where?: KnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Knowledges to fetch.
     */
    orderBy?: KnowledgeOrderByWithRelationInput | KnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Knowledges.
     */
    cursor?: KnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Knowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Knowledges.
     */
    skip?: number
    distinct?: KnowledgeScalarFieldEnum | KnowledgeScalarFieldEnum[]
  }

  /**
   * Knowledge create
   */
  export type KnowledgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Knowledge.
     */
    data: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
  }

  /**
   * Knowledge createMany
   */
  export type KnowledgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Knowledges.
     */
    data: KnowledgeCreateManyInput | KnowledgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Knowledge createManyAndReturn
   */
  export type KnowledgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * The data used to create many Knowledges.
     */
    data: KnowledgeCreateManyInput | KnowledgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Knowledge update
   */
  export type KnowledgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Knowledge.
     */
    data: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
    /**
     * Choose, which Knowledge to update.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge updateMany
   */
  export type KnowledgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Knowledges.
     */
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which Knowledges to update
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to update.
     */
    limit?: number
  }

  /**
   * Knowledge updateManyAndReturn
   */
  export type KnowledgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * The data used to update Knowledges.
     */
    data: XOR<KnowledgeUpdateManyMutationInput, KnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which Knowledges to update
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to update.
     */
    limit?: number
  }

  /**
   * Knowledge upsert
   */
  export type KnowledgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Knowledge to update in case it exists.
     */
    where: KnowledgeWhereUniqueInput
    /**
     * In case the Knowledge found by the `where` argument doesn't exist, create a new Knowledge with this data.
     */
    create: XOR<KnowledgeCreateInput, KnowledgeUncheckedCreateInput>
    /**
     * In case the Knowledge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeUpdateInput, KnowledgeUncheckedUpdateInput>
  }

  /**
   * Knowledge delete
   */
  export type KnowledgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
    /**
     * Filter which Knowledge to delete.
     */
    where: KnowledgeWhereUniqueInput
  }

  /**
   * Knowledge deleteMany
   */
  export type KnowledgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Knowledges to delete
     */
    where?: KnowledgeWhereInput
    /**
     * Limit how many Knowledges to delete.
     */
    limit?: number
  }

  /**
   * Knowledge.files
   */
  export type Knowledge$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    where?: KnowledgeFileWhereInput
    orderBy?: KnowledgeFileOrderByWithRelationInput | KnowledgeFileOrderByWithRelationInput[]
    cursor?: KnowledgeFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeFileScalarFieldEnum | KnowledgeFileScalarFieldEnum[]
  }

  /**
   * Knowledge.knowledgeChunks
   */
  export type Knowledge$knowledgeChunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    where?: KnowledgeChunkWhereInput
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    cursor?: KnowledgeChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * Knowledge without action
   */
  export type KnowledgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Knowledge
     */
    select?: KnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Knowledge
     */
    omit?: KnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeFile
   */

  export type AggregateKnowledgeFile = {
    _count: KnowledgeFileCountAggregateOutputType | null
    _avg: KnowledgeFileAvgAggregateOutputType | null
    _sum: KnowledgeFileSumAggregateOutputType | null
    _min: KnowledgeFileMinAggregateOutputType | null
    _max: KnowledgeFileMaxAggregateOutputType | null
  }

  export type KnowledgeFileAvgAggregateOutputType = {
    size: number | null
  }

  export type KnowledgeFileSumAggregateOutputType = {
    size: number | null
  }

  export type KnowledgeFileMinAggregateOutputType = {
    id: string | null
    knowledgeId: string | null
    name: string | null
    mimeType: string | null
    size: number | null
    storageKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeFileMaxAggregateOutputType = {
    id: string | null
    knowledgeId: string | null
    name: string | null
    mimeType: string | null
    size: number | null
    storageKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeFileCountAggregateOutputType = {
    id: number
    knowledgeId: number
    name: number
    mimeType: number
    size: number
    storageKey: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeFileAvgAggregateInputType = {
    size?: true
  }

  export type KnowledgeFileSumAggregateInputType = {
    size?: true
  }

  export type KnowledgeFileMinAggregateInputType = {
    id?: true
    knowledgeId?: true
    name?: true
    mimeType?: true
    size?: true
    storageKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeFileMaxAggregateInputType = {
    id?: true
    knowledgeId?: true
    name?: true
    mimeType?: true
    size?: true
    storageKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeFileCountAggregateInputType = {
    id?: true
    knowledgeId?: true
    name?: true
    mimeType?: true
    size?: true
    storageKey?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeFile to aggregate.
     */
    where?: KnowledgeFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeFiles to fetch.
     */
    orderBy?: KnowledgeFileOrderByWithRelationInput | KnowledgeFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeFiles
    **/
    _count?: true | KnowledgeFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeFileMaxAggregateInputType
  }

  export type GetKnowledgeFileAggregateType<T extends KnowledgeFileAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeFile[P]>
      : GetScalarType<T[P], AggregateKnowledgeFile[P]>
  }




  export type KnowledgeFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeFileWhereInput
    orderBy?: KnowledgeFileOrderByWithAggregationInput | KnowledgeFileOrderByWithAggregationInput[]
    by: KnowledgeFileScalarFieldEnum[] | KnowledgeFileScalarFieldEnum
    having?: KnowledgeFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeFileCountAggregateInputType | true
    _avg?: KnowledgeFileAvgAggregateInputType
    _sum?: KnowledgeFileSumAggregateInputType
    _min?: KnowledgeFileMinAggregateInputType
    _max?: KnowledgeFileMaxAggregateInputType
  }

  export type KnowledgeFileGroupByOutputType = {
    id: string
    knowledgeId: string
    name: string
    mimeType: string | null
    size: number | null
    storageKey: string | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeFileCountAggregateOutputType | null
    _avg: KnowledgeFileAvgAggregateOutputType | null
    _sum: KnowledgeFileSumAggregateOutputType | null
    _min: KnowledgeFileMinAggregateOutputType | null
    _max: KnowledgeFileMaxAggregateOutputType | null
  }

  type GetKnowledgeFileGroupByPayload<T extends KnowledgeFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeFileGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeFileGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    storageKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    chunks?: boolean | KnowledgeFile$chunksArgs<ExtArgs>
    _count?: boolean | KnowledgeFileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeFile"]>

  export type KnowledgeFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    storageKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeFile"]>

  export type KnowledgeFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    storageKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeFile"]>

  export type KnowledgeFileSelectScalar = {
    id?: boolean
    knowledgeId?: boolean
    name?: boolean
    mimeType?: boolean
    size?: boolean
    storageKey?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "knowledgeId" | "name" | "mimeType" | "size" | "storageKey" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeFile"]>
  export type KnowledgeFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    chunks?: boolean | KnowledgeFile$chunksArgs<ExtArgs>
    _count?: boolean | KnowledgeFileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KnowledgeFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
  }
  export type KnowledgeFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
  }

  export type $KnowledgeFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeFile"
    objects: {
      knowledge: Prisma.$KnowledgePayload<ExtArgs>
      chunks: Prisma.$KnowledgeChunkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      knowledgeId: string
      name: string
      mimeType: string | null
      size: number | null
      storageKey: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeFile"]>
    composites: {}
  }

  type KnowledgeFileGetPayload<S extends boolean | null | undefined | KnowledgeFileDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeFilePayload, S>

  type KnowledgeFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeFileCountAggregateInputType | true
    }

  export interface KnowledgeFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeFile'], meta: { name: 'KnowledgeFile' } }
    /**
     * Find zero or one KnowledgeFile that matches the filter.
     * @param {KnowledgeFileFindUniqueArgs} args - Arguments to find a KnowledgeFile
     * @example
     * // Get one KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeFileFindUniqueArgs>(args: SelectSubset<T, KnowledgeFileFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeFileFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeFile
     * @example
     * // Get one KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeFileFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileFindFirstArgs} args - Arguments to find a KnowledgeFile
     * @example
     * // Get one KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeFileFindFirstArgs>(args?: SelectSubset<T, KnowledgeFileFindFirstArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileFindFirstOrThrowArgs} args - Arguments to find a KnowledgeFile
     * @example
     * // Get one KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeFileFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeFiles
     * const knowledgeFiles = await prisma.knowledgeFile.findMany()
     * 
     * // Get first 10 KnowledgeFiles
     * const knowledgeFiles = await prisma.knowledgeFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeFileWithIdOnly = await prisma.knowledgeFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeFileFindManyArgs>(args?: SelectSubset<T, KnowledgeFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeFile.
     * @param {KnowledgeFileCreateArgs} args - Arguments to create a KnowledgeFile.
     * @example
     * // Create one KnowledgeFile
     * const KnowledgeFile = await prisma.knowledgeFile.create({
     *   data: {
     *     // ... data to create a KnowledgeFile
     *   }
     * })
     * 
     */
    create<T extends KnowledgeFileCreateArgs>(args: SelectSubset<T, KnowledgeFileCreateArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeFiles.
     * @param {KnowledgeFileCreateManyArgs} args - Arguments to create many KnowledgeFiles.
     * @example
     * // Create many KnowledgeFiles
     * const knowledgeFile = await prisma.knowledgeFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeFileCreateManyArgs>(args?: SelectSubset<T, KnowledgeFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeFiles and returns the data saved in the database.
     * @param {KnowledgeFileCreateManyAndReturnArgs} args - Arguments to create many KnowledgeFiles.
     * @example
     * // Create many KnowledgeFiles
     * const knowledgeFile = await prisma.knowledgeFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeFiles and only return the `id`
     * const knowledgeFileWithIdOnly = await prisma.knowledgeFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeFileCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeFile.
     * @param {KnowledgeFileDeleteArgs} args - Arguments to delete one KnowledgeFile.
     * @example
     * // Delete one KnowledgeFile
     * const KnowledgeFile = await prisma.knowledgeFile.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeFile
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeFileDeleteArgs>(args: SelectSubset<T, KnowledgeFileDeleteArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeFile.
     * @param {KnowledgeFileUpdateArgs} args - Arguments to update one KnowledgeFile.
     * @example
     * // Update one KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeFileUpdateArgs>(args: SelectSubset<T, KnowledgeFileUpdateArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeFiles.
     * @param {KnowledgeFileDeleteManyArgs} args - Arguments to filter KnowledgeFiles to delete.
     * @example
     * // Delete a few KnowledgeFiles
     * const { count } = await prisma.knowledgeFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeFileDeleteManyArgs>(args?: SelectSubset<T, KnowledgeFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeFiles
     * const knowledgeFile = await prisma.knowledgeFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeFileUpdateManyArgs>(args: SelectSubset<T, KnowledgeFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeFiles and returns the data updated in the database.
     * @param {KnowledgeFileUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeFiles.
     * @example
     * // Update many KnowledgeFiles
     * const knowledgeFile = await prisma.knowledgeFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeFiles and only return the `id`
     * const knowledgeFileWithIdOnly = await prisma.knowledgeFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeFileUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeFile.
     * @param {KnowledgeFileUpsertArgs} args - Arguments to update or create a KnowledgeFile.
     * @example
     * // Update or create a KnowledgeFile
     * const knowledgeFile = await prisma.knowledgeFile.upsert({
     *   create: {
     *     // ... data to create a KnowledgeFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeFile we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeFileUpsertArgs>(args: SelectSubset<T, KnowledgeFileUpsertArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileCountArgs} args - Arguments to filter KnowledgeFiles to count.
     * @example
     * // Count the number of KnowledgeFiles
     * const count = await prisma.knowledgeFile.count({
     *   where: {
     *     // ... the filter for the KnowledgeFiles we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeFileCountArgs>(
      args?: Subset<T, KnowledgeFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeFileAggregateArgs>(args: Subset<T, KnowledgeFileAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeFileAggregateType<T>>

    /**
     * Group by KnowledgeFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeFileGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeFile model
   */
  readonly fields: KnowledgeFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledge<T extends KnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeDefaultArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    chunks<T extends KnowledgeFile$chunksArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeFile$chunksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeFile model
   */
  interface KnowledgeFileFieldRefs {
    readonly id: FieldRef<"KnowledgeFile", 'String'>
    readonly knowledgeId: FieldRef<"KnowledgeFile", 'String'>
    readonly name: FieldRef<"KnowledgeFile", 'String'>
    readonly mimeType: FieldRef<"KnowledgeFile", 'String'>
    readonly size: FieldRef<"KnowledgeFile", 'Int'>
    readonly storageKey: FieldRef<"KnowledgeFile", 'String'>
    readonly createdAt: FieldRef<"KnowledgeFile", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeFile findUnique
   */
  export type KnowledgeFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeFile to fetch.
     */
    where: KnowledgeFileWhereUniqueInput
  }

  /**
   * KnowledgeFile findUniqueOrThrow
   */
  export type KnowledgeFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeFile to fetch.
     */
    where: KnowledgeFileWhereUniqueInput
  }

  /**
   * KnowledgeFile findFirst
   */
  export type KnowledgeFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeFile to fetch.
     */
    where?: KnowledgeFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeFiles to fetch.
     */
    orderBy?: KnowledgeFileOrderByWithRelationInput | KnowledgeFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeFiles.
     */
    cursor?: KnowledgeFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeFiles.
     */
    distinct?: KnowledgeFileScalarFieldEnum | KnowledgeFileScalarFieldEnum[]
  }

  /**
   * KnowledgeFile findFirstOrThrow
   */
  export type KnowledgeFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeFile to fetch.
     */
    where?: KnowledgeFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeFiles to fetch.
     */
    orderBy?: KnowledgeFileOrderByWithRelationInput | KnowledgeFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeFiles.
     */
    cursor?: KnowledgeFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeFiles.
     */
    distinct?: KnowledgeFileScalarFieldEnum | KnowledgeFileScalarFieldEnum[]
  }

  /**
   * KnowledgeFile findMany
   */
  export type KnowledgeFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeFiles to fetch.
     */
    where?: KnowledgeFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeFiles to fetch.
     */
    orderBy?: KnowledgeFileOrderByWithRelationInput | KnowledgeFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeFiles.
     */
    cursor?: KnowledgeFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeFiles.
     */
    skip?: number
    distinct?: KnowledgeFileScalarFieldEnum | KnowledgeFileScalarFieldEnum[]
  }

  /**
   * KnowledgeFile create
   */
  export type KnowledgeFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeFile.
     */
    data: XOR<KnowledgeFileCreateInput, KnowledgeFileUncheckedCreateInput>
  }

  /**
   * KnowledgeFile createMany
   */
  export type KnowledgeFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeFiles.
     */
    data: KnowledgeFileCreateManyInput | KnowledgeFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeFile createManyAndReturn
   */
  export type KnowledgeFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeFiles.
     */
    data: KnowledgeFileCreateManyInput | KnowledgeFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeFile update
   */
  export type KnowledgeFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeFile.
     */
    data: XOR<KnowledgeFileUpdateInput, KnowledgeFileUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeFile to update.
     */
    where: KnowledgeFileWhereUniqueInput
  }

  /**
   * KnowledgeFile updateMany
   */
  export type KnowledgeFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeFiles.
     */
    data: XOR<KnowledgeFileUpdateManyMutationInput, KnowledgeFileUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeFiles to update
     */
    where?: KnowledgeFileWhereInput
    /**
     * Limit how many KnowledgeFiles to update.
     */
    limit?: number
  }

  /**
   * KnowledgeFile updateManyAndReturn
   */
  export type KnowledgeFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeFiles.
     */
    data: XOR<KnowledgeFileUpdateManyMutationInput, KnowledgeFileUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeFiles to update
     */
    where?: KnowledgeFileWhereInput
    /**
     * Limit how many KnowledgeFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeFile upsert
   */
  export type KnowledgeFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeFile to update in case it exists.
     */
    where: KnowledgeFileWhereUniqueInput
    /**
     * In case the KnowledgeFile found by the `where` argument doesn't exist, create a new KnowledgeFile with this data.
     */
    create: XOR<KnowledgeFileCreateInput, KnowledgeFileUncheckedCreateInput>
    /**
     * In case the KnowledgeFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeFileUpdateInput, KnowledgeFileUncheckedUpdateInput>
  }

  /**
   * KnowledgeFile delete
   */
  export type KnowledgeFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeFile to delete.
     */
    where: KnowledgeFileWhereUniqueInput
  }

  /**
   * KnowledgeFile deleteMany
   */
  export type KnowledgeFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeFiles to delete
     */
    where?: KnowledgeFileWhereInput
    /**
     * Limit how many KnowledgeFiles to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeFile.chunks
   */
  export type KnowledgeFile$chunksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    where?: KnowledgeChunkWhereInput
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    cursor?: KnowledgeChunkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeFile without action
   */
  export type KnowledgeFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
  }


  /**
   * Model KnowledgeChunk
   */

  export type AggregateKnowledgeChunk = {
    _count: KnowledgeChunkCountAggregateOutputType | null
    _avg: KnowledgeChunkAvgAggregateOutputType | null
    _sum: KnowledgeChunkSumAggregateOutputType | null
    _min: KnowledgeChunkMinAggregateOutputType | null
    _max: KnowledgeChunkMaxAggregateOutputType | null
  }

  export type KnowledgeChunkAvgAggregateOutputType = {
    chunkIndex: number | null
  }

  export type KnowledgeChunkSumAggregateOutputType = {
    chunkIndex: number | null
  }

  export type KnowledgeChunkMinAggregateOutputType = {
    id: string | null
    knowledgeId: string | null
    fileId: string | null
    content: string | null
    embedding: Bytes | null
    chunkIndex: number | null
    createdAt: Date | null
  }

  export type KnowledgeChunkMaxAggregateOutputType = {
    id: string | null
    knowledgeId: string | null
    fileId: string | null
    content: string | null
    embedding: Bytes | null
    chunkIndex: number | null
    createdAt: Date | null
  }

  export type KnowledgeChunkCountAggregateOutputType = {
    id: number
    knowledgeId: number
    fileId: number
    content: number
    metadata: number
    embedding: number
    chunkIndex: number
    createdAt: number
    _all: number
  }


  export type KnowledgeChunkAvgAggregateInputType = {
    chunkIndex?: true
  }

  export type KnowledgeChunkSumAggregateInputType = {
    chunkIndex?: true
  }

  export type KnowledgeChunkMinAggregateInputType = {
    id?: true
    knowledgeId?: true
    fileId?: true
    content?: true
    embedding?: true
    chunkIndex?: true
    createdAt?: true
  }

  export type KnowledgeChunkMaxAggregateInputType = {
    id?: true
    knowledgeId?: true
    fileId?: true
    content?: true
    embedding?: true
    chunkIndex?: true
    createdAt?: true
  }

  export type KnowledgeChunkCountAggregateInputType = {
    id?: true
    knowledgeId?: true
    fileId?: true
    content?: true
    metadata?: true
    embedding?: true
    chunkIndex?: true
    createdAt?: true
    _all?: true
  }

  export type KnowledgeChunkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeChunk to aggregate.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeChunks
    **/
    _count?: true | KnowledgeChunkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeChunkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeChunkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeChunkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeChunkMaxAggregateInputType
  }

  export type GetKnowledgeChunkAggregateType<T extends KnowledgeChunkAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeChunk]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeChunk[P]>
      : GetScalarType<T[P], AggregateKnowledgeChunk[P]>
  }




  export type KnowledgeChunkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeChunkWhereInput
    orderBy?: KnowledgeChunkOrderByWithAggregationInput | KnowledgeChunkOrderByWithAggregationInput[]
    by: KnowledgeChunkScalarFieldEnum[] | KnowledgeChunkScalarFieldEnum
    having?: KnowledgeChunkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeChunkCountAggregateInputType | true
    _avg?: KnowledgeChunkAvgAggregateInputType
    _sum?: KnowledgeChunkSumAggregateInputType
    _min?: KnowledgeChunkMinAggregateInputType
    _max?: KnowledgeChunkMaxAggregateInputType
  }

  export type KnowledgeChunkGroupByOutputType = {
    id: string
    knowledgeId: string
    fileId: string | null
    content: string
    metadata: JsonValue | null
    embedding: Bytes | null
    chunkIndex: number
    createdAt: Date
    _count: KnowledgeChunkCountAggregateOutputType | null
    _avg: KnowledgeChunkAvgAggregateOutputType | null
    _sum: KnowledgeChunkSumAggregateOutputType | null
    _min: KnowledgeChunkMinAggregateOutputType | null
    _max: KnowledgeChunkMaxAggregateOutputType | null
  }

  type GetKnowledgeChunkGroupByPayload<T extends KnowledgeChunkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeChunkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeChunkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeChunkGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeChunkGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeChunkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    fileId?: boolean
    content?: boolean
    metadata?: boolean
    embedding?: boolean
    chunkIndex?: boolean
    createdAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    fileId?: boolean
    content?: boolean
    metadata?: boolean
    embedding?: boolean
    chunkIndex?: boolean
    createdAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    knowledgeId?: boolean
    fileId?: boolean
    content?: boolean
    metadata?: boolean
    embedding?: boolean
    chunkIndex?: boolean
    createdAt?: boolean
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }, ExtArgs["result"]["knowledgeChunk"]>

  export type KnowledgeChunkSelectScalar = {
    id?: boolean
    knowledgeId?: boolean
    fileId?: boolean
    content?: boolean
    metadata?: boolean
    embedding?: boolean
    chunkIndex?: boolean
    createdAt?: boolean
  }

  export type KnowledgeChunkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "knowledgeId" | "fileId" | "content" | "metadata" | "embedding" | "chunkIndex" | "createdAt", ExtArgs["result"]["knowledgeChunk"]>
  export type KnowledgeChunkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }
  export type KnowledgeChunkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }
  export type KnowledgeChunkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    knowledge?: boolean | KnowledgeDefaultArgs<ExtArgs>
    file?: boolean | KnowledgeChunk$fileArgs<ExtArgs>
  }

  export type $KnowledgeChunkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeChunk"
    objects: {
      knowledge: Prisma.$KnowledgePayload<ExtArgs>
      file: Prisma.$KnowledgeFilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      knowledgeId: string
      fileId: string | null
      content: string
      metadata: Prisma.JsonValue | null
      embedding: Prisma.Bytes | null
      chunkIndex: number
      createdAt: Date
    }, ExtArgs["result"]["knowledgeChunk"]>
    composites: {}
  }

  type KnowledgeChunkGetPayload<S extends boolean | null | undefined | KnowledgeChunkDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeChunkPayload, S>

  type KnowledgeChunkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeChunkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeChunkCountAggregateInputType | true
    }

  export interface KnowledgeChunkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeChunk'], meta: { name: 'KnowledgeChunk' } }
    /**
     * Find zero or one KnowledgeChunk that matches the filter.
     * @param {KnowledgeChunkFindUniqueArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeChunkFindUniqueArgs>(args: SelectSubset<T, KnowledgeChunkFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeChunk that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeChunkFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeChunkFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeChunk that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindFirstArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeChunkFindFirstArgs>(args?: SelectSubset<T, KnowledgeChunkFindFirstArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeChunk that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindFirstOrThrowArgs} args - Arguments to find a KnowledgeChunk
     * @example
     * // Get one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeChunkFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeChunkFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeChunks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeChunks
     * const knowledgeChunks = await prisma.knowledgeChunk.findMany()
     * 
     * // Get first 10 KnowledgeChunks
     * const knowledgeChunks = await prisma.knowledgeChunk.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeChunkFindManyArgs>(args?: SelectSubset<T, KnowledgeChunkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeChunk.
     * @param {KnowledgeChunkCreateArgs} args - Arguments to create a KnowledgeChunk.
     * @example
     * // Create one KnowledgeChunk
     * const KnowledgeChunk = await prisma.knowledgeChunk.create({
     *   data: {
     *     // ... data to create a KnowledgeChunk
     *   }
     * })
     * 
     */
    create<T extends KnowledgeChunkCreateArgs>(args: SelectSubset<T, KnowledgeChunkCreateArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeChunks.
     * @param {KnowledgeChunkCreateManyArgs} args - Arguments to create many KnowledgeChunks.
     * @example
     * // Create many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeChunkCreateManyArgs>(args?: SelectSubset<T, KnowledgeChunkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeChunks and returns the data saved in the database.
     * @param {KnowledgeChunkCreateManyAndReturnArgs} args - Arguments to create many KnowledgeChunks.
     * @example
     * // Create many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeChunks and only return the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeChunkCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeChunkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeChunk.
     * @param {KnowledgeChunkDeleteArgs} args - Arguments to delete one KnowledgeChunk.
     * @example
     * // Delete one KnowledgeChunk
     * const KnowledgeChunk = await prisma.knowledgeChunk.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeChunk
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeChunkDeleteArgs>(args: SelectSubset<T, KnowledgeChunkDeleteArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeChunk.
     * @param {KnowledgeChunkUpdateArgs} args - Arguments to update one KnowledgeChunk.
     * @example
     * // Update one KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeChunkUpdateArgs>(args: SelectSubset<T, KnowledgeChunkUpdateArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeChunks.
     * @param {KnowledgeChunkDeleteManyArgs} args - Arguments to filter KnowledgeChunks to delete.
     * @example
     * // Delete a few KnowledgeChunks
     * const { count } = await prisma.knowledgeChunk.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeChunkDeleteManyArgs>(args?: SelectSubset<T, KnowledgeChunkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeChunkUpdateManyArgs>(args: SelectSubset<T, KnowledgeChunkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeChunks and returns the data updated in the database.
     * @param {KnowledgeChunkUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeChunks.
     * @example
     * // Update many KnowledgeChunks
     * const knowledgeChunk = await prisma.knowledgeChunk.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeChunks and only return the `id`
     * const knowledgeChunkWithIdOnly = await prisma.knowledgeChunk.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeChunkUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeChunk.
     * @param {KnowledgeChunkUpsertArgs} args - Arguments to update or create a KnowledgeChunk.
     * @example
     * // Update or create a KnowledgeChunk
     * const knowledgeChunk = await prisma.knowledgeChunk.upsert({
     *   create: {
     *     // ... data to create a KnowledgeChunk
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeChunk we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeChunkUpsertArgs>(args: SelectSubset<T, KnowledgeChunkUpsertArgs<ExtArgs>>): Prisma__KnowledgeChunkClient<$Result.GetResult<Prisma.$KnowledgeChunkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeChunks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkCountArgs} args - Arguments to filter KnowledgeChunks to count.
     * @example
     * // Count the number of KnowledgeChunks
     * const count = await prisma.knowledgeChunk.count({
     *   where: {
     *     // ... the filter for the KnowledgeChunks we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeChunkCountArgs>(
      args?: Subset<T, KnowledgeChunkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeChunkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeChunkAggregateArgs>(args: Subset<T, KnowledgeChunkAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeChunkAggregateType<T>>

    /**
     * Group by KnowledgeChunk.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeChunkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeChunkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeChunkGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeChunkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeChunkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeChunkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeChunk model
   */
  readonly fields: KnowledgeChunkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeChunk.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeChunkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    knowledge<T extends KnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeDefaultArgs<ExtArgs>>): Prisma__KnowledgeClient<$Result.GetResult<Prisma.$KnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends KnowledgeChunk$fileArgs<ExtArgs> = {}>(args?: Subset<T, KnowledgeChunk$fileArgs<ExtArgs>>): Prisma__KnowledgeFileClient<$Result.GetResult<Prisma.$KnowledgeFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeChunk model
   */
  interface KnowledgeChunkFieldRefs {
    readonly id: FieldRef<"KnowledgeChunk", 'String'>
    readonly knowledgeId: FieldRef<"KnowledgeChunk", 'String'>
    readonly fileId: FieldRef<"KnowledgeChunk", 'String'>
    readonly content: FieldRef<"KnowledgeChunk", 'String'>
    readonly metadata: FieldRef<"KnowledgeChunk", 'Json'>
    readonly embedding: FieldRef<"KnowledgeChunk", 'Bytes'>
    readonly chunkIndex: FieldRef<"KnowledgeChunk", 'Int'>
    readonly createdAt: FieldRef<"KnowledgeChunk", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeChunk findUnique
   */
  export type KnowledgeChunkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk findUniqueOrThrow
   */
  export type KnowledgeChunkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk findFirst
   */
  export type KnowledgeChunkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeChunks.
     */
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk findFirstOrThrow
   */
  export type KnowledgeChunkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunk to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeChunks.
     */
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk findMany
   */
  export type KnowledgeChunkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter, which KnowledgeChunks to fetch.
     */
    where?: KnowledgeChunkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeChunks to fetch.
     */
    orderBy?: KnowledgeChunkOrderByWithRelationInput | KnowledgeChunkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeChunks.
     */
    cursor?: KnowledgeChunkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeChunks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeChunks.
     */
    skip?: number
    distinct?: KnowledgeChunkScalarFieldEnum | KnowledgeChunkScalarFieldEnum[]
  }

  /**
   * KnowledgeChunk create
   */
  export type KnowledgeChunkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeChunk.
     */
    data: XOR<KnowledgeChunkCreateInput, KnowledgeChunkUncheckedCreateInput>
  }

  /**
   * KnowledgeChunk createMany
   */
  export type KnowledgeChunkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeChunks.
     */
    data: KnowledgeChunkCreateManyInput | KnowledgeChunkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KnowledgeChunk createManyAndReturn
   */
  export type KnowledgeChunkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeChunks.
     */
    data: KnowledgeChunkCreateManyInput | KnowledgeChunkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeChunk update
   */
  export type KnowledgeChunkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeChunk.
     */
    data: XOR<KnowledgeChunkUpdateInput, KnowledgeChunkUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeChunk to update.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk updateMany
   */
  export type KnowledgeChunkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeChunks.
     */
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeChunks to update
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to update.
     */
    limit?: number
  }

  /**
   * KnowledgeChunk updateManyAndReturn
   */
  export type KnowledgeChunkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeChunks.
     */
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeChunks to update
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KnowledgeChunk upsert
   */
  export type KnowledgeChunkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeChunk to update in case it exists.
     */
    where: KnowledgeChunkWhereUniqueInput
    /**
     * In case the KnowledgeChunk found by the `where` argument doesn't exist, create a new KnowledgeChunk with this data.
     */
    create: XOR<KnowledgeChunkCreateInput, KnowledgeChunkUncheckedCreateInput>
    /**
     * In case the KnowledgeChunk was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeChunkUpdateInput, KnowledgeChunkUncheckedUpdateInput>
  }

  /**
   * KnowledgeChunk delete
   */
  export type KnowledgeChunkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
    /**
     * Filter which KnowledgeChunk to delete.
     */
    where: KnowledgeChunkWhereUniqueInput
  }

  /**
   * KnowledgeChunk deleteMany
   */
  export type KnowledgeChunkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeChunks to delete
     */
    where?: KnowledgeChunkWhereInput
    /**
     * Limit how many KnowledgeChunks to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeChunk.file
   */
  export type KnowledgeChunk$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeFile
     */
    select?: KnowledgeFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeFile
     */
    omit?: KnowledgeFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeFileInclude<ExtArgs> | null
    where?: KnowledgeFileWhereInput
  }

  /**
   * KnowledgeChunk without action
   */
  export type KnowledgeChunkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeChunk
     */
    select?: KnowledgeChunkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeChunk
     */
    omit?: KnowledgeChunkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KnowledgeChunkInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const KeywordScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    lang: 'lang',
    categoryId: 'categoryId',
    includes: 'includes',
    excludes: 'excludes',
    enableAiExpand: 'enableAiExpand',
    synonyms: 'synonyms',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KeywordScalarFieldEnum = (typeof KeywordScalarFieldEnum)[keyof typeof KeywordScalarFieldEnum]


  export const ProxyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    url: 'url',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProxyScalarFieldEnum = (typeof ProxyScalarFieldEnum)[keyof typeof ProxyScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    name: 'name',
    kind: 'kind',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const SourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    active: 'active',
    rateLimit: 'rateLimit',
    lastFetchedAt: 'lastFetchedAt',
    lastStatus: 'lastStatus',
    proxyId: 'proxyId',
    credentialId: 'credentialId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SourceScalarFieldEnum = (typeof SourceScalarFieldEnum)[keyof typeof SourceScalarFieldEnum]


  export const WebSourceConfigScalarFieldEnum: {
    sourceId: 'sourceId',
    url: 'url',
    headers: 'headers',
    crawlerEngine: 'crawlerEngine',
    render: 'render',
    parseRules: 'parseRules',
    robotsRespect: 'robotsRespect',
    proxyId: 'proxyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WebSourceConfigScalarFieldEnum = (typeof WebSourceConfigScalarFieldEnum)[keyof typeof WebSourceConfigScalarFieldEnum]


  export const DarknetSourceConfigScalarFieldEnum: {
    sourceId: 'sourceId',
    url: 'url',
    headers: 'headers',
    crawlerEngine: 'crawlerEngine',
    proxyId: 'proxyId',
    render: 'render',
    parseRules: 'parseRules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DarknetSourceConfigScalarFieldEnum = (typeof DarknetSourceConfigScalarFieldEnum)[keyof typeof DarknetSourceConfigScalarFieldEnum]


  export const SearchEngineSourceConfigScalarFieldEnum: {
    sourceId: 'sourceId',
    engine: 'engine',
    query: 'query',
    region: 'region',
    lang: 'lang',
    apiEndpoint: 'apiEndpoint',
    options: 'options',
    credentialId: 'credentialId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SearchEngineSourceConfigScalarFieldEnum = (typeof SearchEngineSourceConfigScalarFieldEnum)[keyof typeof SearchEngineSourceConfigScalarFieldEnum]


  export const SocialMediaSourceConfigScalarFieldEnum: {
    sourceId: 'sourceId',
    platform: 'platform',
    config: 'config',
    credentialId: 'credentialId',
    proxyId: 'proxyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialMediaSourceConfigScalarFieldEnum = (typeof SocialMediaSourceConfigScalarFieldEnum)[keyof typeof SocialMediaSourceConfigScalarFieldEnum]


  export const QueryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    enabled: 'enabled',
    frequency: 'frequency',
    cronSchedule: 'cronSchedule',
    rules: 'rules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueryScalarFieldEnum = (typeof QueryScalarFieldEnum)[keyof typeof QueryScalarFieldEnum]


  export const QueryRunScalarFieldEnum: {
    id: 'id',
    queryId: 'queryId',
    status: 'status',
    progress: 'progress',
    error: 'error',
    startedAt: 'startedAt',
    finishedAt: 'finishedAt',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueryRunScalarFieldEnum = (typeof QueryRunScalarFieldEnum)[keyof typeof QueryRunScalarFieldEnum]


  export const TaskEventScalarFieldEnum: {
    id: 'id',
    runId: 'runId',
    type: 'type',
    message: 'message',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type TaskEventScalarFieldEnum = (typeof TaskEventScalarFieldEnum)[keyof typeof TaskEventScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    markdown: 'markdown',
    platform: 'platform',
    type: 'type',
    time: 'time',
    url: 'url',
    meta: 'meta',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ContentKeywordScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    keywordId: 'keywordId'
  };

  export type ContentKeywordScalarFieldEnum = (typeof ContentKeywordScalarFieldEnum)[keyof typeof ContentKeywordScalarFieldEnum]


  export const ContentEntityScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    persons: 'persons',
    orgs: 'orgs',
    locations: 'locations'
  };

  export type ContentEntityScalarFieldEnum = (typeof ContentEntityScalarFieldEnum)[keyof typeof ContentEntityScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    contentId: 'contentId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const ReportTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    markdown: 'markdown',
    metadata: 'metadata',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportTemplateScalarFieldEnum = (typeof ReportTemplateScalarFieldEnum)[keyof typeof ReportTemplateScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    title: 'title',
    summary: 'summary',
    status: 'status',
    templateId: 'templateId',
    authorId: 'authorId',
    markdown: 'markdown',
    metadata: 'metadata',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportMaterialScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    sourceType: 'sourceType',
    sourceId: 'sourceId',
    title: 'title',
    snippet: 'snippet',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type ReportMaterialScalarFieldEnum = (typeof ReportMaterialScalarFieldEnum)[keyof typeof ReportMaterialScalarFieldEnum]


  export const KnowledgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeScalarFieldEnum = (typeof KnowledgeScalarFieldEnum)[keyof typeof KnowledgeScalarFieldEnum]


  export const KnowledgeFileScalarFieldEnum: {
    id: 'id',
    knowledgeId: 'knowledgeId',
    name: 'name',
    mimeType: 'mimeType',
    size: 'size',
    storageKey: 'storageKey',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeFileScalarFieldEnum = (typeof KnowledgeFileScalarFieldEnum)[keyof typeof KnowledgeFileScalarFieldEnum]


  export const KnowledgeChunkScalarFieldEnum: {
    id: 'id',
    knowledgeId: 'knowledgeId',
    fileId: 'fileId',
    content: 'content',
    metadata: 'metadata',
    embedding: 'embedding',
    chunkIndex: 'chunkIndex',
    createdAt: 'createdAt'
  };

  export type KnowledgeChunkScalarFieldEnum = (typeof KnowledgeChunkScalarFieldEnum)[keyof typeof KnowledgeChunkScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ProxyType'
   */
  export type EnumProxyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProxyType'>
    


  /**
   * Reference to a field of type 'ProxyType[]'
   */
  export type ListEnumProxyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProxyType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'SourceType'
   */
  export type EnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType'>
    


  /**
   * Reference to a field of type 'SourceType[]'
   */
  export type ListEnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'CrawlerEngine'
   */
  export type EnumCrawlerEngineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrawlerEngine'>
    


  /**
   * Reference to a field of type 'CrawlerEngine[]'
   */
  export type ListEnumCrawlerEngineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CrawlerEngine[]'>
    


  /**
   * Reference to a field of type 'SearchEngineKind'
   */
  export type EnumSearchEngineKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SearchEngineKind'>
    


  /**
   * Reference to a field of type 'SearchEngineKind[]'
   */
  export type ListEnumSearchEngineKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SearchEngineKind[]'>
    


  /**
   * Reference to a field of type 'SocialPlatform'
   */
  export type EnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform'>
    


  /**
   * Reference to a field of type 'SocialPlatform[]'
   */
  export type ListEnumSocialPlatformFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SocialPlatform[]'>
    


  /**
   * Reference to a field of type 'QueryFrequency'
   */
  export type EnumQueryFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryFrequency'>
    


  /**
   * Reference to a field of type 'QueryFrequency[]'
   */
  export type ListEnumQueryFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryFrequency[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'MaterialSource'
   */
  export type EnumMaterialSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialSource'>
    


  /**
   * Reference to a field of type 'MaterialSource[]'
   */
  export type ListEnumMaterialSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaterialSource[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    keywords?: KeywordListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keywords?: KeywordOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    keywords?: KeywordListRelationFilter
  }, "id" | "name">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type KeywordWhereInput = {
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    description?: StringNullableFilter<"Keyword"> | string | null
    lang?: StringNullableFilter<"Keyword"> | string | null
    categoryId?: StringNullableFilter<"Keyword"> | string | null
    includes?: StringNullableListFilter<"Keyword">
    excludes?: StringNullableListFilter<"Keyword">
    enableAiExpand?: BoolFilter<"Keyword"> | boolean
    synonyms?: StringNullableListFilter<"Keyword">
    active?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    queries?: QueryListRelationFilter
    contentKeywords?: ContentKeywordListRelationFilter
  }

  export type KeywordOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    lang?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    enableAiExpand?: SortOrder
    synonyms?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CategoryOrderByWithRelationInput
    queries?: QueryOrderByRelationAggregateInput
    contentKeywords?: ContentKeywordOrderByRelationAggregateInput
  }

  export type KeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: KeywordWhereInput | KeywordWhereInput[]
    OR?: KeywordWhereInput[]
    NOT?: KeywordWhereInput | KeywordWhereInput[]
    description?: StringNullableFilter<"Keyword"> | string | null
    lang?: StringNullableFilter<"Keyword"> | string | null
    categoryId?: StringNullableFilter<"Keyword"> | string | null
    includes?: StringNullableListFilter<"Keyword">
    excludes?: StringNullableListFilter<"Keyword">
    enableAiExpand?: BoolFilter<"Keyword"> | boolean
    synonyms?: StringNullableListFilter<"Keyword">
    active?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    queries?: QueryListRelationFilter
    contentKeywords?: ContentKeywordListRelationFilter
  }, "id" | "name">

  export type KeywordOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    lang?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    enableAiExpand?: SortOrder
    synonyms?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KeywordCountOrderByAggregateInput
    _max?: KeywordMaxOrderByAggregateInput
    _min?: KeywordMinOrderByAggregateInput
  }

  export type KeywordScalarWhereWithAggregatesInput = {
    AND?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    OR?: KeywordScalarWhereWithAggregatesInput[]
    NOT?: KeywordScalarWhereWithAggregatesInput | KeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Keyword"> | string
    name?: StringWithAggregatesFilter<"Keyword"> | string
    description?: StringNullableWithAggregatesFilter<"Keyword"> | string | null
    lang?: StringNullableWithAggregatesFilter<"Keyword"> | string | null
    categoryId?: StringNullableWithAggregatesFilter<"Keyword"> | string | null
    includes?: StringNullableListFilter<"Keyword">
    excludes?: StringNullableListFilter<"Keyword">
    enableAiExpand?: BoolWithAggregatesFilter<"Keyword"> | boolean
    synonyms?: StringNullableListFilter<"Keyword">
    active?: BoolWithAggregatesFilter<"Keyword"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Keyword"> | Date | string
  }

  export type ProxyWhereInput = {
    AND?: ProxyWhereInput | ProxyWhereInput[]
    OR?: ProxyWhereInput[]
    NOT?: ProxyWhereInput | ProxyWhereInput[]
    id?: StringFilter<"Proxy"> | string
    name?: StringFilter<"Proxy"> | string
    type?: EnumProxyTypeFilter<"Proxy"> | $Enums.ProxyType
    url?: StringFilter<"Proxy"> | string
    active?: BoolFilter<"Proxy"> | boolean
    createdAt?: DateTimeFilter<"Proxy"> | Date | string
    updatedAt?: DateTimeFilter<"Proxy"> | Date | string
    sources?: SourceListRelationFilter
    darknetOverrides?: DarknetSourceConfigListRelationFilter
    webOverrides?: WebSourceConfigListRelationFilter
    socialOverrides?: SocialMediaSourceConfigListRelationFilter
  }

  export type ProxyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sources?: SourceOrderByRelationAggregateInput
    darknetOverrides?: DarknetSourceConfigOrderByRelationAggregateInput
    webOverrides?: WebSourceConfigOrderByRelationAggregateInput
    socialOverrides?: SocialMediaSourceConfigOrderByRelationAggregateInput
  }

  export type ProxyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProxyWhereInput | ProxyWhereInput[]
    OR?: ProxyWhereInput[]
    NOT?: ProxyWhereInput | ProxyWhereInput[]
    name?: StringFilter<"Proxy"> | string
    type?: EnumProxyTypeFilter<"Proxy"> | $Enums.ProxyType
    url?: StringFilter<"Proxy"> | string
    active?: BoolFilter<"Proxy"> | boolean
    createdAt?: DateTimeFilter<"Proxy"> | Date | string
    updatedAt?: DateTimeFilter<"Proxy"> | Date | string
    sources?: SourceListRelationFilter
    darknetOverrides?: DarknetSourceConfigListRelationFilter
    webOverrides?: WebSourceConfigListRelationFilter
    socialOverrides?: SocialMediaSourceConfigListRelationFilter
  }, "id">

  export type ProxyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProxyCountOrderByAggregateInput
    _max?: ProxyMaxOrderByAggregateInput
    _min?: ProxyMinOrderByAggregateInput
  }

  export type ProxyScalarWhereWithAggregatesInput = {
    AND?: ProxyScalarWhereWithAggregatesInput | ProxyScalarWhereWithAggregatesInput[]
    OR?: ProxyScalarWhereWithAggregatesInput[]
    NOT?: ProxyScalarWhereWithAggregatesInput | ProxyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proxy"> | string
    name?: StringWithAggregatesFilter<"Proxy"> | string
    type?: EnumProxyTypeWithAggregatesFilter<"Proxy"> | $Enums.ProxyType
    url?: StringWithAggregatesFilter<"Proxy"> | string
    active?: BoolWithAggregatesFilter<"Proxy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Proxy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Proxy"> | Date | string
  }

  export type CredentialWhereInput = {
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    id?: StringFilter<"Credential"> | string
    name?: StringFilter<"Credential"> | string
    kind?: StringFilter<"Credential"> | string
    data?: JsonFilter<"Credential">
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    sources?: SourceListRelationFilter
    socialOverrides?: SocialMediaSourceConfigListRelationFilter
    searchOverrides?: SearchEngineSourceConfigListRelationFilter
  }

  export type CredentialOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sources?: SourceOrderByRelationAggregateInput
    socialOverrides?: SocialMediaSourceConfigOrderByRelationAggregateInput
    searchOverrides?: SearchEngineSourceConfigOrderByRelationAggregateInput
  }

  export type CredentialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CredentialWhereInput | CredentialWhereInput[]
    OR?: CredentialWhereInput[]
    NOT?: CredentialWhereInput | CredentialWhereInput[]
    name?: StringFilter<"Credential"> | string
    kind?: StringFilter<"Credential"> | string
    data?: JsonFilter<"Credential">
    createdAt?: DateTimeFilter<"Credential"> | Date | string
    updatedAt?: DateTimeFilter<"Credential"> | Date | string
    sources?: SourceListRelationFilter
    socialOverrides?: SocialMediaSourceConfigListRelationFilter
    searchOverrides?: SearchEngineSourceConfigListRelationFilter
  }, "id">

  export type CredentialOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CredentialCountOrderByAggregateInput
    _max?: CredentialMaxOrderByAggregateInput
    _min?: CredentialMinOrderByAggregateInput
  }

  export type CredentialScalarWhereWithAggregatesInput = {
    AND?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    OR?: CredentialScalarWhereWithAggregatesInput[]
    NOT?: CredentialScalarWhereWithAggregatesInput | CredentialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Credential"> | string
    name?: StringWithAggregatesFilter<"Credential"> | string
    kind?: StringWithAggregatesFilter<"Credential"> | string
    data?: JsonWithAggregatesFilter<"Credential">
    createdAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Credential"> | Date | string
  }

  export type SourceWhereInput = {
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    id?: StringFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    description?: StringNullableFilter<"Source"> | string | null
    type?: EnumSourceTypeFilter<"Source"> | $Enums.SourceType
    active?: BoolFilter<"Source"> | boolean
    rateLimit?: IntNullableFilter<"Source"> | number | null
    lastFetchedAt?: DateTimeNullableFilter<"Source"> | Date | string | null
    lastStatus?: StringNullableFilter<"Source"> | string | null
    proxyId?: StringNullableFilter<"Source"> | string | null
    credentialId?: StringNullableFilter<"Source"> | string | null
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    web?: XOR<WebSourceConfigNullableScalarRelationFilter, WebSourceConfigWhereInput> | null
    darknet?: XOR<DarknetSourceConfigNullableScalarRelationFilter, DarknetSourceConfigWhereInput> | null
    search?: XOR<SearchEngineSourceConfigNullableScalarRelationFilter, SearchEngineSourceConfigWhereInput> | null
    social?: XOR<SocialMediaSourceConfigNullableScalarRelationFilter, SocialMediaSourceConfigWhereInput> | null
    queries?: QueryListRelationFilter
  }

  export type SourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    active?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    lastStatus?: SortOrderInput | SortOrder
    proxyId?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    proxy?: ProxyOrderByWithRelationInput
    credential?: CredentialOrderByWithRelationInput
    web?: WebSourceConfigOrderByWithRelationInput
    darknet?: DarknetSourceConfigOrderByWithRelationInput
    search?: SearchEngineSourceConfigOrderByWithRelationInput
    social?: SocialMediaSourceConfigOrderByWithRelationInput
    queries?: QueryOrderByRelationAggregateInput
  }

  export type SourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SourceWhereInput | SourceWhereInput[]
    OR?: SourceWhereInput[]
    NOT?: SourceWhereInput | SourceWhereInput[]
    description?: StringNullableFilter<"Source"> | string | null
    type?: EnumSourceTypeFilter<"Source"> | $Enums.SourceType
    active?: BoolFilter<"Source"> | boolean
    rateLimit?: IntNullableFilter<"Source"> | number | null
    lastFetchedAt?: DateTimeNullableFilter<"Source"> | Date | string | null
    lastStatus?: StringNullableFilter<"Source"> | string | null
    proxyId?: StringNullableFilter<"Source"> | string | null
    credentialId?: StringNullableFilter<"Source"> | string | null
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    web?: XOR<WebSourceConfigNullableScalarRelationFilter, WebSourceConfigWhereInput> | null
    darknet?: XOR<DarknetSourceConfigNullableScalarRelationFilter, DarknetSourceConfigWhereInput> | null
    search?: XOR<SearchEngineSourceConfigNullableScalarRelationFilter, SearchEngineSourceConfigWhereInput> | null
    social?: XOR<SocialMediaSourceConfigNullableScalarRelationFilter, SocialMediaSourceConfigWhereInput> | null
    queries?: QueryListRelationFilter
  }, "id" | "name">

  export type SourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    active?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    lastFetchedAt?: SortOrderInput | SortOrder
    lastStatus?: SortOrderInput | SortOrder
    proxyId?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SourceCountOrderByAggregateInput
    _avg?: SourceAvgOrderByAggregateInput
    _max?: SourceMaxOrderByAggregateInput
    _min?: SourceMinOrderByAggregateInput
    _sum?: SourceSumOrderByAggregateInput
  }

  export type SourceScalarWhereWithAggregatesInput = {
    AND?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    OR?: SourceScalarWhereWithAggregatesInput[]
    NOT?: SourceScalarWhereWithAggregatesInput | SourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Source"> | string
    name?: StringWithAggregatesFilter<"Source"> | string
    description?: StringNullableWithAggregatesFilter<"Source"> | string | null
    type?: EnumSourceTypeWithAggregatesFilter<"Source"> | $Enums.SourceType
    active?: BoolWithAggregatesFilter<"Source"> | boolean
    rateLimit?: IntNullableWithAggregatesFilter<"Source"> | number | null
    lastFetchedAt?: DateTimeNullableWithAggregatesFilter<"Source"> | Date | string | null
    lastStatus?: StringNullableWithAggregatesFilter<"Source"> | string | null
    proxyId?: StringNullableWithAggregatesFilter<"Source"> | string | null
    credentialId?: StringNullableWithAggregatesFilter<"Source"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Source"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Source"> | Date | string
  }

  export type WebSourceConfigWhereInput = {
    AND?: WebSourceConfigWhereInput | WebSourceConfigWhereInput[]
    OR?: WebSourceConfigWhereInput[]
    NOT?: WebSourceConfigWhereInput | WebSourceConfigWhereInput[]
    sourceId?: StringFilter<"WebSourceConfig"> | string
    url?: StringFilter<"WebSourceConfig"> | string
    headers?: JsonNullableFilter<"WebSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"WebSourceConfig"> | $Enums.CrawlerEngine
    render?: BoolFilter<"WebSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"WebSourceConfig">
    robotsRespect?: BoolFilter<"WebSourceConfig"> | boolean
    proxyId?: StringNullableFilter<"WebSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
  }

  export type WebSourceConfigOrderByWithRelationInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    crawlerEngine?: SortOrder
    render?: SortOrder
    parseRules?: SortOrderInput | SortOrder
    robotsRespect?: SortOrder
    proxyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SourceOrderByWithRelationInput
    proxy?: ProxyOrderByWithRelationInput
  }

  export type WebSourceConfigWhereUniqueInput = Prisma.AtLeast<{
    sourceId?: string
    AND?: WebSourceConfigWhereInput | WebSourceConfigWhereInput[]
    OR?: WebSourceConfigWhereInput[]
    NOT?: WebSourceConfigWhereInput | WebSourceConfigWhereInput[]
    url?: StringFilter<"WebSourceConfig"> | string
    headers?: JsonNullableFilter<"WebSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"WebSourceConfig"> | $Enums.CrawlerEngine
    render?: BoolFilter<"WebSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"WebSourceConfig">
    robotsRespect?: BoolFilter<"WebSourceConfig"> | boolean
    proxyId?: StringNullableFilter<"WebSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
  }, "sourceId">

  export type WebSourceConfigOrderByWithAggregationInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    crawlerEngine?: SortOrder
    render?: SortOrder
    parseRules?: SortOrderInput | SortOrder
    robotsRespect?: SortOrder
    proxyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WebSourceConfigCountOrderByAggregateInput
    _max?: WebSourceConfigMaxOrderByAggregateInput
    _min?: WebSourceConfigMinOrderByAggregateInput
  }

  export type WebSourceConfigScalarWhereWithAggregatesInput = {
    AND?: WebSourceConfigScalarWhereWithAggregatesInput | WebSourceConfigScalarWhereWithAggregatesInput[]
    OR?: WebSourceConfigScalarWhereWithAggregatesInput[]
    NOT?: WebSourceConfigScalarWhereWithAggregatesInput | WebSourceConfigScalarWhereWithAggregatesInput[]
    sourceId?: StringWithAggregatesFilter<"WebSourceConfig"> | string
    url?: StringWithAggregatesFilter<"WebSourceConfig"> | string
    headers?: JsonNullableWithAggregatesFilter<"WebSourceConfig">
    crawlerEngine?: EnumCrawlerEngineWithAggregatesFilter<"WebSourceConfig"> | $Enums.CrawlerEngine
    render?: BoolWithAggregatesFilter<"WebSourceConfig"> | boolean
    parseRules?: JsonNullableWithAggregatesFilter<"WebSourceConfig">
    robotsRespect?: BoolWithAggregatesFilter<"WebSourceConfig"> | boolean
    proxyId?: StringNullableWithAggregatesFilter<"WebSourceConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebSourceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WebSourceConfig"> | Date | string
  }

  export type DarknetSourceConfigWhereInput = {
    AND?: DarknetSourceConfigWhereInput | DarknetSourceConfigWhereInput[]
    OR?: DarknetSourceConfigWhereInput[]
    NOT?: DarknetSourceConfigWhereInput | DarknetSourceConfigWhereInput[]
    sourceId?: StringFilter<"DarknetSourceConfig"> | string
    url?: StringFilter<"DarknetSourceConfig"> | string
    headers?: JsonNullableFilter<"DarknetSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"DarknetSourceConfig"> | $Enums.CrawlerEngine
    proxyId?: StringFilter<"DarknetSourceConfig"> | string
    render?: BoolFilter<"DarknetSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"DarknetSourceConfig">
    createdAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    proxy?: XOR<ProxyScalarRelationFilter, ProxyWhereInput>
  }

  export type DarknetSourceConfigOrderByWithRelationInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    crawlerEngine?: SortOrder
    proxyId?: SortOrder
    render?: SortOrder
    parseRules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SourceOrderByWithRelationInput
    proxy?: ProxyOrderByWithRelationInput
  }

  export type DarknetSourceConfigWhereUniqueInput = Prisma.AtLeast<{
    sourceId?: string
    AND?: DarknetSourceConfigWhereInput | DarknetSourceConfigWhereInput[]
    OR?: DarknetSourceConfigWhereInput[]
    NOT?: DarknetSourceConfigWhereInput | DarknetSourceConfigWhereInput[]
    url?: StringFilter<"DarknetSourceConfig"> | string
    headers?: JsonNullableFilter<"DarknetSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"DarknetSourceConfig"> | $Enums.CrawlerEngine
    proxyId?: StringFilter<"DarknetSourceConfig"> | string
    render?: BoolFilter<"DarknetSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"DarknetSourceConfig">
    createdAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    proxy?: XOR<ProxyScalarRelationFilter, ProxyWhereInput>
  }, "sourceId">

  export type DarknetSourceConfigOrderByWithAggregationInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrderInput | SortOrder
    crawlerEngine?: SortOrder
    proxyId?: SortOrder
    render?: SortOrder
    parseRules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DarknetSourceConfigCountOrderByAggregateInput
    _max?: DarknetSourceConfigMaxOrderByAggregateInput
    _min?: DarknetSourceConfigMinOrderByAggregateInput
  }

  export type DarknetSourceConfigScalarWhereWithAggregatesInput = {
    AND?: DarknetSourceConfigScalarWhereWithAggregatesInput | DarknetSourceConfigScalarWhereWithAggregatesInput[]
    OR?: DarknetSourceConfigScalarWhereWithAggregatesInput[]
    NOT?: DarknetSourceConfigScalarWhereWithAggregatesInput | DarknetSourceConfigScalarWhereWithAggregatesInput[]
    sourceId?: StringWithAggregatesFilter<"DarknetSourceConfig"> | string
    url?: StringWithAggregatesFilter<"DarknetSourceConfig"> | string
    headers?: JsonNullableWithAggregatesFilter<"DarknetSourceConfig">
    crawlerEngine?: EnumCrawlerEngineWithAggregatesFilter<"DarknetSourceConfig"> | $Enums.CrawlerEngine
    proxyId?: StringWithAggregatesFilter<"DarknetSourceConfig"> | string
    render?: BoolWithAggregatesFilter<"DarknetSourceConfig"> | boolean
    parseRules?: JsonNullableWithAggregatesFilter<"DarknetSourceConfig">
    createdAt?: DateTimeWithAggregatesFilter<"DarknetSourceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DarknetSourceConfig"> | Date | string
  }

  export type SearchEngineSourceConfigWhereInput = {
    AND?: SearchEngineSourceConfigWhereInput | SearchEngineSourceConfigWhereInput[]
    OR?: SearchEngineSourceConfigWhereInput[]
    NOT?: SearchEngineSourceConfigWhereInput | SearchEngineSourceConfigWhereInput[]
    sourceId?: StringFilter<"SearchEngineSourceConfig"> | string
    engine?: EnumSearchEngineKindFilter<"SearchEngineSourceConfig"> | $Enums.SearchEngineKind
    query?: StringFilter<"SearchEngineSourceConfig"> | string
    region?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    lang?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    apiEndpoint?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    options?: JsonNullableFilter<"SearchEngineSourceConfig">
    credentialId?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
  }

  export type SearchEngineSourceConfigOrderByWithRelationInput = {
    sourceId?: SortOrder
    engine?: SortOrder
    query?: SortOrder
    region?: SortOrderInput | SortOrder
    lang?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SourceOrderByWithRelationInput
    credential?: CredentialOrderByWithRelationInput
  }

  export type SearchEngineSourceConfigWhereUniqueInput = Prisma.AtLeast<{
    sourceId?: string
    AND?: SearchEngineSourceConfigWhereInput | SearchEngineSourceConfigWhereInput[]
    OR?: SearchEngineSourceConfigWhereInput[]
    NOT?: SearchEngineSourceConfigWhereInput | SearchEngineSourceConfigWhereInput[]
    engine?: EnumSearchEngineKindFilter<"SearchEngineSourceConfig"> | $Enums.SearchEngineKind
    query?: StringFilter<"SearchEngineSourceConfig"> | string
    region?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    lang?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    apiEndpoint?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    options?: JsonNullableFilter<"SearchEngineSourceConfig">
    credentialId?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
  }, "sourceId">

  export type SearchEngineSourceConfigOrderByWithAggregationInput = {
    sourceId?: SortOrder
    engine?: SortOrder
    query?: SortOrder
    region?: SortOrderInput | SortOrder
    lang?: SortOrderInput | SortOrder
    apiEndpoint?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SearchEngineSourceConfigCountOrderByAggregateInput
    _max?: SearchEngineSourceConfigMaxOrderByAggregateInput
    _min?: SearchEngineSourceConfigMinOrderByAggregateInput
  }

  export type SearchEngineSourceConfigScalarWhereWithAggregatesInput = {
    AND?: SearchEngineSourceConfigScalarWhereWithAggregatesInput | SearchEngineSourceConfigScalarWhereWithAggregatesInput[]
    OR?: SearchEngineSourceConfigScalarWhereWithAggregatesInput[]
    NOT?: SearchEngineSourceConfigScalarWhereWithAggregatesInput | SearchEngineSourceConfigScalarWhereWithAggregatesInput[]
    sourceId?: StringWithAggregatesFilter<"SearchEngineSourceConfig"> | string
    engine?: EnumSearchEngineKindWithAggregatesFilter<"SearchEngineSourceConfig"> | $Enums.SearchEngineKind
    query?: StringWithAggregatesFilter<"SearchEngineSourceConfig"> | string
    region?: StringNullableWithAggregatesFilter<"SearchEngineSourceConfig"> | string | null
    lang?: StringNullableWithAggregatesFilter<"SearchEngineSourceConfig"> | string | null
    apiEndpoint?: StringNullableWithAggregatesFilter<"SearchEngineSourceConfig"> | string | null
    options?: JsonNullableWithAggregatesFilter<"SearchEngineSourceConfig">
    credentialId?: StringNullableWithAggregatesFilter<"SearchEngineSourceConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SearchEngineSourceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SearchEngineSourceConfig"> | Date | string
  }

  export type SocialMediaSourceConfigWhereInput = {
    AND?: SocialMediaSourceConfigWhereInput | SocialMediaSourceConfigWhereInput[]
    OR?: SocialMediaSourceConfigWhereInput[]
    NOT?: SocialMediaSourceConfigWhereInput | SocialMediaSourceConfigWhereInput[]
    sourceId?: StringFilter<"SocialMediaSourceConfig"> | string
    platform?: EnumSocialPlatformFilter<"SocialMediaSourceConfig"> | $Enums.SocialPlatform
    config?: JsonFilter<"SocialMediaSourceConfig">
    credentialId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    proxyId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
  }

  export type SocialMediaSourceConfigOrderByWithRelationInput = {
    sourceId?: SortOrder
    platform?: SortOrder
    config?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    proxyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    source?: SourceOrderByWithRelationInput
    credential?: CredentialOrderByWithRelationInput
    proxy?: ProxyOrderByWithRelationInput
  }

  export type SocialMediaSourceConfigWhereUniqueInput = Prisma.AtLeast<{
    sourceId?: string
    AND?: SocialMediaSourceConfigWhereInput | SocialMediaSourceConfigWhereInput[]
    OR?: SocialMediaSourceConfigWhereInput[]
    NOT?: SocialMediaSourceConfigWhereInput | SocialMediaSourceConfigWhereInput[]
    platform?: EnumSocialPlatformFilter<"SocialMediaSourceConfig"> | $Enums.SocialPlatform
    config?: JsonFilter<"SocialMediaSourceConfig">
    credentialId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    proxyId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
    source?: XOR<SourceScalarRelationFilter, SourceWhereInput>
    credential?: XOR<CredentialNullableScalarRelationFilter, CredentialWhereInput> | null
    proxy?: XOR<ProxyNullableScalarRelationFilter, ProxyWhereInput> | null
  }, "sourceId">

  export type SocialMediaSourceConfigOrderByWithAggregationInput = {
    sourceId?: SortOrder
    platform?: SortOrder
    config?: SortOrder
    credentialId?: SortOrderInput | SortOrder
    proxyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialMediaSourceConfigCountOrderByAggregateInput
    _max?: SocialMediaSourceConfigMaxOrderByAggregateInput
    _min?: SocialMediaSourceConfigMinOrderByAggregateInput
  }

  export type SocialMediaSourceConfigScalarWhereWithAggregatesInput = {
    AND?: SocialMediaSourceConfigScalarWhereWithAggregatesInput | SocialMediaSourceConfigScalarWhereWithAggregatesInput[]
    OR?: SocialMediaSourceConfigScalarWhereWithAggregatesInput[]
    NOT?: SocialMediaSourceConfigScalarWhereWithAggregatesInput | SocialMediaSourceConfigScalarWhereWithAggregatesInput[]
    sourceId?: StringWithAggregatesFilter<"SocialMediaSourceConfig"> | string
    platform?: EnumSocialPlatformWithAggregatesFilter<"SocialMediaSourceConfig"> | $Enums.SocialPlatform
    config?: JsonWithAggregatesFilter<"SocialMediaSourceConfig">
    credentialId?: StringNullableWithAggregatesFilter<"SocialMediaSourceConfig"> | string | null
    proxyId?: StringNullableWithAggregatesFilter<"SocialMediaSourceConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SocialMediaSourceConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialMediaSourceConfig"> | Date | string
  }

  export type QueryWhereInput = {
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    id?: StringFilter<"Query"> | string
    name?: StringFilter<"Query"> | string
    description?: StringNullableFilter<"Query"> | string | null
    enabled?: BoolFilter<"Query"> | boolean
    frequency?: EnumQueryFrequencyFilter<"Query"> | $Enums.QueryFrequency
    cronSchedule?: StringNullableFilter<"Query"> | string | null
    rules?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    keywords?: KeywordListRelationFilter
    sources?: SourceListRelationFilter
    queryRuns?: QueryRunListRelationFilter
  }

  export type QueryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    cronSchedule?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keywords?: KeywordOrderByRelationAggregateInput
    sources?: SourceOrderByRelationAggregateInput
    queryRuns?: QueryRunOrderByRelationAggregateInput
  }

  export type QueryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: QueryWhereInput | QueryWhereInput[]
    OR?: QueryWhereInput[]
    NOT?: QueryWhereInput | QueryWhereInput[]
    description?: StringNullableFilter<"Query"> | string | null
    enabled?: BoolFilter<"Query"> | boolean
    frequency?: EnumQueryFrequencyFilter<"Query"> | $Enums.QueryFrequency
    cronSchedule?: StringNullableFilter<"Query"> | string | null
    rules?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
    keywords?: KeywordListRelationFilter
    sources?: SourceListRelationFilter
    queryRuns?: QueryRunListRelationFilter
  }, "id" | "name">

  export type QueryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    cronSchedule?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueryCountOrderByAggregateInput
    _max?: QueryMaxOrderByAggregateInput
    _min?: QueryMinOrderByAggregateInput
  }

  export type QueryScalarWhereWithAggregatesInput = {
    AND?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    OR?: QueryScalarWhereWithAggregatesInput[]
    NOT?: QueryScalarWhereWithAggregatesInput | QueryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Query"> | string
    name?: StringWithAggregatesFilter<"Query"> | string
    description?: StringNullableWithAggregatesFilter<"Query"> | string | null
    enabled?: BoolWithAggregatesFilter<"Query"> | boolean
    frequency?: EnumQueryFrequencyWithAggregatesFilter<"Query"> | $Enums.QueryFrequency
    cronSchedule?: StringNullableWithAggregatesFilter<"Query"> | string | null
    rules?: JsonNullableWithAggregatesFilter<"Query">
    createdAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Query"> | Date | string
  }

  export type QueryRunWhereInput = {
    AND?: QueryRunWhereInput | QueryRunWhereInput[]
    OR?: QueryRunWhereInput[]
    NOT?: QueryRunWhereInput | QueryRunWhereInput[]
    id?: StringFilter<"QueryRun"> | string
    queryId?: StringFilter<"QueryRun"> | string
    status?: EnumTaskStatusFilter<"QueryRun"> | $Enums.TaskStatus
    progress?: IntFilter<"QueryRun"> | number
    error?: StringNullableFilter<"QueryRun"> | string | null
    startedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    meta?: JsonNullableFilter<"QueryRun">
    createdAt?: DateTimeFilter<"QueryRun"> | Date | string
    updatedAt?: DateTimeFilter<"QueryRun"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
    events?: TaskEventListRelationFilter
  }

  export type QueryRunOrderByWithRelationInput = {
    id?: SortOrder
    queryId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    query?: QueryOrderByWithRelationInput
    events?: TaskEventOrderByRelationAggregateInput
  }

  export type QueryRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueryRunWhereInput | QueryRunWhereInput[]
    OR?: QueryRunWhereInput[]
    NOT?: QueryRunWhereInput | QueryRunWhereInput[]
    queryId?: StringFilter<"QueryRun"> | string
    status?: EnumTaskStatusFilter<"QueryRun"> | $Enums.TaskStatus
    progress?: IntFilter<"QueryRun"> | number
    error?: StringNullableFilter<"QueryRun"> | string | null
    startedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    meta?: JsonNullableFilter<"QueryRun">
    createdAt?: DateTimeFilter<"QueryRun"> | Date | string
    updatedAt?: DateTimeFilter<"QueryRun"> | Date | string
    query?: XOR<QueryScalarRelationFilter, QueryWhereInput>
    events?: TaskEventListRelationFilter
  }, "id">

  export type QueryRunOrderByWithAggregationInput = {
    id?: SortOrder
    queryId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    finishedAt?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueryRunCountOrderByAggregateInput
    _avg?: QueryRunAvgOrderByAggregateInput
    _max?: QueryRunMaxOrderByAggregateInput
    _min?: QueryRunMinOrderByAggregateInput
    _sum?: QueryRunSumOrderByAggregateInput
  }

  export type QueryRunScalarWhereWithAggregatesInput = {
    AND?: QueryRunScalarWhereWithAggregatesInput | QueryRunScalarWhereWithAggregatesInput[]
    OR?: QueryRunScalarWhereWithAggregatesInput[]
    NOT?: QueryRunScalarWhereWithAggregatesInput | QueryRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QueryRun"> | string
    queryId?: StringWithAggregatesFilter<"QueryRun"> | string
    status?: EnumTaskStatusWithAggregatesFilter<"QueryRun"> | $Enums.TaskStatus
    progress?: IntWithAggregatesFilter<"QueryRun"> | number
    error?: StringNullableWithAggregatesFilter<"QueryRun"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"QueryRun"> | Date | string | null
    finishedAt?: DateTimeNullableWithAggregatesFilter<"QueryRun"> | Date | string | null
    meta?: JsonNullableWithAggregatesFilter<"QueryRun">
    createdAt?: DateTimeWithAggregatesFilter<"QueryRun"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QueryRun"> | Date | string
  }

  export type TaskEventWhereInput = {
    AND?: TaskEventWhereInput | TaskEventWhereInput[]
    OR?: TaskEventWhereInput[]
    NOT?: TaskEventWhereInput | TaskEventWhereInput[]
    id?: StringFilter<"TaskEvent"> | string
    runId?: StringFilter<"TaskEvent"> | string
    type?: StringFilter<"TaskEvent"> | string
    message?: StringFilter<"TaskEvent"> | string
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
    run?: XOR<QueryRunScalarRelationFilter, QueryRunWhereInput>
  }

  export type TaskEventOrderByWithRelationInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    run?: QueryRunOrderByWithRelationInput
  }

  export type TaskEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskEventWhereInput | TaskEventWhereInput[]
    OR?: TaskEventWhereInput[]
    NOT?: TaskEventWhereInput | TaskEventWhereInput[]
    runId?: StringFilter<"TaskEvent"> | string
    type?: StringFilter<"TaskEvent"> | string
    message?: StringFilter<"TaskEvent"> | string
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
    run?: XOR<QueryRunScalarRelationFilter, QueryRunWhereInput>
  }, "id">

  export type TaskEventOrderByWithAggregationInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskEventCountOrderByAggregateInput
    _max?: TaskEventMaxOrderByAggregateInput
    _min?: TaskEventMinOrderByAggregateInput
  }

  export type TaskEventScalarWhereWithAggregatesInput = {
    AND?: TaskEventScalarWhereWithAggregatesInput | TaskEventScalarWhereWithAggregatesInput[]
    OR?: TaskEventScalarWhereWithAggregatesInput[]
    NOT?: TaskEventScalarWhereWithAggregatesInput | TaskEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskEvent"> | string
    runId?: StringWithAggregatesFilter<"TaskEvent"> | string
    type?: StringWithAggregatesFilter<"TaskEvent"> | string
    message?: StringWithAggregatesFilter<"TaskEvent"> | string
    data?: JsonNullableWithAggregatesFilter<"TaskEvent">
    createdAt?: DateTimeWithAggregatesFilter<"TaskEvent"> | Date | string
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: StringFilter<"Content"> | string
    title?: StringFilter<"Content"> | string
    summary?: StringFilter<"Content"> | string
    markdown?: StringFilter<"Content"> | string
    platform?: StringFilter<"Content"> | string
    type?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    time?: DateTimeFilter<"Content"> | Date | string
    url?: StringNullableFilter<"Content"> | string | null
    meta?: JsonNullableFilter<"Content">
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    keywords?: ContentKeywordListRelationFilter
    entities?: XOR<ContentEntityNullableScalarRelationFilter, ContentEntityWhereInput> | null
    favorites?: FavoriteListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    markdown?: SortOrder
    platform?: SortOrder
    type?: SortOrder
    time?: SortOrder
    url?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    keywords?: ContentKeywordOrderByRelationAggregateInput
    entities?: ContentEntityOrderByWithRelationInput
    favorites?: FavoriteOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    title?: StringFilter<"Content"> | string
    summary?: StringFilter<"Content"> | string
    markdown?: StringFilter<"Content"> | string
    platform?: StringFilter<"Content"> | string
    type?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    time?: DateTimeFilter<"Content"> | Date | string
    url?: StringNullableFilter<"Content"> | string | null
    meta?: JsonNullableFilter<"Content">
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    keywords?: ContentKeywordListRelationFilter
    entities?: XOR<ContentEntityNullableScalarRelationFilter, ContentEntityWhereInput> | null
    favorites?: FavoriteListRelationFilter
  }, "id">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    markdown?: SortOrder
    platform?: SortOrder
    type?: SortOrder
    time?: SortOrder
    url?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Content"> | string
    title?: StringWithAggregatesFilter<"Content"> | string
    summary?: StringWithAggregatesFilter<"Content"> | string
    markdown?: StringWithAggregatesFilter<"Content"> | string
    platform?: StringWithAggregatesFilter<"Content"> | string
    type?: EnumContentTypeWithAggregatesFilter<"Content"> | $Enums.ContentType
    time?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    url?: StringNullableWithAggregatesFilter<"Content"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"Content">
    createdAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
  }

  export type ContentKeywordWhereInput = {
    AND?: ContentKeywordWhereInput | ContentKeywordWhereInput[]
    OR?: ContentKeywordWhereInput[]
    NOT?: ContentKeywordWhereInput | ContentKeywordWhereInput[]
    id?: StringFilter<"ContentKeyword"> | string
    contentId?: StringFilter<"ContentKeyword"> | string
    keywordId?: StringFilter<"ContentKeyword"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    keyword?: XOR<KeywordScalarRelationFilter, KeywordWhereInput>
  }

  export type ContentKeywordOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    keywordId?: SortOrder
    content?: ContentOrderByWithRelationInput
    keyword?: KeywordOrderByWithRelationInput
  }

  export type ContentKeywordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId_keywordId?: ContentKeywordContentIdKeywordIdCompoundUniqueInput
    AND?: ContentKeywordWhereInput | ContentKeywordWhereInput[]
    OR?: ContentKeywordWhereInput[]
    NOT?: ContentKeywordWhereInput | ContentKeywordWhereInput[]
    contentId?: StringFilter<"ContentKeyword"> | string
    keywordId?: StringFilter<"ContentKeyword"> | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    keyword?: XOR<KeywordScalarRelationFilter, KeywordWhereInput>
  }, "id" | "contentId_keywordId">

  export type ContentKeywordOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    keywordId?: SortOrder
    _count?: ContentKeywordCountOrderByAggregateInput
    _max?: ContentKeywordMaxOrderByAggregateInput
    _min?: ContentKeywordMinOrderByAggregateInput
  }

  export type ContentKeywordScalarWhereWithAggregatesInput = {
    AND?: ContentKeywordScalarWhereWithAggregatesInput | ContentKeywordScalarWhereWithAggregatesInput[]
    OR?: ContentKeywordScalarWhereWithAggregatesInput[]
    NOT?: ContentKeywordScalarWhereWithAggregatesInput | ContentKeywordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentKeyword"> | string
    contentId?: StringWithAggregatesFilter<"ContentKeyword"> | string
    keywordId?: StringWithAggregatesFilter<"ContentKeyword"> | string
  }

  export type ContentEntityWhereInput = {
    AND?: ContentEntityWhereInput | ContentEntityWhereInput[]
    OR?: ContentEntityWhereInput[]
    NOT?: ContentEntityWhereInput | ContentEntityWhereInput[]
    id?: StringFilter<"ContentEntity"> | string
    contentId?: StringFilter<"ContentEntity"> | string
    persons?: StringNullableListFilter<"ContentEntity">
    orgs?: StringNullableListFilter<"ContentEntity">
    locations?: StringNullableListFilter<"ContentEntity">
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }

  export type ContentEntityOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    persons?: SortOrder
    orgs?: SortOrder
    locations?: SortOrder
    content?: ContentOrderByWithRelationInput
  }

  export type ContentEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId?: string
    AND?: ContentEntityWhereInput | ContentEntityWhereInput[]
    OR?: ContentEntityWhereInput[]
    NOT?: ContentEntityWhereInput | ContentEntityWhereInput[]
    persons?: StringNullableListFilter<"ContentEntity">
    orgs?: StringNullableListFilter<"ContentEntity">
    locations?: StringNullableListFilter<"ContentEntity">
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }, "id" | "contentId">

  export type ContentEntityOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    persons?: SortOrder
    orgs?: SortOrder
    locations?: SortOrder
    _count?: ContentEntityCountOrderByAggregateInput
    _max?: ContentEntityMaxOrderByAggregateInput
    _min?: ContentEntityMinOrderByAggregateInput
  }

  export type ContentEntityScalarWhereWithAggregatesInput = {
    AND?: ContentEntityScalarWhereWithAggregatesInput | ContentEntityScalarWhereWithAggregatesInput[]
    OR?: ContentEntityScalarWhereWithAggregatesInput[]
    NOT?: ContentEntityScalarWhereWithAggregatesInput | ContentEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentEntity"> | string
    contentId?: StringWithAggregatesFilter<"ContentEntity"> | string
    persons?: StringNullableListFilter<"ContentEntity">
    orgs?: StringNullableListFilter<"ContentEntity">
    locations?: StringNullableListFilter<"ContentEntity">
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    contentId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    content?: ContentOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_contentId?: FavoriteUserIdContentIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: StringFilter<"Favorite"> | string
    contentId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
  }, "id" | "userId_contentId">

  export type FavoriteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Favorite"> | string
    userId?: StringWithAggregatesFilter<"Favorite"> | string
    contentId?: StringWithAggregatesFilter<"Favorite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type ReportTemplateWhereInput = {
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    id?: StringFilter<"ReportTemplate"> | string
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    markdown?: StringNullableFilter<"ReportTemplate"> | string | null
    metadata?: JsonNullableFilter<"ReportTemplate">
    createdBy?: StringNullableFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    reports?: ReportListRelationFilter
  }

  export type ReportTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    markdown?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reports?: ReportOrderByRelationAggregateInput
  }

  export type ReportTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    OR?: ReportTemplateWhereInput[]
    NOT?: ReportTemplateWhereInput | ReportTemplateWhereInput[]
    name?: StringFilter<"ReportTemplate"> | string
    description?: StringNullableFilter<"ReportTemplate"> | string | null
    markdown?: StringNullableFilter<"ReportTemplate"> | string | null
    metadata?: JsonNullableFilter<"ReportTemplate">
    createdBy?: StringNullableFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ReportTemplate"> | Date | string
    reports?: ReportListRelationFilter
  }, "id">

  export type ReportTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    markdown?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportTemplateCountOrderByAggregateInput
    _max?: ReportTemplateMaxOrderByAggregateInput
    _min?: ReportTemplateMinOrderByAggregateInput
  }

  export type ReportTemplateScalarWhereWithAggregatesInput = {
    AND?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    OR?: ReportTemplateScalarWhereWithAggregatesInput[]
    NOT?: ReportTemplateScalarWhereWithAggregatesInput | ReportTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportTemplate"> | string
    name?: StringWithAggregatesFilter<"ReportTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    markdown?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ReportTemplate">
    createdBy?: StringNullableWithAggregatesFilter<"ReportTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReportTemplate"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    templateId?: StringNullableFilter<"Report"> | string | null
    authorId?: StringNullableFilter<"Report"> | string | null
    markdown?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    version?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
    materials?: ReportMaterialListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    templateId?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    markdown?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: ReportTemplateOrderByWithRelationInput
    materials?: ReportMaterialOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    templateId?: StringNullableFilter<"Report"> | string | null
    authorId?: StringNullableFilter<"Report"> | string | null
    markdown?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    version?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    template?: XOR<ReportTemplateNullableScalarRelationFilter, ReportTemplateWhereInput> | null
    materials?: ReportMaterialListRelationFilter
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    status?: SortOrder
    templateId?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    markdown?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    title?: StringWithAggregatesFilter<"Report"> | string
    summary?: StringNullableWithAggregatesFilter<"Report"> | string | null
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    templateId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    authorId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    markdown?: StringNullableWithAggregatesFilter<"Report"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Report">
    version?: IntWithAggregatesFilter<"Report"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type ReportMaterialWhereInput = {
    AND?: ReportMaterialWhereInput | ReportMaterialWhereInput[]
    OR?: ReportMaterialWhereInput[]
    NOT?: ReportMaterialWhereInput | ReportMaterialWhereInput[]
    id?: StringFilter<"ReportMaterial"> | string
    reportId?: StringFilter<"ReportMaterial"> | string
    sourceType?: EnumMaterialSourceFilter<"ReportMaterial"> | $Enums.MaterialSource
    sourceId?: StringFilter<"ReportMaterial"> | string
    title?: StringNullableFilter<"ReportMaterial"> | string | null
    snippet?: StringNullableFilter<"ReportMaterial"> | string | null
    metadata?: JsonNullableFilter<"ReportMaterial">
    createdAt?: DateTimeFilter<"ReportMaterial"> | Date | string
    report?: XOR<ReportScalarRelationFilter, ReportWhereInput>
  }

  export type ReportMaterialOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    title?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type ReportMaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportMaterialWhereInput | ReportMaterialWhereInput[]
    OR?: ReportMaterialWhereInput[]
    NOT?: ReportMaterialWhereInput | ReportMaterialWhereInput[]
    reportId?: StringFilter<"ReportMaterial"> | string
    sourceType?: EnumMaterialSourceFilter<"ReportMaterial"> | $Enums.MaterialSource
    sourceId?: StringFilter<"ReportMaterial"> | string
    title?: StringNullableFilter<"ReportMaterial"> | string | null
    snippet?: StringNullableFilter<"ReportMaterial"> | string | null
    metadata?: JsonNullableFilter<"ReportMaterial">
    createdAt?: DateTimeFilter<"ReportMaterial"> | Date | string
    report?: XOR<ReportScalarRelationFilter, ReportWhereInput>
  }, "id">

  export type ReportMaterialOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    title?: SortOrderInput | SortOrder
    snippet?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportMaterialCountOrderByAggregateInput
    _max?: ReportMaterialMaxOrderByAggregateInput
    _min?: ReportMaterialMinOrderByAggregateInput
  }

  export type ReportMaterialScalarWhereWithAggregatesInput = {
    AND?: ReportMaterialScalarWhereWithAggregatesInput | ReportMaterialScalarWhereWithAggregatesInput[]
    OR?: ReportMaterialScalarWhereWithAggregatesInput[]
    NOT?: ReportMaterialScalarWhereWithAggregatesInput | ReportMaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportMaterial"> | string
    reportId?: StringWithAggregatesFilter<"ReportMaterial"> | string
    sourceType?: EnumMaterialSourceWithAggregatesFilter<"ReportMaterial"> | $Enums.MaterialSource
    sourceId?: StringWithAggregatesFilter<"ReportMaterial"> | string
    title?: StringNullableWithAggregatesFilter<"ReportMaterial"> | string | null
    snippet?: StringNullableWithAggregatesFilter<"ReportMaterial"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ReportMaterial">
    createdAt?: DateTimeWithAggregatesFilter<"ReportMaterial"> | Date | string
  }

  export type KnowledgeWhereInput = {
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    id?: StringFilter<"Knowledge"> | string
    name?: StringFilter<"Knowledge"> | string
    description?: StringNullableFilter<"Knowledge"> | string | null
    ownerId?: StringNullableFilter<"Knowledge"> | string | null
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    files?: KnowledgeFileListRelationFilter
    knowledgeChunks?: KnowledgeChunkListRelationFilter
  }

  export type KnowledgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    files?: KnowledgeFileOrderByRelationAggregateInput
    knowledgeChunks?: KnowledgeChunkOrderByRelationAggregateInput
  }

  export type KnowledgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeWhereInput | KnowledgeWhereInput[]
    OR?: KnowledgeWhereInput[]
    NOT?: KnowledgeWhereInput | KnowledgeWhereInput[]
    name?: StringFilter<"Knowledge"> | string
    description?: StringNullableFilter<"Knowledge"> | string | null
    ownerId?: StringNullableFilter<"Knowledge"> | string | null
    createdAt?: DateTimeFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeFilter<"Knowledge"> | Date | string
    files?: KnowledgeFileListRelationFilter
    knowledgeChunks?: KnowledgeChunkListRelationFilter
  }, "id">

  export type KnowledgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeCountOrderByAggregateInput
    _max?: KnowledgeMaxOrderByAggregateInput
    _min?: KnowledgeMinOrderByAggregateInput
  }

  export type KnowledgeScalarWhereWithAggregatesInput = {
    AND?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    OR?: KnowledgeScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeScalarWhereWithAggregatesInput | KnowledgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Knowledge"> | string
    name?: StringWithAggregatesFilter<"Knowledge"> | string
    description?: StringNullableWithAggregatesFilter<"Knowledge"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Knowledge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Knowledge"> | Date | string
  }

  export type KnowledgeFileWhereInput = {
    AND?: KnowledgeFileWhereInput | KnowledgeFileWhereInput[]
    OR?: KnowledgeFileWhereInput[]
    NOT?: KnowledgeFileWhereInput | KnowledgeFileWhereInput[]
    id?: StringFilter<"KnowledgeFile"> | string
    knowledgeId?: StringFilter<"KnowledgeFile"> | string
    name?: StringFilter<"KnowledgeFile"> | string
    mimeType?: StringNullableFilter<"KnowledgeFile"> | string | null
    size?: IntNullableFilter<"KnowledgeFile"> | number | null
    storageKey?: StringNullableFilter<"KnowledgeFile"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
    knowledge?: XOR<KnowledgeScalarRelationFilter, KnowledgeWhereInput>
    chunks?: KnowledgeChunkListRelationFilter
  }

  export type KnowledgeFileOrderByWithRelationInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    name?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    knowledge?: KnowledgeOrderByWithRelationInput
    chunks?: KnowledgeChunkOrderByRelationAggregateInput
  }

  export type KnowledgeFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeFileWhereInput | KnowledgeFileWhereInput[]
    OR?: KnowledgeFileWhereInput[]
    NOT?: KnowledgeFileWhereInput | KnowledgeFileWhereInput[]
    knowledgeId?: StringFilter<"KnowledgeFile"> | string
    name?: StringFilter<"KnowledgeFile"> | string
    mimeType?: StringNullableFilter<"KnowledgeFile"> | string | null
    size?: IntNullableFilter<"KnowledgeFile"> | number | null
    storageKey?: StringNullableFilter<"KnowledgeFile"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
    knowledge?: XOR<KnowledgeScalarRelationFilter, KnowledgeWhereInput>
    chunks?: KnowledgeChunkListRelationFilter
  }, "id">

  export type KnowledgeFileOrderByWithAggregationInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    name?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    storageKey?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeFileCountOrderByAggregateInput
    _avg?: KnowledgeFileAvgOrderByAggregateInput
    _max?: KnowledgeFileMaxOrderByAggregateInput
    _min?: KnowledgeFileMinOrderByAggregateInput
    _sum?: KnowledgeFileSumOrderByAggregateInput
  }

  export type KnowledgeFileScalarWhereWithAggregatesInput = {
    AND?: KnowledgeFileScalarWhereWithAggregatesInput | KnowledgeFileScalarWhereWithAggregatesInput[]
    OR?: KnowledgeFileScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeFileScalarWhereWithAggregatesInput | KnowledgeFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeFile"> | string
    knowledgeId?: StringWithAggregatesFilter<"KnowledgeFile"> | string
    name?: StringWithAggregatesFilter<"KnowledgeFile"> | string
    mimeType?: StringNullableWithAggregatesFilter<"KnowledgeFile"> | string | null
    size?: IntNullableWithAggregatesFilter<"KnowledgeFile"> | number | null
    storageKey?: StringNullableWithAggregatesFilter<"KnowledgeFile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeFile"> | Date | string
  }

  export type KnowledgeChunkWhereInput = {
    AND?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    OR?: KnowledgeChunkWhereInput[]
    NOT?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    id?: StringFilter<"KnowledgeChunk"> | string
    knowledgeId?: StringFilter<"KnowledgeChunk"> | string
    fileId?: StringNullableFilter<"KnowledgeChunk"> | string | null
    content?: StringFilter<"KnowledgeChunk"> | string
    metadata?: JsonNullableFilter<"KnowledgeChunk">
    embedding?: BytesNullableFilter<"KnowledgeChunk"> | Bytes | null
    chunkIndex?: IntFilter<"KnowledgeChunk"> | number
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
    knowledge?: XOR<KnowledgeScalarRelationFilter, KnowledgeWhereInput>
    file?: XOR<KnowledgeFileNullableScalarRelationFilter, KnowledgeFileWhereInput> | null
  }

  export type KnowledgeChunkOrderByWithRelationInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    fileId?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    chunkIndex?: SortOrder
    createdAt?: SortOrder
    knowledge?: KnowledgeOrderByWithRelationInput
    file?: KnowledgeFileOrderByWithRelationInput
  }

  export type KnowledgeChunkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    OR?: KnowledgeChunkWhereInput[]
    NOT?: KnowledgeChunkWhereInput | KnowledgeChunkWhereInput[]
    knowledgeId?: StringFilter<"KnowledgeChunk"> | string
    fileId?: StringNullableFilter<"KnowledgeChunk"> | string | null
    content?: StringFilter<"KnowledgeChunk"> | string
    metadata?: JsonNullableFilter<"KnowledgeChunk">
    embedding?: BytesNullableFilter<"KnowledgeChunk"> | Bytes | null
    chunkIndex?: IntFilter<"KnowledgeChunk"> | number
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
    knowledge?: XOR<KnowledgeScalarRelationFilter, KnowledgeWhereInput>
    file?: XOR<KnowledgeFileNullableScalarRelationFilter, KnowledgeFileWhereInput> | null
  }, "id">

  export type KnowledgeChunkOrderByWithAggregationInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    fileId?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    embedding?: SortOrderInput | SortOrder
    chunkIndex?: SortOrder
    createdAt?: SortOrder
    _count?: KnowledgeChunkCountOrderByAggregateInput
    _avg?: KnowledgeChunkAvgOrderByAggregateInput
    _max?: KnowledgeChunkMaxOrderByAggregateInput
    _min?: KnowledgeChunkMinOrderByAggregateInput
    _sum?: KnowledgeChunkSumOrderByAggregateInput
  }

  export type KnowledgeChunkScalarWhereWithAggregatesInput = {
    AND?: KnowledgeChunkScalarWhereWithAggregatesInput | KnowledgeChunkScalarWhereWithAggregatesInput[]
    OR?: KnowledgeChunkScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeChunkScalarWhereWithAggregatesInput | KnowledgeChunkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    knowledgeId?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    fileId?: StringNullableWithAggregatesFilter<"KnowledgeChunk"> | string | null
    content?: StringWithAggregatesFilter<"KnowledgeChunk"> | string
    metadata?: JsonNullableWithAggregatesFilter<"KnowledgeChunk">
    embedding?: BytesNullableWithAggregatesFilter<"KnowledgeChunk"> | Bytes | null
    chunkIndex?: IntWithAggregatesFilter<"KnowledgeChunk"> | number
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeChunk"> | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordCreateInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutKeywordsInput
    queries?: QueryCreateNestedManyWithoutKeywordsInput
    contentKeywords?: ContentKeywordCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    categoryId?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    queries?: QueryUncheckedCreateNestedManyWithoutKeywordsInput
    contentKeywords?: ContentKeywordUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutKeywordsNestedInput
    queries?: QueryUpdateManyWithoutKeywordsNestedInput
    contentKeywords?: ContentKeywordUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: QueryUncheckedUpdateManyWithoutKeywordsNestedInput
    contentKeywords?: ContentKeywordUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    categoryId?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyCreateInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutProxyInput
  }

  export type ProxyUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutProxyInput
  }

  export type ProxyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
  }

  export type ProxyCreateManyInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialCreateInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutCredentialInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutCredentialInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutCredentialNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutCredentialNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialCreateManyInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CredentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CredentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type SourceCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebSourceConfigCreateInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutWebInput
    proxy?: ProxyCreateNestedOneWithoutWebOverridesInput
  }

  export type WebSourceConfigUncheckedCreateInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebSourceConfigUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutWebNestedInput
    proxy?: ProxyUpdateOneWithoutWebOverridesNestedInput
  }

  export type WebSourceConfigUncheckedUpdateInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebSourceConfigCreateManyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebSourceConfigUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebSourceConfigUncheckedUpdateManyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigCreateInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutDarknetInput
    proxy: ProxyCreateNestedOneWithoutDarknetOverridesInput
  }

  export type DarknetSourceConfigUncheckedCreateInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    proxyId: string
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DarknetSourceConfigUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutDarknetNestedInput
    proxy?: ProxyUpdateOneRequiredWithoutDarknetOverridesNestedInput
  }

  export type DarknetSourceConfigUncheckedUpdateInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    proxyId?: StringFieldUpdateOperationsInput | string
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigCreateManyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    proxyId: string
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DarknetSourceConfigUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigUncheckedUpdateManyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    proxyId?: StringFieldUpdateOperationsInput | string
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigCreateInput = {
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutSearchInput
    credential?: CredentialCreateNestedOneWithoutSearchOverridesInput
  }

  export type SearchEngineSourceConfigUncheckedCreateInput = {
    sourceId: string
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchEngineSourceConfigUpdateInput = {
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutSearchNestedInput
    credential?: CredentialUpdateOneWithoutSearchOverridesNestedInput
  }

  export type SearchEngineSourceConfigUncheckedUpdateInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigCreateManyInput = {
    sourceId: string
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchEngineSourceConfigUpdateManyMutationInput = {
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigUncheckedUpdateManyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigCreateInput = {
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutSocialInput
    credential?: CredentialCreateNestedOneWithoutSocialOverridesInput
    proxy?: ProxyCreateNestedOneWithoutSocialOverridesInput
  }

  export type SocialMediaSourceConfigUncheckedCreateInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigUpdateInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutSocialNestedInput
    credential?: CredentialUpdateOneWithoutSocialOverridesNestedInput
    proxy?: ProxyUpdateOneWithoutSocialOverridesNestedInput
  }

  export type SocialMediaSourceConfigUncheckedUpdateInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigCreateManyInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigUpdateManyMutationInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUncheckedUpdateManyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryCreateInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordCreateNestedManyWithoutQueriesInput
    sources?: SourceCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordUncheckedCreateNestedManyWithoutQueriesInput
    sources?: SourceUncheckedCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUpdateManyWithoutQueriesNestedInput
    sources?: SourceUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUncheckedUpdateManyWithoutQueriesNestedInput
    sources?: SourceUncheckedUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryRunCreateInput = {
    id?: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    query: QueryCreateNestedOneWithoutQueryRunsInput
    events?: TaskEventCreateNestedManyWithoutRunInput
  }

  export type QueryRunUncheckedCreateInput = {
    id?: string
    queryId: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TaskEventUncheckedCreateNestedManyWithoutRunInput
  }

  export type QueryRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutQueryRunsNestedInput
    events?: TaskEventUpdateManyWithoutRunNestedInput
  }

  export type QueryRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TaskEventUncheckedUpdateManyWithoutRunNestedInput
  }

  export type QueryRunCreateManyInput = {
    id?: string
    queryId: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventCreateInput = {
    id?: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    run: QueryRunCreateNestedOneWithoutEventsInput
  }

  export type TaskEventUncheckedCreateInput = {
    id?: string
    runId: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    run?: QueryRunUpdateOneRequiredWithoutEventsNestedInput
  }

  export type TaskEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventCreateManyInput = {
    id?: string
    runId: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCreateInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordCreateNestedManyWithoutContentInput
    entities?: ContentEntityCreateNestedOneWithoutContentInput
    favorites?: FavoriteCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordUncheckedCreateNestedManyWithoutContentInput
    entities?: ContentEntityUncheckedCreateNestedOneWithoutContentInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUpdateManyWithoutContentNestedInput
    entities?: ContentEntityUpdateOneWithoutContentNestedInput
    favorites?: FavoriteUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUncheckedUpdateManyWithoutContentNestedInput
    entities?: ContentEntityUncheckedUpdateOneWithoutContentNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentKeywordCreateInput = {
    id?: string
    content: ContentCreateNestedOneWithoutKeywordsInput
    keyword: KeywordCreateNestedOneWithoutContentKeywordsInput
  }

  export type ContentKeywordUncheckedCreateInput = {
    id?: string
    contentId: string
    keywordId: string
  }

  export type ContentKeywordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: ContentUpdateOneRequiredWithoutKeywordsNestedInput
    keyword?: KeywordUpdateOneRequiredWithoutContentKeywordsNestedInput
  }

  export type ContentKeywordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentKeywordCreateManyInput = {
    id?: string
    contentId: string
    keywordId: string
  }

  export type ContentKeywordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ContentKeywordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentEntityCreateInput = {
    id?: string
    persons?: ContentEntityCreatepersonsInput | string[]
    orgs?: ContentEntityCreateorgsInput | string[]
    locations?: ContentEntityCreatelocationsInput | string[]
    content: ContentCreateNestedOneWithoutEntitiesInput
  }

  export type ContentEntityUncheckedCreateInput = {
    id?: string
    contentId: string
    persons?: ContentEntityCreatepersonsInput | string[]
    orgs?: ContentEntityCreateorgsInput | string[]
    locations?: ContentEntityCreatelocationsInput | string[]
  }

  export type ContentEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
    content?: ContentUpdateOneRequiredWithoutEntitiesNestedInput
  }

  export type ContentEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
  }

  export type ContentEntityCreateManyInput = {
    id?: string
    contentId: string
    persons?: ContentEntityCreatepersonsInput | string[]
    orgs?: ContentEntityCreateorgsInput | string[]
    locations?: ContentEntityCreatelocationsInput | string[]
  }

  export type ContentEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
  }

  export type ContentEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
  }

  export type FavoriteCreateInput = {
    id?: string
    userId: string
    createdAt?: Date | string
    content: ContentCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    id?: string
    userId: string
    contentId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    id?: string
    userId: string
    contentId: string
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ReportTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ReportTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
    materials?: ReportMaterialCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    templateId?: string | null
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: ReportMaterialUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
    materials?: ReportMaterialUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: ReportMaterialUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    templateId?: string | null
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialCreateInput = {
    id?: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    report: ReportCreateNestedOneWithoutMaterialsInput
  }

  export type ReportMaterialUncheckedCreateInput = {
    id?: string
    reportId: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportMaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type ReportMaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialCreateManyInput = {
    id?: string
    reportId: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportMaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KnowledgeFileCreateNestedManyWithoutKnowledgeInput
    knowledgeChunks?: KnowledgeChunkCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KnowledgeFileUncheckedCreateNestedManyWithoutKnowledgeInput
    knowledgeChunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KnowledgeFileUpdateManyWithoutKnowledgeNestedInput
    knowledgeChunks?: KnowledgeChunkUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KnowledgeFileUncheckedUpdateManyWithoutKnowledgeNestedInput
    knowledgeChunks?: KnowledgeChunkUncheckedUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeFileCreateInput = {
    id?: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge: KnowledgeCreateNestedOneWithoutFilesInput
    chunks?: KnowledgeChunkCreateNestedManyWithoutFileInput
  }

  export type KnowledgeFileUncheckedCreateInput = {
    id?: string
    knowledgeId: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutFileInput
  }

  export type KnowledgeFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateOneRequiredWithoutFilesNestedInput
    chunks?: KnowledgeChunkUpdateManyWithoutFileNestedInput
  }

  export type KnowledgeFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUncheckedUpdateManyWithoutFileNestedInput
  }

  export type KnowledgeFileCreateManyInput = {
    id?: string
    knowledgeId: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkCreateInput = {
    id?: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
    knowledge: KnowledgeCreateNestedOneWithoutKnowledgeChunksInput
    file?: KnowledgeFileCreateNestedOneWithoutChunksInput
  }

  export type KnowledgeChunkUncheckedCreateInput = {
    id?: string
    knowledgeId: string
    fileId?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateOneRequiredWithoutKnowledgeChunksNestedInput
    file?: KnowledgeFileUpdateOneWithoutChunksNestedInput
  }

  export type KnowledgeChunkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkCreateManyInput = {
    id?: string
    knowledgeId: string
    fileId?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type KeywordListRelationFilter = {
    every?: KeywordWhereInput
    some?: KeywordWhereInput
    none?: KeywordWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type KeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type QueryListRelationFilter = {
    every?: QueryWhereInput
    some?: QueryWhereInput
    none?: QueryWhereInput
  }

  export type ContentKeywordListRelationFilter = {
    every?: ContentKeywordWhereInput
    some?: ContentKeywordWhereInput
    none?: ContentKeywordWhereInput
  }

  export type QueryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentKeywordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KeywordCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lang?: SortOrder
    categoryId?: SortOrder
    includes?: SortOrder
    excludes?: SortOrder
    enableAiExpand?: SortOrder
    synonyms?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lang?: SortOrder
    categoryId?: SortOrder
    enableAiExpand?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KeywordMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    lang?: SortOrder
    categoryId?: SortOrder
    enableAiExpand?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumProxyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyType | EnumProxyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyTypeFilter<$PrismaModel> | $Enums.ProxyType
  }

  export type SourceListRelationFilter = {
    every?: SourceWhereInput
    some?: SourceWhereInput
    none?: SourceWhereInput
  }

  export type DarknetSourceConfigListRelationFilter = {
    every?: DarknetSourceConfigWhereInput
    some?: DarknetSourceConfigWhereInput
    none?: DarknetSourceConfigWhereInput
  }

  export type WebSourceConfigListRelationFilter = {
    every?: WebSourceConfigWhereInput
    some?: WebSourceConfigWhereInput
    none?: WebSourceConfigWhereInput
  }

  export type SocialMediaSourceConfigListRelationFilter = {
    every?: SocialMediaSourceConfigWhereInput
    some?: SocialMediaSourceConfigWhereInput
    none?: SocialMediaSourceConfigWhereInput
  }

  export type SourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DarknetSourceConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebSourceConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialMediaSourceConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProxyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    url?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProxyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyType | EnumProxyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProxyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxyTypeFilter<$PrismaModel>
    _max?: NestedEnumProxyTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SearchEngineSourceConfigListRelationFilter = {
    every?: SearchEngineSourceConfigWhereInput
    some?: SearchEngineSourceConfigWhereInput
    none?: SearchEngineSourceConfigWhereInput
  }

  export type SearchEngineSourceConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CredentialCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CredentialMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    kind?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ProxyNullableScalarRelationFilter = {
    is?: ProxyWhereInput | null
    isNot?: ProxyWhereInput | null
  }

  export type CredentialNullableScalarRelationFilter = {
    is?: CredentialWhereInput | null
    isNot?: CredentialWhereInput | null
  }

  export type WebSourceConfigNullableScalarRelationFilter = {
    is?: WebSourceConfigWhereInput | null
    isNot?: WebSourceConfigWhereInput | null
  }

  export type DarknetSourceConfigNullableScalarRelationFilter = {
    is?: DarknetSourceConfigWhereInput | null
    isNot?: DarknetSourceConfigWhereInput | null
  }

  export type SearchEngineSourceConfigNullableScalarRelationFilter = {
    is?: SearchEngineSourceConfigWhereInput | null
    isNot?: SearchEngineSourceConfigWhereInput | null
  }

  export type SocialMediaSourceConfigNullableScalarRelationFilter = {
    is?: SocialMediaSourceConfigWhereInput | null
    isNot?: SocialMediaSourceConfigWhereInput | null
  }

  export type SourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    active?: SortOrder
    rateLimit?: SortOrder
    lastFetchedAt?: SortOrder
    lastStatus?: SortOrder
    proxyId?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type SourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    active?: SortOrder
    rateLimit?: SortOrder
    lastFetchedAt?: SortOrder
    lastStatus?: SortOrder
    proxyId?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    active?: SortOrder
    rateLimit?: SortOrder
    lastFetchedAt?: SortOrder
    lastStatus?: SortOrder
    proxyId?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceSumOrderByAggregateInput = {
    rateLimit?: SortOrder
  }

  export type EnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumCrawlerEngineFilter<$PrismaModel = never> = {
    equals?: $Enums.CrawlerEngine | EnumCrawlerEngineFieldRefInput<$PrismaModel>
    in?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumCrawlerEngineFilter<$PrismaModel> | $Enums.CrawlerEngine
  }

  export type SourceScalarRelationFilter = {
    is?: SourceWhereInput
    isNot?: SourceWhereInput
  }

  export type WebSourceConfigCountOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrder
    crawlerEngine?: SortOrder
    render?: SortOrder
    parseRules?: SortOrder
    robotsRespect?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebSourceConfigMaxOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    crawlerEngine?: SortOrder
    render?: SortOrder
    robotsRespect?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WebSourceConfigMinOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    crawlerEngine?: SortOrder
    render?: SortOrder
    robotsRespect?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumCrawlerEngineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrawlerEngine | EnumCrawlerEngineFieldRefInput<$PrismaModel>
    in?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumCrawlerEngineWithAggregatesFilter<$PrismaModel> | $Enums.CrawlerEngine
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrawlerEngineFilter<$PrismaModel>
    _max?: NestedEnumCrawlerEngineFilter<$PrismaModel>
  }

  export type ProxyScalarRelationFilter = {
    is?: ProxyWhereInput
    isNot?: ProxyWhereInput
  }

  export type DarknetSourceConfigCountOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    headers?: SortOrder
    crawlerEngine?: SortOrder
    proxyId?: SortOrder
    render?: SortOrder
    parseRules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DarknetSourceConfigMaxOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    crawlerEngine?: SortOrder
    proxyId?: SortOrder
    render?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DarknetSourceConfigMinOrderByAggregateInput = {
    sourceId?: SortOrder
    url?: SortOrder
    crawlerEngine?: SortOrder
    proxyId?: SortOrder
    render?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSearchEngineKindFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchEngineKind | EnumSearchEngineKindFieldRefInput<$PrismaModel>
    in?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchEngineKindFilter<$PrismaModel> | $Enums.SearchEngineKind
  }

  export type SearchEngineSourceConfigCountOrderByAggregateInput = {
    sourceId?: SortOrder
    engine?: SortOrder
    query?: SortOrder
    region?: SortOrder
    lang?: SortOrder
    apiEndpoint?: SortOrder
    options?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchEngineSourceConfigMaxOrderByAggregateInput = {
    sourceId?: SortOrder
    engine?: SortOrder
    query?: SortOrder
    region?: SortOrder
    lang?: SortOrder
    apiEndpoint?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchEngineSourceConfigMinOrderByAggregateInput = {
    sourceId?: SortOrder
    engine?: SortOrder
    query?: SortOrder
    region?: SortOrder
    lang?: SortOrder
    apiEndpoint?: SortOrder
    credentialId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSearchEngineKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchEngineKind | EnumSearchEngineKindFieldRefInput<$PrismaModel>
    in?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchEngineKindWithAggregatesFilter<$PrismaModel> | $Enums.SearchEngineKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSearchEngineKindFilter<$PrismaModel>
    _max?: NestedEnumSearchEngineKindFilter<$PrismaModel>
  }

  export type EnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type SocialMediaSourceConfigCountOrderByAggregateInput = {
    sourceId?: SortOrder
    platform?: SortOrder
    config?: SortOrder
    credentialId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaSourceConfigMaxOrderByAggregateInput = {
    sourceId?: SortOrder
    platform?: SortOrder
    credentialId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaSourceConfigMinOrderByAggregateInput = {
    sourceId?: SortOrder
    platform?: SortOrder
    credentialId?: SortOrder
    proxyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type EnumQueryFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryFrequency | EnumQueryFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryFrequencyFilter<$PrismaModel> | $Enums.QueryFrequency
  }

  export type QueryRunListRelationFilter = {
    every?: QueryRunWhereInput
    some?: QueryRunWhereInput
    none?: QueryRunWhereInput
  }

  export type QueryRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    cronSchedule?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    cronSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    enabled?: SortOrder
    frequency?: SortOrder
    cronSchedule?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumQueryFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryFrequency | EnumQueryFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.QueryFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryFrequencyFilter<$PrismaModel>
    _max?: NestedEnumQueryFrequencyFilter<$PrismaModel>
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type QueryScalarRelationFilter = {
    is?: QueryWhereInput
    isNot?: QueryWhereInput
  }

  export type TaskEventListRelationFilter = {
    every?: TaskEventWhereInput
    some?: TaskEventWhereInput
    none?: TaskEventWhereInput
  }

  export type TaskEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueryRunCountOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryRunAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type QueryRunMaxOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryRunMinOrderByAggregateInput = {
    id?: SortOrder
    queryId?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    error?: SortOrder
    startedAt?: SortOrder
    finishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueryRunSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type QueryRunScalarRelationFilter = {
    is?: QueryRunWhereInput
    isNot?: QueryRunWhereInput
  }

  export type TaskEventCountOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskEventMaxOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskEventMinOrderByAggregateInput = {
    id?: SortOrder
    runId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type ContentEntityNullableScalarRelationFilter = {
    is?: ContentEntityWhereInput | null
    isNot?: ContentEntityWhereInput | null
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    markdown?: SortOrder
    platform?: SortOrder
    type?: SortOrder
    time?: SortOrder
    url?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    markdown?: SortOrder
    platform?: SortOrder
    type?: SortOrder
    time?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    markdown?: SortOrder
    platform?: SortOrder
    type?: SortOrder
    time?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type KeywordScalarRelationFilter = {
    is?: KeywordWhereInput
    isNot?: KeywordWhereInput
  }

  export type ContentKeywordContentIdKeywordIdCompoundUniqueInput = {
    contentId: string
    keywordId: string
  }

  export type ContentKeywordCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    keywordId?: SortOrder
  }

  export type ContentKeywordMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    keywordId?: SortOrder
  }

  export type ContentKeywordMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    keywordId?: SortOrder
  }

  export type ContentEntityCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    persons?: SortOrder
    orgs?: SortOrder
    locations?: SortOrder
  }

  export type ContentEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
  }

  export type ContentEntityMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
  }

  export type FavoriteUserIdContentIdCompoundUniqueInput = {
    userId: string
    contentId: string
  }

  export type FavoriteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    contentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    markdown?: SortOrder
    metadata?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    markdown?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    markdown?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportTemplateNullableScalarRelationFilter = {
    is?: ReportTemplateWhereInput | null
    isNot?: ReportTemplateWhereInput | null
  }

  export type ReportMaterialListRelationFilter = {
    every?: ReportMaterialWhereInput
    some?: ReportMaterialWhereInput
    none?: ReportMaterialWhereInput
  }

  export type ReportMaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    authorId?: SortOrder
    markdown?: SortOrder
    metadata?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    authorId?: SortOrder
    markdown?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    status?: SortOrder
    templateId?: SortOrder
    authorId?: SortOrder
    markdown?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type EnumMaterialSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialSource | EnumMaterialSourceFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialSourceFilter<$PrismaModel> | $Enums.MaterialSource
  }

  export type ReportScalarRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type ReportMaterialCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaterialMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    sourceType?: SortOrder
    sourceId?: SortOrder
    title?: SortOrder
    snippet?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMaterialSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialSource | EnumMaterialSourceFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialSourceWithAggregatesFilter<$PrismaModel> | $Enums.MaterialSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialSourceFilter<$PrismaModel>
    _max?: NestedEnumMaterialSourceFilter<$PrismaModel>
  }

  export type KnowledgeFileListRelationFilter = {
    every?: KnowledgeFileWhereInput
    some?: KnowledgeFileWhereInput
    none?: KnowledgeFileWhereInput
  }

  export type KnowledgeChunkListRelationFilter = {
    every?: KnowledgeChunkWhereInput
    some?: KnowledgeChunkWhereInput
    none?: KnowledgeChunkWhereInput
  }

  export type KnowledgeFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeChunkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KnowledgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeScalarRelationFilter = {
    is?: KnowledgeWhereInput
    isNot?: KnowledgeWhereInput
  }

  export type KnowledgeFileCountOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeFileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type KnowledgeFileMaxOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeFileMinOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    name?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    storageKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeFileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type KnowledgeFileNullableScalarRelationFilter = {
    is?: KnowledgeFileWhereInput | null
    isNot?: KnowledgeFileWhereInput | null
  }

  export type KnowledgeChunkCountOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    embedding?: SortOrder
    chunkIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkAvgOrderByAggregateInput = {
    chunkIndex?: SortOrder
  }

  export type KnowledgeChunkMaxOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    embedding?: SortOrder
    chunkIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkMinOrderByAggregateInput = {
    id?: SortOrder
    knowledgeId?: SortOrder
    fileId?: SortOrder
    content?: SortOrder
    embedding?: SortOrder
    chunkIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type KnowledgeChunkSumOrderByAggregateInput = {
    chunkIndex?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type KeywordCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput> | KeywordCreateWithoutCategoryInput[] | KeywordUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutCategoryInput | KeywordCreateOrConnectWithoutCategoryInput[]
    createMany?: KeywordCreateManyCategoryInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput> | KeywordCreateWithoutCategoryInput[] | KeywordUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutCategoryInput | KeywordCreateOrConnectWithoutCategoryInput[]
    createMany?: KeywordCreateManyCategoryInputEnvelope
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type KeywordUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput> | KeywordCreateWithoutCategoryInput[] | KeywordUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutCategoryInput | KeywordCreateOrConnectWithoutCategoryInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutCategoryInput | KeywordUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KeywordCreateManyCategoryInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutCategoryInput | KeywordUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutCategoryInput | KeywordUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput> | KeywordCreateWithoutCategoryInput[] | KeywordUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutCategoryInput | KeywordCreateOrConnectWithoutCategoryInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutCategoryInput | KeywordUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: KeywordCreateManyCategoryInputEnvelope
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutCategoryInput | KeywordUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutCategoryInput | KeywordUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type KeywordCreateincludesInput = {
    set: string[]
  }

  export type KeywordCreateexcludesInput = {
    set: string[]
  }

  export type KeywordCreatesynonymsInput = {
    set: string[]
  }

  export type CategoryCreateNestedOneWithoutKeywordsInput = {
    create?: XOR<CategoryCreateWithoutKeywordsInput, CategoryUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutKeywordsInput
    connect?: CategoryWhereUniqueInput
  }

  export type QueryCreateNestedManyWithoutKeywordsInput = {
    create?: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput> | QueryCreateWithoutKeywordsInput[] | QueryUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutKeywordsInput | QueryCreateOrConnectWithoutKeywordsInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type ContentKeywordCreateNestedManyWithoutKeywordInput = {
    create?: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput> | ContentKeywordCreateWithoutKeywordInput[] | ContentKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutKeywordInput | ContentKeywordCreateOrConnectWithoutKeywordInput[]
    createMany?: ContentKeywordCreateManyKeywordInputEnvelope
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
  }

  export type QueryUncheckedCreateNestedManyWithoutKeywordsInput = {
    create?: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput> | QueryCreateWithoutKeywordsInput[] | QueryUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutKeywordsInput | QueryCreateOrConnectWithoutKeywordsInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type ContentKeywordUncheckedCreateNestedManyWithoutKeywordInput = {
    create?: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput> | ContentKeywordCreateWithoutKeywordInput[] | ContentKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutKeywordInput | ContentKeywordCreateOrConnectWithoutKeywordInput[]
    createMany?: ContentKeywordCreateManyKeywordInputEnvelope
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
  }

  export type KeywordUpdateincludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type KeywordUpdateexcludesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type KeywordUpdatesynonymsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CategoryUpdateOneWithoutKeywordsNestedInput = {
    create?: XOR<CategoryCreateWithoutKeywordsInput, CategoryUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutKeywordsInput
    upsert?: CategoryUpsertWithoutKeywordsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutKeywordsInput, CategoryUpdateWithoutKeywordsInput>, CategoryUncheckedUpdateWithoutKeywordsInput>
  }

  export type QueryUpdateManyWithoutKeywordsNestedInput = {
    create?: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput> | QueryCreateWithoutKeywordsInput[] | QueryUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutKeywordsInput | QueryCreateOrConnectWithoutKeywordsInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutKeywordsInput | QueryUpsertWithWhereUniqueWithoutKeywordsInput[]
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutKeywordsInput | QueryUpdateWithWhereUniqueWithoutKeywordsInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutKeywordsInput | QueryUpdateManyWithWhereWithoutKeywordsInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type ContentKeywordUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput> | ContentKeywordCreateWithoutKeywordInput[] | ContentKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutKeywordInput | ContentKeywordCreateOrConnectWithoutKeywordInput[]
    upsert?: ContentKeywordUpsertWithWhereUniqueWithoutKeywordInput | ContentKeywordUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: ContentKeywordCreateManyKeywordInputEnvelope
    set?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    disconnect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    delete?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    update?: ContentKeywordUpdateWithWhereUniqueWithoutKeywordInput | ContentKeywordUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: ContentKeywordUpdateManyWithWhereWithoutKeywordInput | ContentKeywordUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
  }

  export type QueryUncheckedUpdateManyWithoutKeywordsNestedInput = {
    create?: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput> | QueryCreateWithoutKeywordsInput[] | QueryUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutKeywordsInput | QueryCreateOrConnectWithoutKeywordsInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutKeywordsInput | QueryUpsertWithWhereUniqueWithoutKeywordsInput[]
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutKeywordsInput | QueryUpdateWithWhereUniqueWithoutKeywordsInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutKeywordsInput | QueryUpdateManyWithWhereWithoutKeywordsInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type ContentKeywordUncheckedUpdateManyWithoutKeywordNestedInput = {
    create?: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput> | ContentKeywordCreateWithoutKeywordInput[] | ContentKeywordUncheckedCreateWithoutKeywordInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutKeywordInput | ContentKeywordCreateOrConnectWithoutKeywordInput[]
    upsert?: ContentKeywordUpsertWithWhereUniqueWithoutKeywordInput | ContentKeywordUpsertWithWhereUniqueWithoutKeywordInput[]
    createMany?: ContentKeywordCreateManyKeywordInputEnvelope
    set?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    disconnect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    delete?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    update?: ContentKeywordUpdateWithWhereUniqueWithoutKeywordInput | ContentKeywordUpdateWithWhereUniqueWithoutKeywordInput[]
    updateMany?: ContentKeywordUpdateManyWithWhereWithoutKeywordInput | ContentKeywordUpdateManyWithWhereWithoutKeywordInput[]
    deleteMany?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
  }

  export type SourceCreateNestedManyWithoutProxyInput = {
    create?: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput> | SourceCreateWithoutProxyInput[] | SourceUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutProxyInput | SourceCreateOrConnectWithoutProxyInput[]
    createMany?: SourceCreateManyProxyInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type DarknetSourceConfigCreateNestedManyWithoutProxyInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput> | DarknetSourceConfigCreateWithoutProxyInput[] | DarknetSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutProxyInput | DarknetSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: DarknetSourceConfigCreateManyProxyInputEnvelope
    connect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
  }

  export type WebSourceConfigCreateNestedManyWithoutProxyInput = {
    create?: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput> | WebSourceConfigCreateWithoutProxyInput[] | WebSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutProxyInput | WebSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: WebSourceConfigCreateManyProxyInputEnvelope
    connect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
  }

  export type SocialMediaSourceConfigCreateNestedManyWithoutProxyInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput> | SocialMediaSourceConfigCreateWithoutProxyInput[] | SocialMediaSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutProxyInput | SocialMediaSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: SocialMediaSourceConfigCreateManyProxyInputEnvelope
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
  }

  export type SourceUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput> | SourceCreateWithoutProxyInput[] | SourceUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutProxyInput | SourceCreateOrConnectWithoutProxyInput[]
    createMany?: SourceCreateManyProxyInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type DarknetSourceConfigUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput> | DarknetSourceConfigCreateWithoutProxyInput[] | DarknetSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutProxyInput | DarknetSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: DarknetSourceConfigCreateManyProxyInputEnvelope
    connect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
  }

  export type WebSourceConfigUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput> | WebSourceConfigCreateWithoutProxyInput[] | WebSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutProxyInput | WebSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: WebSourceConfigCreateManyProxyInputEnvelope
    connect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
  }

  export type SocialMediaSourceConfigUncheckedCreateNestedManyWithoutProxyInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput> | SocialMediaSourceConfigCreateWithoutProxyInput[] | SocialMediaSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutProxyInput | SocialMediaSourceConfigCreateOrConnectWithoutProxyInput[]
    createMany?: SocialMediaSourceConfigCreateManyProxyInputEnvelope
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
  }

  export type EnumProxyTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProxyType
  }

  export type SourceUpdateManyWithoutProxyNestedInput = {
    create?: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput> | SourceCreateWithoutProxyInput[] | SourceUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutProxyInput | SourceCreateOrConnectWithoutProxyInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutProxyInput | SourceUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: SourceCreateManyProxyInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutProxyInput | SourceUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutProxyInput | SourceUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type DarknetSourceConfigUpdateManyWithoutProxyNestedInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput> | DarknetSourceConfigCreateWithoutProxyInput[] | DarknetSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutProxyInput | DarknetSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: DarknetSourceConfigUpsertWithWhereUniqueWithoutProxyInput | DarknetSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: DarknetSourceConfigCreateManyProxyInputEnvelope
    set?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    disconnect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    delete?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    connect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    update?: DarknetSourceConfigUpdateWithWhereUniqueWithoutProxyInput | DarknetSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: DarknetSourceConfigUpdateManyWithWhereWithoutProxyInput | DarknetSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: DarknetSourceConfigScalarWhereInput | DarknetSourceConfigScalarWhereInput[]
  }

  export type WebSourceConfigUpdateManyWithoutProxyNestedInput = {
    create?: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput> | WebSourceConfigCreateWithoutProxyInput[] | WebSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutProxyInput | WebSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: WebSourceConfigUpsertWithWhereUniqueWithoutProxyInput | WebSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: WebSourceConfigCreateManyProxyInputEnvelope
    set?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    disconnect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    delete?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    connect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    update?: WebSourceConfigUpdateWithWhereUniqueWithoutProxyInput | WebSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: WebSourceConfigUpdateManyWithWhereWithoutProxyInput | WebSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: WebSourceConfigScalarWhereInput | WebSourceConfigScalarWhereInput[]
  }

  export type SocialMediaSourceConfigUpdateManyWithoutProxyNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput> | SocialMediaSourceConfigCreateWithoutProxyInput[] | SocialMediaSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutProxyInput | SocialMediaSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: SocialMediaSourceConfigUpsertWithWhereUniqueWithoutProxyInput | SocialMediaSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: SocialMediaSourceConfigCreateManyProxyInputEnvelope
    set?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    disconnect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    delete?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    update?: SocialMediaSourceConfigUpdateWithWhereUniqueWithoutProxyInput | SocialMediaSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: SocialMediaSourceConfigUpdateManyWithWhereWithoutProxyInput | SocialMediaSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
  }

  export type SourceUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput> | SourceCreateWithoutProxyInput[] | SourceUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutProxyInput | SourceCreateOrConnectWithoutProxyInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutProxyInput | SourceUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: SourceCreateManyProxyInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutProxyInput | SourceUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutProxyInput | SourceUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type DarknetSourceConfigUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput> | DarknetSourceConfigCreateWithoutProxyInput[] | DarknetSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutProxyInput | DarknetSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: DarknetSourceConfigUpsertWithWhereUniqueWithoutProxyInput | DarknetSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: DarknetSourceConfigCreateManyProxyInputEnvelope
    set?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    disconnect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    delete?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    connect?: DarknetSourceConfigWhereUniqueInput | DarknetSourceConfigWhereUniqueInput[]
    update?: DarknetSourceConfigUpdateWithWhereUniqueWithoutProxyInput | DarknetSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: DarknetSourceConfigUpdateManyWithWhereWithoutProxyInput | DarknetSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: DarknetSourceConfigScalarWhereInput | DarknetSourceConfigScalarWhereInput[]
  }

  export type WebSourceConfigUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput> | WebSourceConfigCreateWithoutProxyInput[] | WebSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutProxyInput | WebSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: WebSourceConfigUpsertWithWhereUniqueWithoutProxyInput | WebSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: WebSourceConfigCreateManyProxyInputEnvelope
    set?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    disconnect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    delete?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    connect?: WebSourceConfigWhereUniqueInput | WebSourceConfigWhereUniqueInput[]
    update?: WebSourceConfigUpdateWithWhereUniqueWithoutProxyInput | WebSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: WebSourceConfigUpdateManyWithWhereWithoutProxyInput | WebSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: WebSourceConfigScalarWhereInput | WebSourceConfigScalarWhereInput[]
  }

  export type SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput> | SocialMediaSourceConfigCreateWithoutProxyInput[] | SocialMediaSourceConfigUncheckedCreateWithoutProxyInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutProxyInput | SocialMediaSourceConfigCreateOrConnectWithoutProxyInput[]
    upsert?: SocialMediaSourceConfigUpsertWithWhereUniqueWithoutProxyInput | SocialMediaSourceConfigUpsertWithWhereUniqueWithoutProxyInput[]
    createMany?: SocialMediaSourceConfigCreateManyProxyInputEnvelope
    set?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    disconnect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    delete?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    update?: SocialMediaSourceConfigUpdateWithWhereUniqueWithoutProxyInput | SocialMediaSourceConfigUpdateWithWhereUniqueWithoutProxyInput[]
    updateMany?: SocialMediaSourceConfigUpdateManyWithWhereWithoutProxyInput | SocialMediaSourceConfigUpdateManyWithWhereWithoutProxyInput[]
    deleteMany?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
  }

  export type SourceCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput> | SourceCreateWithoutCredentialInput[] | SourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutCredentialInput | SourceCreateOrConnectWithoutCredentialInput[]
    createMany?: SourceCreateManyCredentialInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type SocialMediaSourceConfigCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput> | SocialMediaSourceConfigCreateWithoutCredentialInput[] | SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput | SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput[]
    createMany?: SocialMediaSourceConfigCreateManyCredentialInputEnvelope
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
  }

  export type SearchEngineSourceConfigCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput> | SearchEngineSourceConfigCreateWithoutCredentialInput[] | SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput | SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput[]
    createMany?: SearchEngineSourceConfigCreateManyCredentialInputEnvelope
    connect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
  }

  export type SourceUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput> | SourceCreateWithoutCredentialInput[] | SourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutCredentialInput | SourceCreateOrConnectWithoutCredentialInput[]
    createMany?: SourceCreateManyCredentialInputEnvelope
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type SocialMediaSourceConfigUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput> | SocialMediaSourceConfigCreateWithoutCredentialInput[] | SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput | SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput[]
    createMany?: SocialMediaSourceConfigCreateManyCredentialInputEnvelope
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
  }

  export type SearchEngineSourceConfigUncheckedCreateNestedManyWithoutCredentialInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput> | SearchEngineSourceConfigCreateWithoutCredentialInput[] | SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput | SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput[]
    createMany?: SearchEngineSourceConfigCreateManyCredentialInputEnvelope
    connect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
  }

  export type SourceUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput> | SourceCreateWithoutCredentialInput[] | SourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutCredentialInput | SourceCreateOrConnectWithoutCredentialInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutCredentialInput | SourceUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SourceCreateManyCredentialInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutCredentialInput | SourceUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutCredentialInput | SourceUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type SocialMediaSourceConfigUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput> | SocialMediaSourceConfigCreateWithoutCredentialInput[] | SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput | SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput[]
    upsert?: SocialMediaSourceConfigUpsertWithWhereUniqueWithoutCredentialInput | SocialMediaSourceConfigUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SocialMediaSourceConfigCreateManyCredentialInputEnvelope
    set?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    disconnect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    delete?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    update?: SocialMediaSourceConfigUpdateWithWhereUniqueWithoutCredentialInput | SocialMediaSourceConfigUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SocialMediaSourceConfigUpdateManyWithWhereWithoutCredentialInput | SocialMediaSourceConfigUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
  }

  export type SearchEngineSourceConfigUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput> | SearchEngineSourceConfigCreateWithoutCredentialInput[] | SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput | SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput[]
    upsert?: SearchEngineSourceConfigUpsertWithWhereUniqueWithoutCredentialInput | SearchEngineSourceConfigUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SearchEngineSourceConfigCreateManyCredentialInputEnvelope
    set?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    disconnect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    delete?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    connect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    update?: SearchEngineSourceConfigUpdateWithWhereUniqueWithoutCredentialInput | SearchEngineSourceConfigUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SearchEngineSourceConfigUpdateManyWithWhereWithoutCredentialInput | SearchEngineSourceConfigUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SearchEngineSourceConfigScalarWhereInput | SearchEngineSourceConfigScalarWhereInput[]
  }

  export type SourceUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput> | SourceCreateWithoutCredentialInput[] | SourceUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutCredentialInput | SourceCreateOrConnectWithoutCredentialInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutCredentialInput | SourceUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SourceCreateManyCredentialInputEnvelope
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutCredentialInput | SourceUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutCredentialInput | SourceUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput> | SocialMediaSourceConfigCreateWithoutCredentialInput[] | SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput | SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput[]
    upsert?: SocialMediaSourceConfigUpsertWithWhereUniqueWithoutCredentialInput | SocialMediaSourceConfigUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SocialMediaSourceConfigCreateManyCredentialInputEnvelope
    set?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    disconnect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    delete?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    connect?: SocialMediaSourceConfigWhereUniqueInput | SocialMediaSourceConfigWhereUniqueInput[]
    update?: SocialMediaSourceConfigUpdateWithWhereUniqueWithoutCredentialInput | SocialMediaSourceConfigUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SocialMediaSourceConfigUpdateManyWithWhereWithoutCredentialInput | SocialMediaSourceConfigUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
  }

  export type SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput> | SearchEngineSourceConfigCreateWithoutCredentialInput[] | SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput[]
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput | SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput[]
    upsert?: SearchEngineSourceConfigUpsertWithWhereUniqueWithoutCredentialInput | SearchEngineSourceConfigUpsertWithWhereUniqueWithoutCredentialInput[]
    createMany?: SearchEngineSourceConfigCreateManyCredentialInputEnvelope
    set?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    disconnect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    delete?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    connect?: SearchEngineSourceConfigWhereUniqueInput | SearchEngineSourceConfigWhereUniqueInput[]
    update?: SearchEngineSourceConfigUpdateWithWhereUniqueWithoutCredentialInput | SearchEngineSourceConfigUpdateWithWhereUniqueWithoutCredentialInput[]
    updateMany?: SearchEngineSourceConfigUpdateManyWithWhereWithoutCredentialInput | SearchEngineSourceConfigUpdateManyWithWhereWithoutCredentialInput[]
    deleteMany?: SearchEngineSourceConfigScalarWhereInput | SearchEngineSourceConfigScalarWhereInput[]
  }

  export type ProxyCreateNestedOneWithoutSourcesInput = {
    create?: XOR<ProxyCreateWithoutSourcesInput, ProxyUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutSourcesInput
    connect?: ProxyWhereUniqueInput
  }

  export type CredentialCreateNestedOneWithoutSourcesInput = {
    create?: XOR<CredentialCreateWithoutSourcesInput, CredentialUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSourcesInput
    connect?: CredentialWhereUniqueInput
  }

  export type WebSourceConfigCreateNestedOneWithoutSourceInput = {
    create?: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutSourceInput
    connect?: WebSourceConfigWhereUniqueInput
  }

  export type DarknetSourceConfigCreateNestedOneWithoutSourceInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutSourceInput
    connect?: DarknetSourceConfigWhereUniqueInput
  }

  export type SearchEngineSourceConfigCreateNestedOneWithoutSourceInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutSourceInput
    connect?: SearchEngineSourceConfigWhereUniqueInput
  }

  export type SocialMediaSourceConfigCreateNestedOneWithoutSourceInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutSourceInput
    connect?: SocialMediaSourceConfigWhereUniqueInput
  }

  export type QueryCreateNestedManyWithoutSourcesInput = {
    create?: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput> | QueryCreateWithoutSourcesInput[] | QueryUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutSourcesInput | QueryCreateOrConnectWithoutSourcesInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput = {
    create?: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutSourceInput
    connect?: WebSourceConfigWhereUniqueInput
  }

  export type DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutSourceInput
    connect?: DarknetSourceConfigWhereUniqueInput
  }

  export type SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutSourceInput
    connect?: SearchEngineSourceConfigWhereUniqueInput
  }

  export type SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutSourceInput
    connect?: SocialMediaSourceConfigWhereUniqueInput
  }

  export type QueryUncheckedCreateNestedManyWithoutSourcesInput = {
    create?: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput> | QueryCreateWithoutSourcesInput[] | QueryUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutSourcesInput | QueryCreateOrConnectWithoutSourcesInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
  }

  export type EnumSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SourceType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProxyUpdateOneWithoutSourcesNestedInput = {
    create?: XOR<ProxyCreateWithoutSourcesInput, ProxyUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutSourcesInput
    upsert?: ProxyUpsertWithoutSourcesInput
    disconnect?: ProxyWhereInput | boolean
    delete?: ProxyWhereInput | boolean
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutSourcesInput, ProxyUpdateWithoutSourcesInput>, ProxyUncheckedUpdateWithoutSourcesInput>
  }

  export type CredentialUpdateOneWithoutSourcesNestedInput = {
    create?: XOR<CredentialCreateWithoutSourcesInput, CredentialUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSourcesInput
    upsert?: CredentialUpsertWithoutSourcesInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutSourcesInput, CredentialUpdateWithoutSourcesInput>, CredentialUncheckedUpdateWithoutSourcesInput>
  }

  export type WebSourceConfigUpdateOneWithoutSourceNestedInput = {
    create?: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: WebSourceConfigUpsertWithoutSourceInput
    disconnect?: WebSourceConfigWhereInput | boolean
    delete?: WebSourceConfigWhereInput | boolean
    connect?: WebSourceConfigWhereUniqueInput
    update?: XOR<XOR<WebSourceConfigUpdateToOneWithWhereWithoutSourceInput, WebSourceConfigUpdateWithoutSourceInput>, WebSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type DarknetSourceConfigUpdateOneWithoutSourceNestedInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: DarknetSourceConfigUpsertWithoutSourceInput
    disconnect?: DarknetSourceConfigWhereInput | boolean
    delete?: DarknetSourceConfigWhereInput | boolean
    connect?: DarknetSourceConfigWhereUniqueInput
    update?: XOR<XOR<DarknetSourceConfigUpdateToOneWithWhereWithoutSourceInput, DarknetSourceConfigUpdateWithoutSourceInput>, DarknetSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: SearchEngineSourceConfigUpsertWithoutSourceInput
    disconnect?: SearchEngineSourceConfigWhereInput | boolean
    delete?: SearchEngineSourceConfigWhereInput | boolean
    connect?: SearchEngineSourceConfigWhereUniqueInput
    update?: XOR<XOR<SearchEngineSourceConfigUpdateToOneWithWhereWithoutSourceInput, SearchEngineSourceConfigUpdateWithoutSourceInput>, SearchEngineSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: SocialMediaSourceConfigUpsertWithoutSourceInput
    disconnect?: SocialMediaSourceConfigWhereInput | boolean
    delete?: SocialMediaSourceConfigWhereInput | boolean
    connect?: SocialMediaSourceConfigWhereUniqueInput
    update?: XOR<XOR<SocialMediaSourceConfigUpdateToOneWithWhereWithoutSourceInput, SocialMediaSourceConfigUpdateWithoutSourceInput>, SocialMediaSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type QueryUpdateManyWithoutSourcesNestedInput = {
    create?: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput> | QueryCreateWithoutSourcesInput[] | QueryUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutSourcesInput | QueryCreateOrConnectWithoutSourcesInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutSourcesInput | QueryUpsertWithWhereUniqueWithoutSourcesInput[]
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutSourcesInput | QueryUpdateWithWhereUniqueWithoutSourcesInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutSourcesInput | QueryUpdateManyWithWhereWithoutSourcesInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput = {
    create?: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: WebSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: WebSourceConfigUpsertWithoutSourceInput
    disconnect?: WebSourceConfigWhereInput | boolean
    delete?: WebSourceConfigWhereInput | boolean
    connect?: WebSourceConfigWhereUniqueInput
    update?: XOR<XOR<WebSourceConfigUpdateToOneWithWhereWithoutSourceInput, WebSourceConfigUpdateWithoutSourceInput>, WebSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput = {
    create?: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: DarknetSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: DarknetSourceConfigUpsertWithoutSourceInput
    disconnect?: DarknetSourceConfigWhereInput | boolean
    delete?: DarknetSourceConfigWhereInput | boolean
    connect?: DarknetSourceConfigWhereUniqueInput
    update?: XOR<XOR<DarknetSourceConfigUpdateToOneWithWhereWithoutSourceInput, DarknetSourceConfigUpdateWithoutSourceInput>, DarknetSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput = {
    create?: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SearchEngineSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: SearchEngineSourceConfigUpsertWithoutSourceInput
    disconnect?: SearchEngineSourceConfigWhereInput | boolean
    delete?: SearchEngineSourceConfigWhereInput | boolean
    connect?: SearchEngineSourceConfigWhereUniqueInput
    update?: XOR<XOR<SearchEngineSourceConfigUpdateToOneWithWhereWithoutSourceInput, SearchEngineSourceConfigUpdateWithoutSourceInput>, SearchEngineSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput = {
    create?: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
    connectOrCreate?: SocialMediaSourceConfigCreateOrConnectWithoutSourceInput
    upsert?: SocialMediaSourceConfigUpsertWithoutSourceInput
    disconnect?: SocialMediaSourceConfigWhereInput | boolean
    delete?: SocialMediaSourceConfigWhereInput | boolean
    connect?: SocialMediaSourceConfigWhereUniqueInput
    update?: XOR<XOR<SocialMediaSourceConfigUpdateToOneWithWhereWithoutSourceInput, SocialMediaSourceConfigUpdateWithoutSourceInput>, SocialMediaSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type QueryUncheckedUpdateManyWithoutSourcesNestedInput = {
    create?: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput> | QueryCreateWithoutSourcesInput[] | QueryUncheckedCreateWithoutSourcesInput[]
    connectOrCreate?: QueryCreateOrConnectWithoutSourcesInput | QueryCreateOrConnectWithoutSourcesInput[]
    upsert?: QueryUpsertWithWhereUniqueWithoutSourcesInput | QueryUpsertWithWhereUniqueWithoutSourcesInput[]
    set?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    disconnect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    delete?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    connect?: QueryWhereUniqueInput | QueryWhereUniqueInput[]
    update?: QueryUpdateWithWhereUniqueWithoutSourcesInput | QueryUpdateWithWhereUniqueWithoutSourcesInput[]
    updateMany?: QueryUpdateManyWithWhereWithoutSourcesInput | QueryUpdateManyWithWhereWithoutSourcesInput[]
    deleteMany?: QueryScalarWhereInput | QueryScalarWhereInput[]
  }

  export type SourceCreateNestedOneWithoutWebInput = {
    create?: XOR<SourceCreateWithoutWebInput, SourceUncheckedCreateWithoutWebInput>
    connectOrCreate?: SourceCreateOrConnectWithoutWebInput
    connect?: SourceWhereUniqueInput
  }

  export type ProxyCreateNestedOneWithoutWebOverridesInput = {
    create?: XOR<ProxyCreateWithoutWebOverridesInput, ProxyUncheckedCreateWithoutWebOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutWebOverridesInput
    connect?: ProxyWhereUniqueInput
  }

  export type EnumCrawlerEngineFieldUpdateOperationsInput = {
    set?: $Enums.CrawlerEngine
  }

  export type SourceUpdateOneRequiredWithoutWebNestedInput = {
    create?: XOR<SourceCreateWithoutWebInput, SourceUncheckedCreateWithoutWebInput>
    connectOrCreate?: SourceCreateOrConnectWithoutWebInput
    upsert?: SourceUpsertWithoutWebInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutWebInput, SourceUpdateWithoutWebInput>, SourceUncheckedUpdateWithoutWebInput>
  }

  export type ProxyUpdateOneWithoutWebOverridesNestedInput = {
    create?: XOR<ProxyCreateWithoutWebOverridesInput, ProxyUncheckedCreateWithoutWebOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutWebOverridesInput
    upsert?: ProxyUpsertWithoutWebOverridesInput
    disconnect?: ProxyWhereInput | boolean
    delete?: ProxyWhereInput | boolean
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutWebOverridesInput, ProxyUpdateWithoutWebOverridesInput>, ProxyUncheckedUpdateWithoutWebOverridesInput>
  }

  export type SourceCreateNestedOneWithoutDarknetInput = {
    create?: XOR<SourceCreateWithoutDarknetInput, SourceUncheckedCreateWithoutDarknetInput>
    connectOrCreate?: SourceCreateOrConnectWithoutDarknetInput
    connect?: SourceWhereUniqueInput
  }

  export type ProxyCreateNestedOneWithoutDarknetOverridesInput = {
    create?: XOR<ProxyCreateWithoutDarknetOverridesInput, ProxyUncheckedCreateWithoutDarknetOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutDarknetOverridesInput
    connect?: ProxyWhereUniqueInput
  }

  export type SourceUpdateOneRequiredWithoutDarknetNestedInput = {
    create?: XOR<SourceCreateWithoutDarknetInput, SourceUncheckedCreateWithoutDarknetInput>
    connectOrCreate?: SourceCreateOrConnectWithoutDarknetInput
    upsert?: SourceUpsertWithoutDarknetInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutDarknetInput, SourceUpdateWithoutDarknetInput>, SourceUncheckedUpdateWithoutDarknetInput>
  }

  export type ProxyUpdateOneRequiredWithoutDarknetOverridesNestedInput = {
    create?: XOR<ProxyCreateWithoutDarknetOverridesInput, ProxyUncheckedCreateWithoutDarknetOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutDarknetOverridesInput
    upsert?: ProxyUpsertWithoutDarknetOverridesInput
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutDarknetOverridesInput, ProxyUpdateWithoutDarknetOverridesInput>, ProxyUncheckedUpdateWithoutDarknetOverridesInput>
  }

  export type SourceCreateNestedOneWithoutSearchInput = {
    create?: XOR<SourceCreateWithoutSearchInput, SourceUncheckedCreateWithoutSearchInput>
    connectOrCreate?: SourceCreateOrConnectWithoutSearchInput
    connect?: SourceWhereUniqueInput
  }

  export type CredentialCreateNestedOneWithoutSearchOverridesInput = {
    create?: XOR<CredentialCreateWithoutSearchOverridesInput, CredentialUncheckedCreateWithoutSearchOverridesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSearchOverridesInput
    connect?: CredentialWhereUniqueInput
  }

  export type EnumSearchEngineKindFieldUpdateOperationsInput = {
    set?: $Enums.SearchEngineKind
  }

  export type SourceUpdateOneRequiredWithoutSearchNestedInput = {
    create?: XOR<SourceCreateWithoutSearchInput, SourceUncheckedCreateWithoutSearchInput>
    connectOrCreate?: SourceCreateOrConnectWithoutSearchInput
    upsert?: SourceUpsertWithoutSearchInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutSearchInput, SourceUpdateWithoutSearchInput>, SourceUncheckedUpdateWithoutSearchInput>
  }

  export type CredentialUpdateOneWithoutSearchOverridesNestedInput = {
    create?: XOR<CredentialCreateWithoutSearchOverridesInput, CredentialUncheckedCreateWithoutSearchOverridesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSearchOverridesInput
    upsert?: CredentialUpsertWithoutSearchOverridesInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutSearchOverridesInput, CredentialUpdateWithoutSearchOverridesInput>, CredentialUncheckedUpdateWithoutSearchOverridesInput>
  }

  export type SourceCreateNestedOneWithoutSocialInput = {
    create?: XOR<SourceCreateWithoutSocialInput, SourceUncheckedCreateWithoutSocialInput>
    connectOrCreate?: SourceCreateOrConnectWithoutSocialInput
    connect?: SourceWhereUniqueInput
  }

  export type CredentialCreateNestedOneWithoutSocialOverridesInput = {
    create?: XOR<CredentialCreateWithoutSocialOverridesInput, CredentialUncheckedCreateWithoutSocialOverridesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSocialOverridesInput
    connect?: CredentialWhereUniqueInput
  }

  export type ProxyCreateNestedOneWithoutSocialOverridesInput = {
    create?: XOR<ProxyCreateWithoutSocialOverridesInput, ProxyUncheckedCreateWithoutSocialOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutSocialOverridesInput
    connect?: ProxyWhereUniqueInput
  }

  export type EnumSocialPlatformFieldUpdateOperationsInput = {
    set?: $Enums.SocialPlatform
  }

  export type SourceUpdateOneRequiredWithoutSocialNestedInput = {
    create?: XOR<SourceCreateWithoutSocialInput, SourceUncheckedCreateWithoutSocialInput>
    connectOrCreate?: SourceCreateOrConnectWithoutSocialInput
    upsert?: SourceUpsertWithoutSocialInput
    connect?: SourceWhereUniqueInput
    update?: XOR<XOR<SourceUpdateToOneWithWhereWithoutSocialInput, SourceUpdateWithoutSocialInput>, SourceUncheckedUpdateWithoutSocialInput>
  }

  export type CredentialUpdateOneWithoutSocialOverridesNestedInput = {
    create?: XOR<CredentialCreateWithoutSocialOverridesInput, CredentialUncheckedCreateWithoutSocialOverridesInput>
    connectOrCreate?: CredentialCreateOrConnectWithoutSocialOverridesInput
    upsert?: CredentialUpsertWithoutSocialOverridesInput
    disconnect?: CredentialWhereInput | boolean
    delete?: CredentialWhereInput | boolean
    connect?: CredentialWhereUniqueInput
    update?: XOR<XOR<CredentialUpdateToOneWithWhereWithoutSocialOverridesInput, CredentialUpdateWithoutSocialOverridesInput>, CredentialUncheckedUpdateWithoutSocialOverridesInput>
  }

  export type ProxyUpdateOneWithoutSocialOverridesNestedInput = {
    create?: XOR<ProxyCreateWithoutSocialOverridesInput, ProxyUncheckedCreateWithoutSocialOverridesInput>
    connectOrCreate?: ProxyCreateOrConnectWithoutSocialOverridesInput
    upsert?: ProxyUpsertWithoutSocialOverridesInput
    disconnect?: ProxyWhereInput | boolean
    delete?: ProxyWhereInput | boolean
    connect?: ProxyWhereUniqueInput
    update?: XOR<XOR<ProxyUpdateToOneWithWhereWithoutSocialOverridesInput, ProxyUpdateWithoutSocialOverridesInput>, ProxyUncheckedUpdateWithoutSocialOverridesInput>
  }

  export type KeywordCreateNestedManyWithoutQueriesInput = {
    create?: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput> | KeywordCreateWithoutQueriesInput[] | KeywordUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutQueriesInput | KeywordCreateOrConnectWithoutQueriesInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type SourceCreateNestedManyWithoutQueriesInput = {
    create?: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput> | SourceCreateWithoutQueriesInput[] | SourceUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutQueriesInput | SourceCreateOrConnectWithoutQueriesInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type QueryRunCreateNestedManyWithoutQueryInput = {
    create?: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput> | QueryRunCreateWithoutQueryInput[] | QueryRunUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryRunCreateOrConnectWithoutQueryInput | QueryRunCreateOrConnectWithoutQueryInput[]
    createMany?: QueryRunCreateManyQueryInputEnvelope
    connect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
  }

  export type KeywordUncheckedCreateNestedManyWithoutQueriesInput = {
    create?: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput> | KeywordCreateWithoutQueriesInput[] | KeywordUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutQueriesInput | KeywordCreateOrConnectWithoutQueriesInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
  }

  export type SourceUncheckedCreateNestedManyWithoutQueriesInput = {
    create?: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput> | SourceCreateWithoutQueriesInput[] | SourceUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutQueriesInput | SourceCreateOrConnectWithoutQueriesInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
  }

  export type QueryRunUncheckedCreateNestedManyWithoutQueryInput = {
    create?: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput> | QueryRunCreateWithoutQueryInput[] | QueryRunUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryRunCreateOrConnectWithoutQueryInput | QueryRunCreateOrConnectWithoutQueryInput[]
    createMany?: QueryRunCreateManyQueryInputEnvelope
    connect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
  }

  export type EnumQueryFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.QueryFrequency
  }

  export type KeywordUpdateManyWithoutQueriesNestedInput = {
    create?: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput> | KeywordCreateWithoutQueriesInput[] | KeywordUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutQueriesInput | KeywordCreateOrConnectWithoutQueriesInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutQueriesInput | KeywordUpsertWithWhereUniqueWithoutQueriesInput[]
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutQueriesInput | KeywordUpdateWithWhereUniqueWithoutQueriesInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutQueriesInput | KeywordUpdateManyWithWhereWithoutQueriesInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type SourceUpdateManyWithoutQueriesNestedInput = {
    create?: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput> | SourceCreateWithoutQueriesInput[] | SourceUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutQueriesInput | SourceCreateOrConnectWithoutQueriesInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutQueriesInput | SourceUpsertWithWhereUniqueWithoutQueriesInput[]
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutQueriesInput | SourceUpdateWithWhereUniqueWithoutQueriesInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutQueriesInput | SourceUpdateManyWithWhereWithoutQueriesInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type QueryRunUpdateManyWithoutQueryNestedInput = {
    create?: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput> | QueryRunCreateWithoutQueryInput[] | QueryRunUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryRunCreateOrConnectWithoutQueryInput | QueryRunCreateOrConnectWithoutQueryInput[]
    upsert?: QueryRunUpsertWithWhereUniqueWithoutQueryInput | QueryRunUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: QueryRunCreateManyQueryInputEnvelope
    set?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    disconnect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    delete?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    connect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    update?: QueryRunUpdateWithWhereUniqueWithoutQueryInput | QueryRunUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: QueryRunUpdateManyWithWhereWithoutQueryInput | QueryRunUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: QueryRunScalarWhereInput | QueryRunScalarWhereInput[]
  }

  export type KeywordUncheckedUpdateManyWithoutQueriesNestedInput = {
    create?: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput> | KeywordCreateWithoutQueriesInput[] | KeywordUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: KeywordCreateOrConnectWithoutQueriesInput | KeywordCreateOrConnectWithoutQueriesInput[]
    upsert?: KeywordUpsertWithWhereUniqueWithoutQueriesInput | KeywordUpsertWithWhereUniqueWithoutQueriesInput[]
    set?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    disconnect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    delete?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    connect?: KeywordWhereUniqueInput | KeywordWhereUniqueInput[]
    update?: KeywordUpdateWithWhereUniqueWithoutQueriesInput | KeywordUpdateWithWhereUniqueWithoutQueriesInput[]
    updateMany?: KeywordUpdateManyWithWhereWithoutQueriesInput | KeywordUpdateManyWithWhereWithoutQueriesInput[]
    deleteMany?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
  }

  export type SourceUncheckedUpdateManyWithoutQueriesNestedInput = {
    create?: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput> | SourceCreateWithoutQueriesInput[] | SourceUncheckedCreateWithoutQueriesInput[]
    connectOrCreate?: SourceCreateOrConnectWithoutQueriesInput | SourceCreateOrConnectWithoutQueriesInput[]
    upsert?: SourceUpsertWithWhereUniqueWithoutQueriesInput | SourceUpsertWithWhereUniqueWithoutQueriesInput[]
    set?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    disconnect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    delete?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    connect?: SourceWhereUniqueInput | SourceWhereUniqueInput[]
    update?: SourceUpdateWithWhereUniqueWithoutQueriesInput | SourceUpdateWithWhereUniqueWithoutQueriesInput[]
    updateMany?: SourceUpdateManyWithWhereWithoutQueriesInput | SourceUpdateManyWithWhereWithoutQueriesInput[]
    deleteMany?: SourceScalarWhereInput | SourceScalarWhereInput[]
  }

  export type QueryRunUncheckedUpdateManyWithoutQueryNestedInput = {
    create?: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput> | QueryRunCreateWithoutQueryInput[] | QueryRunUncheckedCreateWithoutQueryInput[]
    connectOrCreate?: QueryRunCreateOrConnectWithoutQueryInput | QueryRunCreateOrConnectWithoutQueryInput[]
    upsert?: QueryRunUpsertWithWhereUniqueWithoutQueryInput | QueryRunUpsertWithWhereUniqueWithoutQueryInput[]
    createMany?: QueryRunCreateManyQueryInputEnvelope
    set?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    disconnect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    delete?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    connect?: QueryRunWhereUniqueInput | QueryRunWhereUniqueInput[]
    update?: QueryRunUpdateWithWhereUniqueWithoutQueryInput | QueryRunUpdateWithWhereUniqueWithoutQueryInput[]
    updateMany?: QueryRunUpdateManyWithWhereWithoutQueryInput | QueryRunUpdateManyWithWhereWithoutQueryInput[]
    deleteMany?: QueryRunScalarWhereInput | QueryRunScalarWhereInput[]
  }

  export type QueryCreateNestedOneWithoutQueryRunsInput = {
    create?: XOR<QueryCreateWithoutQueryRunsInput, QueryUncheckedCreateWithoutQueryRunsInput>
    connectOrCreate?: QueryCreateOrConnectWithoutQueryRunsInput
    connect?: QueryWhereUniqueInput
  }

  export type TaskEventCreateNestedManyWithoutRunInput = {
    create?: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput> | TaskEventCreateWithoutRunInput[] | TaskEventUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutRunInput | TaskEventCreateOrConnectWithoutRunInput[]
    createMany?: TaskEventCreateManyRunInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type TaskEventUncheckedCreateNestedManyWithoutRunInput = {
    create?: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput> | TaskEventCreateWithoutRunInput[] | TaskEventUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutRunInput | TaskEventCreateOrConnectWithoutRunInput[]
    createMany?: TaskEventCreateManyRunInputEnvelope
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QueryUpdateOneRequiredWithoutQueryRunsNestedInput = {
    create?: XOR<QueryCreateWithoutQueryRunsInput, QueryUncheckedCreateWithoutQueryRunsInput>
    connectOrCreate?: QueryCreateOrConnectWithoutQueryRunsInput
    upsert?: QueryUpsertWithoutQueryRunsInput
    connect?: QueryWhereUniqueInput
    update?: XOR<XOR<QueryUpdateToOneWithWhereWithoutQueryRunsInput, QueryUpdateWithoutQueryRunsInput>, QueryUncheckedUpdateWithoutQueryRunsInput>
  }

  export type TaskEventUpdateManyWithoutRunNestedInput = {
    create?: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput> | TaskEventCreateWithoutRunInput[] | TaskEventUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutRunInput | TaskEventCreateOrConnectWithoutRunInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutRunInput | TaskEventUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: TaskEventCreateManyRunInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutRunInput | TaskEventUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutRunInput | TaskEventUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type TaskEventUncheckedUpdateManyWithoutRunNestedInput = {
    create?: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput> | TaskEventCreateWithoutRunInput[] | TaskEventUncheckedCreateWithoutRunInput[]
    connectOrCreate?: TaskEventCreateOrConnectWithoutRunInput | TaskEventCreateOrConnectWithoutRunInput[]
    upsert?: TaskEventUpsertWithWhereUniqueWithoutRunInput | TaskEventUpsertWithWhereUniqueWithoutRunInput[]
    createMany?: TaskEventCreateManyRunInputEnvelope
    set?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    disconnect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    delete?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    connect?: TaskEventWhereUniqueInput | TaskEventWhereUniqueInput[]
    update?: TaskEventUpdateWithWhereUniqueWithoutRunInput | TaskEventUpdateWithWhereUniqueWithoutRunInput[]
    updateMany?: TaskEventUpdateManyWithWhereWithoutRunInput | TaskEventUpdateManyWithWhereWithoutRunInput[]
    deleteMany?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
  }

  export type QueryRunCreateNestedOneWithoutEventsInput = {
    create?: XOR<QueryRunCreateWithoutEventsInput, QueryRunUncheckedCreateWithoutEventsInput>
    connectOrCreate?: QueryRunCreateOrConnectWithoutEventsInput
    connect?: QueryRunWhereUniqueInput
  }

  export type QueryRunUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<QueryRunCreateWithoutEventsInput, QueryRunUncheckedCreateWithoutEventsInput>
    connectOrCreate?: QueryRunCreateOrConnectWithoutEventsInput
    upsert?: QueryRunUpsertWithoutEventsInput
    connect?: QueryRunWhereUniqueInput
    update?: XOR<XOR<QueryRunUpdateToOneWithWhereWithoutEventsInput, QueryRunUpdateWithoutEventsInput>, QueryRunUncheckedUpdateWithoutEventsInput>
  }

  export type ContentKeywordCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput> | ContentKeywordCreateWithoutContentInput[] | ContentKeywordUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutContentInput | ContentKeywordCreateOrConnectWithoutContentInput[]
    createMany?: ContentKeywordCreateManyContentInputEnvelope
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
  }

  export type ContentEntityCreateNestedOneWithoutContentInput = {
    create?: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentEntityCreateOrConnectWithoutContentInput
    connect?: ContentEntityWhereUniqueInput
  }

  export type FavoriteCreateNestedManyWithoutContentInput = {
    create?: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput> | FavoriteCreateWithoutContentInput[] | FavoriteUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutContentInput | FavoriteCreateOrConnectWithoutContentInput[]
    createMany?: FavoriteCreateManyContentInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ContentKeywordUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput> | ContentKeywordCreateWithoutContentInput[] | ContentKeywordUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutContentInput | ContentKeywordCreateOrConnectWithoutContentInput[]
    createMany?: ContentKeywordCreateManyContentInputEnvelope
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
  }

  export type ContentEntityUncheckedCreateNestedOneWithoutContentInput = {
    create?: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentEntityCreateOrConnectWithoutContentInput
    connect?: ContentEntityWhereUniqueInput
  }

  export type FavoriteUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput> | FavoriteCreateWithoutContentInput[] | FavoriteUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutContentInput | FavoriteCreateOrConnectWithoutContentInput[]
    createMany?: FavoriteCreateManyContentInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type ContentKeywordUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput> | ContentKeywordCreateWithoutContentInput[] | ContentKeywordUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutContentInput | ContentKeywordCreateOrConnectWithoutContentInput[]
    upsert?: ContentKeywordUpsertWithWhereUniqueWithoutContentInput | ContentKeywordUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentKeywordCreateManyContentInputEnvelope
    set?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    disconnect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    delete?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    update?: ContentKeywordUpdateWithWhereUniqueWithoutContentInput | ContentKeywordUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentKeywordUpdateManyWithWhereWithoutContentInput | ContentKeywordUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
  }

  export type ContentEntityUpdateOneWithoutContentNestedInput = {
    create?: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentEntityCreateOrConnectWithoutContentInput
    upsert?: ContentEntityUpsertWithoutContentInput
    disconnect?: ContentEntityWhereInput | boolean
    delete?: ContentEntityWhereInput | boolean
    connect?: ContentEntityWhereUniqueInput
    update?: XOR<XOR<ContentEntityUpdateToOneWithWhereWithoutContentInput, ContentEntityUpdateWithoutContentInput>, ContentEntityUncheckedUpdateWithoutContentInput>
  }

  export type FavoriteUpdateManyWithoutContentNestedInput = {
    create?: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput> | FavoriteCreateWithoutContentInput[] | FavoriteUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutContentInput | FavoriteCreateOrConnectWithoutContentInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutContentInput | FavoriteUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FavoriteCreateManyContentInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutContentInput | FavoriteUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutContentInput | FavoriteUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ContentKeywordUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput> | ContentKeywordCreateWithoutContentInput[] | ContentKeywordUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentKeywordCreateOrConnectWithoutContentInput | ContentKeywordCreateOrConnectWithoutContentInput[]
    upsert?: ContentKeywordUpsertWithWhereUniqueWithoutContentInput | ContentKeywordUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentKeywordCreateManyContentInputEnvelope
    set?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    disconnect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    delete?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    connect?: ContentKeywordWhereUniqueInput | ContentKeywordWhereUniqueInput[]
    update?: ContentKeywordUpdateWithWhereUniqueWithoutContentInput | ContentKeywordUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentKeywordUpdateManyWithWhereWithoutContentInput | ContentKeywordUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
  }

  export type ContentEntityUncheckedUpdateOneWithoutContentNestedInput = {
    create?: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
    connectOrCreate?: ContentEntityCreateOrConnectWithoutContentInput
    upsert?: ContentEntityUpsertWithoutContentInput
    disconnect?: ContentEntityWhereInput | boolean
    delete?: ContentEntityWhereInput | boolean
    connect?: ContentEntityWhereUniqueInput
    update?: XOR<XOR<ContentEntityUpdateToOneWithWhereWithoutContentInput, ContentEntityUpdateWithoutContentInput>, ContentEntityUncheckedUpdateWithoutContentInput>
  }

  export type FavoriteUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput> | FavoriteCreateWithoutContentInput[] | FavoriteUncheckedCreateWithoutContentInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutContentInput | FavoriteCreateOrConnectWithoutContentInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutContentInput | FavoriteUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: FavoriteCreateManyContentInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutContentInput | FavoriteUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutContentInput | FavoriteUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutKeywordsInput = {
    create?: XOR<ContentCreateWithoutKeywordsInput, ContentUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutKeywordsInput
    connect?: ContentWhereUniqueInput
  }

  export type KeywordCreateNestedOneWithoutContentKeywordsInput = {
    create?: XOR<KeywordCreateWithoutContentKeywordsInput, KeywordUncheckedCreateWithoutContentKeywordsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutContentKeywordsInput
    connect?: KeywordWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutKeywordsNestedInput = {
    create?: XOR<ContentCreateWithoutKeywordsInput, ContentUncheckedCreateWithoutKeywordsInput>
    connectOrCreate?: ContentCreateOrConnectWithoutKeywordsInput
    upsert?: ContentUpsertWithoutKeywordsInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutKeywordsInput, ContentUpdateWithoutKeywordsInput>, ContentUncheckedUpdateWithoutKeywordsInput>
  }

  export type KeywordUpdateOneRequiredWithoutContentKeywordsNestedInput = {
    create?: XOR<KeywordCreateWithoutContentKeywordsInput, KeywordUncheckedCreateWithoutContentKeywordsInput>
    connectOrCreate?: KeywordCreateOrConnectWithoutContentKeywordsInput
    upsert?: KeywordUpsertWithoutContentKeywordsInput
    connect?: KeywordWhereUniqueInput
    update?: XOR<XOR<KeywordUpdateToOneWithWhereWithoutContentKeywordsInput, KeywordUpdateWithoutContentKeywordsInput>, KeywordUncheckedUpdateWithoutContentKeywordsInput>
  }

  export type ContentEntityCreatepersonsInput = {
    set: string[]
  }

  export type ContentEntityCreateorgsInput = {
    set: string[]
  }

  export type ContentEntityCreatelocationsInput = {
    set: string[]
  }

  export type ContentCreateNestedOneWithoutEntitiesInput = {
    create?: XOR<ContentCreateWithoutEntitiesInput, ContentUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutEntitiesInput
    connect?: ContentWhereUniqueInput
  }

  export type ContentEntityUpdatepersonsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentEntityUpdateorgsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentEntityUpdatelocationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentUpdateOneRequiredWithoutEntitiesNestedInput = {
    create?: XOR<ContentCreateWithoutEntitiesInput, ContentUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutEntitiesInput
    upsert?: ContentUpsertWithoutEntitiesInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutEntitiesInput, ContentUpdateWithoutEntitiesInput>, ContentUncheckedUpdateWithoutEntitiesInput>
  }

  export type ContentCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ContentCreateWithoutFavoritesInput, ContentUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutFavoritesInput
    connect?: ContentWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ContentCreateWithoutFavoritesInput, ContentUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ContentCreateOrConnectWithoutFavoritesInput
    upsert?: ContentUpsertWithoutFavoritesInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutFavoritesInput, ContentUpdateWithoutFavoritesInput>, ContentUncheckedUpdateWithoutFavoritesInput>
  }

  export type ReportCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTemplateInput | ReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTemplateInput | ReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTemplateInput | ReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput> | ReportCreateWithoutTemplateInput[] | ReportUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutTemplateInput | ReportCreateOrConnectWithoutTemplateInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutTemplateInput | ReportUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ReportCreateManyTemplateInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutTemplateInput | ReportUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutTemplateInput | ReportUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportTemplateCreateNestedOneWithoutReportsInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    connect?: ReportTemplateWhereUniqueInput
  }

  export type ReportMaterialCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput> | ReportMaterialCreateWithoutReportInput[] | ReportMaterialUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportMaterialCreateOrConnectWithoutReportInput | ReportMaterialCreateOrConnectWithoutReportInput[]
    createMany?: ReportMaterialCreateManyReportInputEnvelope
    connect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
  }

  export type ReportMaterialUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput> | ReportMaterialCreateWithoutReportInput[] | ReportMaterialUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportMaterialCreateOrConnectWithoutReportInput | ReportMaterialCreateOrConnectWithoutReportInput[]
    createMany?: ReportMaterialCreateManyReportInputEnvelope
    connect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type ReportTemplateUpdateOneWithoutReportsNestedInput = {
    create?: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReportTemplateCreateOrConnectWithoutReportsInput
    upsert?: ReportTemplateUpsertWithoutReportsInput
    disconnect?: ReportTemplateWhereInput | boolean
    delete?: ReportTemplateWhereInput | boolean
    connect?: ReportTemplateWhereUniqueInput
    update?: XOR<XOR<ReportTemplateUpdateToOneWithWhereWithoutReportsInput, ReportTemplateUpdateWithoutReportsInput>, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type ReportMaterialUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput> | ReportMaterialCreateWithoutReportInput[] | ReportMaterialUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportMaterialCreateOrConnectWithoutReportInput | ReportMaterialCreateOrConnectWithoutReportInput[]
    upsert?: ReportMaterialUpsertWithWhereUniqueWithoutReportInput | ReportMaterialUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportMaterialCreateManyReportInputEnvelope
    set?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    disconnect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    delete?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    connect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    update?: ReportMaterialUpdateWithWhereUniqueWithoutReportInput | ReportMaterialUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportMaterialUpdateManyWithWhereWithoutReportInput | ReportMaterialUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportMaterialScalarWhereInput | ReportMaterialScalarWhereInput[]
  }

  export type ReportMaterialUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput> | ReportMaterialCreateWithoutReportInput[] | ReportMaterialUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportMaterialCreateOrConnectWithoutReportInput | ReportMaterialCreateOrConnectWithoutReportInput[]
    upsert?: ReportMaterialUpsertWithWhereUniqueWithoutReportInput | ReportMaterialUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportMaterialCreateManyReportInputEnvelope
    set?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    disconnect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    delete?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    connect?: ReportMaterialWhereUniqueInput | ReportMaterialWhereUniqueInput[]
    update?: ReportMaterialUpdateWithWhereUniqueWithoutReportInput | ReportMaterialUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportMaterialUpdateManyWithWhereWithoutReportInput | ReportMaterialUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportMaterialScalarWhereInput | ReportMaterialScalarWhereInput[]
  }

  export type ReportCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<ReportCreateWithoutMaterialsInput, ReportUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutMaterialsInput
    connect?: ReportWhereUniqueInput
  }

  export type EnumMaterialSourceFieldUpdateOperationsInput = {
    set?: $Enums.MaterialSource
  }

  export type ReportUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<ReportCreateWithoutMaterialsInput, ReportUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutMaterialsInput
    upsert?: ReportUpsertWithoutMaterialsInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutMaterialsInput, ReportUpdateWithoutMaterialsInput>, ReportUncheckedUpdateWithoutMaterialsInput>
  }

  export type KnowledgeFileCreateNestedManyWithoutKnowledgeInput = {
    create?: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput> | KnowledgeFileCreateWithoutKnowledgeInput[] | KnowledgeFileUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutKnowledgeInput | KnowledgeFileCreateOrConnectWithoutKnowledgeInput[]
    createMany?: KnowledgeFileCreateManyKnowledgeInputEnvelope
    connect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
  }

  export type KnowledgeChunkCreateNestedManyWithoutKnowledgeInput = {
    create?: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput> | KnowledgeChunkCreateWithoutKnowledgeInput[] | KnowledgeChunkUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutKnowledgeInput | KnowledgeChunkCreateOrConnectWithoutKnowledgeInput[]
    createMany?: KnowledgeChunkCreateManyKnowledgeInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type KnowledgeFileUncheckedCreateNestedManyWithoutKnowledgeInput = {
    create?: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput> | KnowledgeFileCreateWithoutKnowledgeInput[] | KnowledgeFileUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutKnowledgeInput | KnowledgeFileCreateOrConnectWithoutKnowledgeInput[]
    createMany?: KnowledgeFileCreateManyKnowledgeInputEnvelope
    connect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
  }

  export type KnowledgeChunkUncheckedCreateNestedManyWithoutKnowledgeInput = {
    create?: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput> | KnowledgeChunkCreateWithoutKnowledgeInput[] | KnowledgeChunkUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutKnowledgeInput | KnowledgeChunkCreateOrConnectWithoutKnowledgeInput[]
    createMany?: KnowledgeChunkCreateManyKnowledgeInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type KnowledgeFileUpdateManyWithoutKnowledgeNestedInput = {
    create?: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput> | KnowledgeFileCreateWithoutKnowledgeInput[] | KnowledgeFileUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutKnowledgeInput | KnowledgeFileCreateOrConnectWithoutKnowledgeInput[]
    upsert?: KnowledgeFileUpsertWithWhereUniqueWithoutKnowledgeInput | KnowledgeFileUpsertWithWhereUniqueWithoutKnowledgeInput[]
    createMany?: KnowledgeFileCreateManyKnowledgeInputEnvelope
    set?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    disconnect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    delete?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    connect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    update?: KnowledgeFileUpdateWithWhereUniqueWithoutKnowledgeInput | KnowledgeFileUpdateWithWhereUniqueWithoutKnowledgeInput[]
    updateMany?: KnowledgeFileUpdateManyWithWhereWithoutKnowledgeInput | KnowledgeFileUpdateManyWithWhereWithoutKnowledgeInput[]
    deleteMany?: KnowledgeFileScalarWhereInput | KnowledgeFileScalarWhereInput[]
  }

  export type KnowledgeChunkUpdateManyWithoutKnowledgeNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput> | KnowledgeChunkCreateWithoutKnowledgeInput[] | KnowledgeChunkUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutKnowledgeInput | KnowledgeChunkCreateOrConnectWithoutKnowledgeInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutKnowledgeInput | KnowledgeChunkUpsertWithWhereUniqueWithoutKnowledgeInput[]
    createMany?: KnowledgeChunkCreateManyKnowledgeInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutKnowledgeInput | KnowledgeChunkUpdateWithWhereUniqueWithoutKnowledgeInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutKnowledgeInput | KnowledgeChunkUpdateManyWithWhereWithoutKnowledgeInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeFileUncheckedUpdateManyWithoutKnowledgeNestedInput = {
    create?: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput> | KnowledgeFileCreateWithoutKnowledgeInput[] | KnowledgeFileUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutKnowledgeInput | KnowledgeFileCreateOrConnectWithoutKnowledgeInput[]
    upsert?: KnowledgeFileUpsertWithWhereUniqueWithoutKnowledgeInput | KnowledgeFileUpsertWithWhereUniqueWithoutKnowledgeInput[]
    createMany?: KnowledgeFileCreateManyKnowledgeInputEnvelope
    set?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    disconnect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    delete?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    connect?: KnowledgeFileWhereUniqueInput | KnowledgeFileWhereUniqueInput[]
    update?: KnowledgeFileUpdateWithWhereUniqueWithoutKnowledgeInput | KnowledgeFileUpdateWithWhereUniqueWithoutKnowledgeInput[]
    updateMany?: KnowledgeFileUpdateManyWithWhereWithoutKnowledgeInput | KnowledgeFileUpdateManyWithWhereWithoutKnowledgeInput[]
    deleteMany?: KnowledgeFileScalarWhereInput | KnowledgeFileScalarWhereInput[]
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutKnowledgeNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput> | KnowledgeChunkCreateWithoutKnowledgeInput[] | KnowledgeChunkUncheckedCreateWithoutKnowledgeInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutKnowledgeInput | KnowledgeChunkCreateOrConnectWithoutKnowledgeInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutKnowledgeInput | KnowledgeChunkUpsertWithWhereUniqueWithoutKnowledgeInput[]
    createMany?: KnowledgeChunkCreateManyKnowledgeInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutKnowledgeInput | KnowledgeChunkUpdateWithWhereUniqueWithoutKnowledgeInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutKnowledgeInput | KnowledgeChunkUpdateManyWithWhereWithoutKnowledgeInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeCreateNestedOneWithoutFilesInput = {
    create?: XOR<KnowledgeCreateWithoutFilesInput, KnowledgeUncheckedCreateWithoutFilesInput>
    connectOrCreate?: KnowledgeCreateOrConnectWithoutFilesInput
    connect?: KnowledgeWhereUniqueInput
  }

  export type KnowledgeChunkCreateNestedManyWithoutFileInput = {
    create?: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput> | KnowledgeChunkCreateWithoutFileInput[] | KnowledgeChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutFileInput | KnowledgeChunkCreateOrConnectWithoutFileInput[]
    createMany?: KnowledgeChunkCreateManyFileInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type KnowledgeChunkUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput> | KnowledgeChunkCreateWithoutFileInput[] | KnowledgeChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutFileInput | KnowledgeChunkCreateOrConnectWithoutFileInput[]
    createMany?: KnowledgeChunkCreateManyFileInputEnvelope
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
  }

  export type KnowledgeUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<KnowledgeCreateWithoutFilesInput, KnowledgeUncheckedCreateWithoutFilesInput>
    connectOrCreate?: KnowledgeCreateOrConnectWithoutFilesInput
    upsert?: KnowledgeUpsertWithoutFilesInput
    connect?: KnowledgeWhereUniqueInput
    update?: XOR<XOR<KnowledgeUpdateToOneWithWhereWithoutFilesInput, KnowledgeUpdateWithoutFilesInput>, KnowledgeUncheckedUpdateWithoutFilesInput>
  }

  export type KnowledgeChunkUpdateManyWithoutFileNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput> | KnowledgeChunkCreateWithoutFileInput[] | KnowledgeChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutFileInput | KnowledgeChunkCreateOrConnectWithoutFileInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutFileInput | KnowledgeChunkUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: KnowledgeChunkCreateManyFileInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutFileInput | KnowledgeChunkUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutFileInput | KnowledgeChunkUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput> | KnowledgeChunkCreateWithoutFileInput[] | KnowledgeChunkUncheckedCreateWithoutFileInput[]
    connectOrCreate?: KnowledgeChunkCreateOrConnectWithoutFileInput | KnowledgeChunkCreateOrConnectWithoutFileInput[]
    upsert?: KnowledgeChunkUpsertWithWhereUniqueWithoutFileInput | KnowledgeChunkUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: KnowledgeChunkCreateManyFileInputEnvelope
    set?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    disconnect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    delete?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    connect?: KnowledgeChunkWhereUniqueInput | KnowledgeChunkWhereUniqueInput[]
    update?: KnowledgeChunkUpdateWithWhereUniqueWithoutFileInput | KnowledgeChunkUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: KnowledgeChunkUpdateManyWithWhereWithoutFileInput | KnowledgeChunkUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
  }

  export type KnowledgeCreateNestedOneWithoutKnowledgeChunksInput = {
    create?: XOR<KnowledgeCreateWithoutKnowledgeChunksInput, KnowledgeUncheckedCreateWithoutKnowledgeChunksInput>
    connectOrCreate?: KnowledgeCreateOrConnectWithoutKnowledgeChunksInput
    connect?: KnowledgeWhereUniqueInput
  }

  export type KnowledgeFileCreateNestedOneWithoutChunksInput = {
    create?: XOR<KnowledgeFileCreateWithoutChunksInput, KnowledgeFileUncheckedCreateWithoutChunksInput>
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutChunksInput
    connect?: KnowledgeFileWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type KnowledgeUpdateOneRequiredWithoutKnowledgeChunksNestedInput = {
    create?: XOR<KnowledgeCreateWithoutKnowledgeChunksInput, KnowledgeUncheckedCreateWithoutKnowledgeChunksInput>
    connectOrCreate?: KnowledgeCreateOrConnectWithoutKnowledgeChunksInput
    upsert?: KnowledgeUpsertWithoutKnowledgeChunksInput
    connect?: KnowledgeWhereUniqueInput
    update?: XOR<XOR<KnowledgeUpdateToOneWithWhereWithoutKnowledgeChunksInput, KnowledgeUpdateWithoutKnowledgeChunksInput>, KnowledgeUncheckedUpdateWithoutKnowledgeChunksInput>
  }

  export type KnowledgeFileUpdateOneWithoutChunksNestedInput = {
    create?: XOR<KnowledgeFileCreateWithoutChunksInput, KnowledgeFileUncheckedCreateWithoutChunksInput>
    connectOrCreate?: KnowledgeFileCreateOrConnectWithoutChunksInput
    upsert?: KnowledgeFileUpsertWithoutChunksInput
    disconnect?: KnowledgeFileWhereInput | boolean
    delete?: KnowledgeFileWhereInput | boolean
    connect?: KnowledgeFileWhereUniqueInput
    update?: XOR<XOR<KnowledgeFileUpdateToOneWithWhereWithoutChunksInput, KnowledgeFileUpdateWithoutChunksInput>, KnowledgeFileUncheckedUpdateWithoutChunksInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumProxyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyType | EnumProxyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyTypeFilter<$PrismaModel> | $Enums.ProxyType
  }

  export type NestedEnumProxyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProxyType | EnumProxyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProxyType[] | ListEnumProxyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProxyTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProxyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProxyTypeFilter<$PrismaModel>
    _max?: NestedEnumProxyTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCrawlerEngineFilter<$PrismaModel = never> = {
    equals?: $Enums.CrawlerEngine | EnumCrawlerEngineFieldRefInput<$PrismaModel>
    in?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumCrawlerEngineFilter<$PrismaModel> | $Enums.CrawlerEngine
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCrawlerEngineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CrawlerEngine | EnumCrawlerEngineFieldRefInput<$PrismaModel>
    in?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.CrawlerEngine[] | ListEnumCrawlerEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumCrawlerEngineWithAggregatesFilter<$PrismaModel> | $Enums.CrawlerEngine
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCrawlerEngineFilter<$PrismaModel>
    _max?: NestedEnumCrawlerEngineFilter<$PrismaModel>
  }

  export type NestedEnumSearchEngineKindFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchEngineKind | EnumSearchEngineKindFieldRefInput<$PrismaModel>
    in?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchEngineKindFilter<$PrismaModel> | $Enums.SearchEngineKind
  }

  export type NestedEnumSearchEngineKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SearchEngineKind | EnumSearchEngineKindFieldRefInput<$PrismaModel>
    in?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.SearchEngineKind[] | ListEnumSearchEngineKindFieldRefInput<$PrismaModel>
    not?: NestedEnumSearchEngineKindWithAggregatesFilter<$PrismaModel> | $Enums.SearchEngineKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSearchEngineKindFilter<$PrismaModel>
    _max?: NestedEnumSearchEngineKindFilter<$PrismaModel>
  }

  export type NestedEnumSocialPlatformFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformFilter<$PrismaModel> | $Enums.SocialPlatform
  }

  export type NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SocialPlatform | EnumSocialPlatformFieldRefInput<$PrismaModel>
    in?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    notIn?: $Enums.SocialPlatform[] | ListEnumSocialPlatformFieldRefInput<$PrismaModel>
    not?: NestedEnumSocialPlatformWithAggregatesFilter<$PrismaModel> | $Enums.SocialPlatform
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSocialPlatformFilter<$PrismaModel>
    _max?: NestedEnumSocialPlatformFilter<$PrismaModel>
  }

  export type NestedEnumQueryFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryFrequency | EnumQueryFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryFrequencyFilter<$PrismaModel> | $Enums.QueryFrequency
  }

  export type NestedEnumQueryFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueryFrequency | EnumQueryFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueryFrequency[] | ListEnumQueryFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumQueryFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.QueryFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueryFrequencyFilter<$PrismaModel>
    _max?: NestedEnumQueryFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumMaterialSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialSource | EnumMaterialSourceFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialSourceFilter<$PrismaModel> | $Enums.MaterialSource
  }

  export type NestedEnumMaterialSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaterialSource | EnumMaterialSourceFieldRefInput<$PrismaModel>
    in?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaterialSource[] | ListEnumMaterialSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumMaterialSourceWithAggregatesFilter<$PrismaModel> | $Enums.MaterialSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaterialSourceFilter<$PrismaModel>
    _max?: NestedEnumMaterialSourceFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type KeywordCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    queries?: QueryCreateNestedManyWithoutKeywordsInput
    contentKeywords?: ContentKeywordCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    queries?: QueryUncheckedCreateNestedManyWithoutKeywordsInput
    contentKeywords?: ContentKeywordUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutCategoryInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput>
  }

  export type KeywordCreateManyCategoryInputEnvelope = {
    data: KeywordCreateManyCategoryInput | KeywordCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type KeywordUpsertWithWhereUniqueWithoutCategoryInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutCategoryInput, KeywordUncheckedUpdateWithoutCategoryInput>
    create: XOR<KeywordCreateWithoutCategoryInput, KeywordUncheckedCreateWithoutCategoryInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutCategoryInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutCategoryInput, KeywordUncheckedUpdateWithoutCategoryInput>
  }

  export type KeywordUpdateManyWithWhereWithoutCategoryInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutCategoryInput>
  }

  export type KeywordScalarWhereInput = {
    AND?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    OR?: KeywordScalarWhereInput[]
    NOT?: KeywordScalarWhereInput | KeywordScalarWhereInput[]
    id?: StringFilter<"Keyword"> | string
    name?: StringFilter<"Keyword"> | string
    description?: StringNullableFilter<"Keyword"> | string | null
    lang?: StringNullableFilter<"Keyword"> | string | null
    categoryId?: StringNullableFilter<"Keyword"> | string | null
    includes?: StringNullableListFilter<"Keyword">
    excludes?: StringNullableListFilter<"Keyword">
    enableAiExpand?: BoolFilter<"Keyword"> | boolean
    synonyms?: StringNullableListFilter<"Keyword">
    active?: BoolFilter<"Keyword"> | boolean
    createdAt?: DateTimeFilter<"Keyword"> | Date | string
    updatedAt?: DateTimeFilter<"Keyword"> | Date | string
  }

  export type CategoryCreateWithoutKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutKeywordsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutKeywordsInput, CategoryUncheckedCreateWithoutKeywordsInput>
  }

  export type QueryCreateWithoutKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutKeywordsInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput>
  }

  export type ContentKeywordCreateWithoutKeywordInput = {
    id?: string
    content: ContentCreateNestedOneWithoutKeywordsInput
  }

  export type ContentKeywordUncheckedCreateWithoutKeywordInput = {
    id?: string
    contentId: string
  }

  export type ContentKeywordCreateOrConnectWithoutKeywordInput = {
    where: ContentKeywordWhereUniqueInput
    create: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput>
  }

  export type ContentKeywordCreateManyKeywordInputEnvelope = {
    data: ContentKeywordCreateManyKeywordInput | ContentKeywordCreateManyKeywordInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutKeywordsInput = {
    update: XOR<CategoryUpdateWithoutKeywordsInput, CategoryUncheckedUpdateWithoutKeywordsInput>
    create: XOR<CategoryCreateWithoutKeywordsInput, CategoryUncheckedCreateWithoutKeywordsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutKeywordsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutKeywordsInput, CategoryUncheckedUpdateWithoutKeywordsInput>
  }

  export type CategoryUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpsertWithWhereUniqueWithoutKeywordsInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutKeywordsInput, QueryUncheckedUpdateWithoutKeywordsInput>
    create: XOR<QueryCreateWithoutKeywordsInput, QueryUncheckedCreateWithoutKeywordsInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutKeywordsInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutKeywordsInput, QueryUncheckedUpdateWithoutKeywordsInput>
  }

  export type QueryUpdateManyWithWhereWithoutKeywordsInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutKeywordsInput>
  }

  export type QueryScalarWhereInput = {
    AND?: QueryScalarWhereInput | QueryScalarWhereInput[]
    OR?: QueryScalarWhereInput[]
    NOT?: QueryScalarWhereInput | QueryScalarWhereInput[]
    id?: StringFilter<"Query"> | string
    name?: StringFilter<"Query"> | string
    description?: StringNullableFilter<"Query"> | string | null
    enabled?: BoolFilter<"Query"> | boolean
    frequency?: EnumQueryFrequencyFilter<"Query"> | $Enums.QueryFrequency
    cronSchedule?: StringNullableFilter<"Query"> | string | null
    rules?: JsonNullableFilter<"Query">
    createdAt?: DateTimeFilter<"Query"> | Date | string
    updatedAt?: DateTimeFilter<"Query"> | Date | string
  }

  export type ContentKeywordUpsertWithWhereUniqueWithoutKeywordInput = {
    where: ContentKeywordWhereUniqueInput
    update: XOR<ContentKeywordUpdateWithoutKeywordInput, ContentKeywordUncheckedUpdateWithoutKeywordInput>
    create: XOR<ContentKeywordCreateWithoutKeywordInput, ContentKeywordUncheckedCreateWithoutKeywordInput>
  }

  export type ContentKeywordUpdateWithWhereUniqueWithoutKeywordInput = {
    where: ContentKeywordWhereUniqueInput
    data: XOR<ContentKeywordUpdateWithoutKeywordInput, ContentKeywordUncheckedUpdateWithoutKeywordInput>
  }

  export type ContentKeywordUpdateManyWithWhereWithoutKeywordInput = {
    where: ContentKeywordScalarWhereInput
    data: XOR<ContentKeywordUpdateManyMutationInput, ContentKeywordUncheckedUpdateManyWithoutKeywordInput>
  }

  export type ContentKeywordScalarWhereInput = {
    AND?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
    OR?: ContentKeywordScalarWhereInput[]
    NOT?: ContentKeywordScalarWhereInput | ContentKeywordScalarWhereInput[]
    id?: StringFilter<"ContentKeyword"> | string
    contentId?: StringFilter<"ContentKeyword"> | string
    keywordId?: StringFilter<"ContentKeyword"> | string
  }

  export type SourceCreateWithoutProxyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutProxyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutProxyInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput>
  }

  export type SourceCreateManyProxyInputEnvelope = {
    data: SourceCreateManyProxyInput | SourceCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type DarknetSourceConfigCreateWithoutProxyInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutDarknetInput
  }

  export type DarknetSourceConfigUncheckedCreateWithoutProxyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DarknetSourceConfigCreateOrConnectWithoutProxyInput = {
    where: DarknetSourceConfigWhereUniqueInput
    create: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type DarknetSourceConfigCreateManyProxyInputEnvelope = {
    data: DarknetSourceConfigCreateManyProxyInput | DarknetSourceConfigCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type WebSourceConfigCreateWithoutProxyInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutWebInput
  }

  export type WebSourceConfigUncheckedCreateWithoutProxyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebSourceConfigCreateOrConnectWithoutProxyInput = {
    where: WebSourceConfigWhereUniqueInput
    create: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type WebSourceConfigCreateManyProxyInputEnvelope = {
    data: WebSourceConfigCreateManyProxyInput | WebSourceConfigCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type SocialMediaSourceConfigCreateWithoutProxyInput = {
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutSocialInput
    credential?: CredentialCreateNestedOneWithoutSocialOverridesInput
  }

  export type SocialMediaSourceConfigUncheckedCreateWithoutProxyInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigCreateOrConnectWithoutProxyInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    create: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type SocialMediaSourceConfigCreateManyProxyInputEnvelope = {
    data: SocialMediaSourceConfigCreateManyProxyInput | SocialMediaSourceConfigCreateManyProxyInput[]
    skipDuplicates?: boolean
  }

  export type SourceUpsertWithWhereUniqueWithoutProxyInput = {
    where: SourceWhereUniqueInput
    update: XOR<SourceUpdateWithoutProxyInput, SourceUncheckedUpdateWithoutProxyInput>
    create: XOR<SourceCreateWithoutProxyInput, SourceUncheckedCreateWithoutProxyInput>
  }

  export type SourceUpdateWithWhereUniqueWithoutProxyInput = {
    where: SourceWhereUniqueInput
    data: XOR<SourceUpdateWithoutProxyInput, SourceUncheckedUpdateWithoutProxyInput>
  }

  export type SourceUpdateManyWithWhereWithoutProxyInput = {
    where: SourceScalarWhereInput
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyWithoutProxyInput>
  }

  export type SourceScalarWhereInput = {
    AND?: SourceScalarWhereInput | SourceScalarWhereInput[]
    OR?: SourceScalarWhereInput[]
    NOT?: SourceScalarWhereInput | SourceScalarWhereInput[]
    id?: StringFilter<"Source"> | string
    name?: StringFilter<"Source"> | string
    description?: StringNullableFilter<"Source"> | string | null
    type?: EnumSourceTypeFilter<"Source"> | $Enums.SourceType
    active?: BoolFilter<"Source"> | boolean
    rateLimit?: IntNullableFilter<"Source"> | number | null
    lastFetchedAt?: DateTimeNullableFilter<"Source"> | Date | string | null
    lastStatus?: StringNullableFilter<"Source"> | string | null
    proxyId?: StringNullableFilter<"Source"> | string | null
    credentialId?: StringNullableFilter<"Source"> | string | null
    createdAt?: DateTimeFilter<"Source"> | Date | string
    updatedAt?: DateTimeFilter<"Source"> | Date | string
  }

  export type DarknetSourceConfigUpsertWithWhereUniqueWithoutProxyInput = {
    where: DarknetSourceConfigWhereUniqueInput
    update: XOR<DarknetSourceConfigUpdateWithoutProxyInput, DarknetSourceConfigUncheckedUpdateWithoutProxyInput>
    create: XOR<DarknetSourceConfigCreateWithoutProxyInput, DarknetSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type DarknetSourceConfigUpdateWithWhereUniqueWithoutProxyInput = {
    where: DarknetSourceConfigWhereUniqueInput
    data: XOR<DarknetSourceConfigUpdateWithoutProxyInput, DarknetSourceConfigUncheckedUpdateWithoutProxyInput>
  }

  export type DarknetSourceConfigUpdateManyWithWhereWithoutProxyInput = {
    where: DarknetSourceConfigScalarWhereInput
    data: XOR<DarknetSourceConfigUpdateManyMutationInput, DarknetSourceConfigUncheckedUpdateManyWithoutProxyInput>
  }

  export type DarknetSourceConfigScalarWhereInput = {
    AND?: DarknetSourceConfigScalarWhereInput | DarknetSourceConfigScalarWhereInput[]
    OR?: DarknetSourceConfigScalarWhereInput[]
    NOT?: DarknetSourceConfigScalarWhereInput | DarknetSourceConfigScalarWhereInput[]
    sourceId?: StringFilter<"DarknetSourceConfig"> | string
    url?: StringFilter<"DarknetSourceConfig"> | string
    headers?: JsonNullableFilter<"DarknetSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"DarknetSourceConfig"> | $Enums.CrawlerEngine
    proxyId?: StringFilter<"DarknetSourceConfig"> | string
    render?: BoolFilter<"DarknetSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"DarknetSourceConfig">
    createdAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"DarknetSourceConfig"> | Date | string
  }

  export type WebSourceConfigUpsertWithWhereUniqueWithoutProxyInput = {
    where: WebSourceConfigWhereUniqueInput
    update: XOR<WebSourceConfigUpdateWithoutProxyInput, WebSourceConfigUncheckedUpdateWithoutProxyInput>
    create: XOR<WebSourceConfigCreateWithoutProxyInput, WebSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type WebSourceConfigUpdateWithWhereUniqueWithoutProxyInput = {
    where: WebSourceConfigWhereUniqueInput
    data: XOR<WebSourceConfigUpdateWithoutProxyInput, WebSourceConfigUncheckedUpdateWithoutProxyInput>
  }

  export type WebSourceConfigUpdateManyWithWhereWithoutProxyInput = {
    where: WebSourceConfigScalarWhereInput
    data: XOR<WebSourceConfigUpdateManyMutationInput, WebSourceConfigUncheckedUpdateManyWithoutProxyInput>
  }

  export type WebSourceConfigScalarWhereInput = {
    AND?: WebSourceConfigScalarWhereInput | WebSourceConfigScalarWhereInput[]
    OR?: WebSourceConfigScalarWhereInput[]
    NOT?: WebSourceConfigScalarWhereInput | WebSourceConfigScalarWhereInput[]
    sourceId?: StringFilter<"WebSourceConfig"> | string
    url?: StringFilter<"WebSourceConfig"> | string
    headers?: JsonNullableFilter<"WebSourceConfig">
    crawlerEngine?: EnumCrawlerEngineFilter<"WebSourceConfig"> | $Enums.CrawlerEngine
    render?: BoolFilter<"WebSourceConfig"> | boolean
    parseRules?: JsonNullableFilter<"WebSourceConfig">
    robotsRespect?: BoolFilter<"WebSourceConfig"> | boolean
    proxyId?: StringNullableFilter<"WebSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"WebSourceConfig"> | Date | string
  }

  export type SocialMediaSourceConfigUpsertWithWhereUniqueWithoutProxyInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    update: XOR<SocialMediaSourceConfigUpdateWithoutProxyInput, SocialMediaSourceConfigUncheckedUpdateWithoutProxyInput>
    create: XOR<SocialMediaSourceConfigCreateWithoutProxyInput, SocialMediaSourceConfigUncheckedCreateWithoutProxyInput>
  }

  export type SocialMediaSourceConfigUpdateWithWhereUniqueWithoutProxyInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    data: XOR<SocialMediaSourceConfigUpdateWithoutProxyInput, SocialMediaSourceConfigUncheckedUpdateWithoutProxyInput>
  }

  export type SocialMediaSourceConfigUpdateManyWithWhereWithoutProxyInput = {
    where: SocialMediaSourceConfigScalarWhereInput
    data: XOR<SocialMediaSourceConfigUpdateManyMutationInput, SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyInput>
  }

  export type SocialMediaSourceConfigScalarWhereInput = {
    AND?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
    OR?: SocialMediaSourceConfigScalarWhereInput[]
    NOT?: SocialMediaSourceConfigScalarWhereInput | SocialMediaSourceConfigScalarWhereInput[]
    sourceId?: StringFilter<"SocialMediaSourceConfig"> | string
    platform?: EnumSocialPlatformFilter<"SocialMediaSourceConfig"> | $Enums.SocialPlatform
    config?: JsonFilter<"SocialMediaSourceConfig">
    credentialId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    proxyId?: StringNullableFilter<"SocialMediaSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaSourceConfig"> | Date | string
  }

  export type SourceCreateWithoutCredentialInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutCredentialInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutCredentialInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput>
  }

  export type SourceCreateManyCredentialInputEnvelope = {
    data: SourceCreateManyCredentialInput | SourceCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type SocialMediaSourceConfigCreateWithoutCredentialInput = {
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutSocialInput
    proxy?: ProxyCreateNestedOneWithoutSocialOverridesInput
  }

  export type SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigCreateOrConnectWithoutCredentialInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    create: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput>
  }

  export type SocialMediaSourceConfigCreateManyCredentialInputEnvelope = {
    data: SocialMediaSourceConfigCreateManyCredentialInput | SocialMediaSourceConfigCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type SearchEngineSourceConfigCreateWithoutCredentialInput = {
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    source: SourceCreateNestedOneWithoutSearchInput
  }

  export type SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput = {
    sourceId: string
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchEngineSourceConfigCreateOrConnectWithoutCredentialInput = {
    where: SearchEngineSourceConfigWhereUniqueInput
    create: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput>
  }

  export type SearchEngineSourceConfigCreateManyCredentialInputEnvelope = {
    data: SearchEngineSourceConfigCreateManyCredentialInput | SearchEngineSourceConfigCreateManyCredentialInput[]
    skipDuplicates?: boolean
  }

  export type SourceUpsertWithWhereUniqueWithoutCredentialInput = {
    where: SourceWhereUniqueInput
    update: XOR<SourceUpdateWithoutCredentialInput, SourceUncheckedUpdateWithoutCredentialInput>
    create: XOR<SourceCreateWithoutCredentialInput, SourceUncheckedCreateWithoutCredentialInput>
  }

  export type SourceUpdateWithWhereUniqueWithoutCredentialInput = {
    where: SourceWhereUniqueInput
    data: XOR<SourceUpdateWithoutCredentialInput, SourceUncheckedUpdateWithoutCredentialInput>
  }

  export type SourceUpdateManyWithWhereWithoutCredentialInput = {
    where: SourceScalarWhereInput
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyWithoutCredentialInput>
  }

  export type SocialMediaSourceConfigUpsertWithWhereUniqueWithoutCredentialInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    update: XOR<SocialMediaSourceConfigUpdateWithoutCredentialInput, SocialMediaSourceConfigUncheckedUpdateWithoutCredentialInput>
    create: XOR<SocialMediaSourceConfigCreateWithoutCredentialInput, SocialMediaSourceConfigUncheckedCreateWithoutCredentialInput>
  }

  export type SocialMediaSourceConfigUpdateWithWhereUniqueWithoutCredentialInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    data: XOR<SocialMediaSourceConfigUpdateWithoutCredentialInput, SocialMediaSourceConfigUncheckedUpdateWithoutCredentialInput>
  }

  export type SocialMediaSourceConfigUpdateManyWithWhereWithoutCredentialInput = {
    where: SocialMediaSourceConfigScalarWhereInput
    data: XOR<SocialMediaSourceConfigUpdateManyMutationInput, SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialInput>
  }

  export type SearchEngineSourceConfigUpsertWithWhereUniqueWithoutCredentialInput = {
    where: SearchEngineSourceConfigWhereUniqueInput
    update: XOR<SearchEngineSourceConfigUpdateWithoutCredentialInput, SearchEngineSourceConfigUncheckedUpdateWithoutCredentialInput>
    create: XOR<SearchEngineSourceConfigCreateWithoutCredentialInput, SearchEngineSourceConfigUncheckedCreateWithoutCredentialInput>
  }

  export type SearchEngineSourceConfigUpdateWithWhereUniqueWithoutCredentialInput = {
    where: SearchEngineSourceConfigWhereUniqueInput
    data: XOR<SearchEngineSourceConfigUpdateWithoutCredentialInput, SearchEngineSourceConfigUncheckedUpdateWithoutCredentialInput>
  }

  export type SearchEngineSourceConfigUpdateManyWithWhereWithoutCredentialInput = {
    where: SearchEngineSourceConfigScalarWhereInput
    data: XOR<SearchEngineSourceConfigUpdateManyMutationInput, SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialInput>
  }

  export type SearchEngineSourceConfigScalarWhereInput = {
    AND?: SearchEngineSourceConfigScalarWhereInput | SearchEngineSourceConfigScalarWhereInput[]
    OR?: SearchEngineSourceConfigScalarWhereInput[]
    NOT?: SearchEngineSourceConfigScalarWhereInput | SearchEngineSourceConfigScalarWhereInput[]
    sourceId?: StringFilter<"SearchEngineSourceConfig"> | string
    engine?: EnumSearchEngineKindFilter<"SearchEngineSourceConfig"> | $Enums.SearchEngineKind
    query?: StringFilter<"SearchEngineSourceConfig"> | string
    region?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    lang?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    apiEndpoint?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    options?: JsonNullableFilter<"SearchEngineSourceConfig">
    credentialId?: StringNullableFilter<"SearchEngineSourceConfig"> | string | null
    createdAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SearchEngineSourceConfig"> | Date | string
  }

  export type ProxyCreateWithoutSourcesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    darknetOverrides?: DarknetSourceConfigCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutProxyInput
  }

  export type ProxyUncheckedCreateWithoutSourcesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    darknetOverrides?: DarknetSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutProxyInput
  }

  export type ProxyCreateOrConnectWithoutSourcesInput = {
    where: ProxyWhereUniqueInput
    create: XOR<ProxyCreateWithoutSourcesInput, ProxyUncheckedCreateWithoutSourcesInput>
  }

  export type CredentialCreateWithoutSourcesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutSourcesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutSourcesInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutSourcesInput, CredentialUncheckedCreateWithoutSourcesInput>
  }

  export type WebSourceConfigCreateWithoutSourceInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutWebOverridesInput
  }

  export type WebSourceConfigUncheckedCreateWithoutSourceInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebSourceConfigCreateOrConnectWithoutSourceInput = {
    where: WebSourceConfigWhereUniqueInput
    create: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
  }

  export type DarknetSourceConfigCreateWithoutSourceInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy: ProxyCreateNestedOneWithoutDarknetOverridesInput
  }

  export type DarknetSourceConfigUncheckedCreateWithoutSourceInput = {
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    proxyId: string
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DarknetSourceConfigCreateOrConnectWithoutSourceInput = {
    where: DarknetSourceConfigWhereUniqueInput
    create: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
  }

  export type SearchEngineSourceConfigCreateWithoutSourceInput = {
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    credential?: CredentialCreateNestedOneWithoutSearchOverridesInput
  }

  export type SearchEngineSourceConfigUncheckedCreateWithoutSourceInput = {
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchEngineSourceConfigCreateOrConnectWithoutSourceInput = {
    where: SearchEngineSourceConfigWhereUniqueInput
    create: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
  }

  export type SocialMediaSourceConfigCreateWithoutSourceInput = {
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    credential?: CredentialCreateNestedOneWithoutSocialOverridesInput
    proxy?: ProxyCreateNestedOneWithoutSocialOverridesInput
  }

  export type SocialMediaSourceConfigUncheckedCreateWithoutSourceInput = {
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigCreateOrConnectWithoutSourceInput = {
    where: SocialMediaSourceConfigWhereUniqueInput
    create: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
  }

  export type QueryCreateWithoutSourcesInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunCreateNestedManyWithoutQueryInput
  }

  export type QueryUncheckedCreateWithoutSourcesInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordUncheckedCreateNestedManyWithoutQueriesInput
    queryRuns?: QueryRunUncheckedCreateNestedManyWithoutQueryInput
  }

  export type QueryCreateOrConnectWithoutSourcesInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput>
  }

  export type ProxyUpsertWithoutSourcesInput = {
    update: XOR<ProxyUpdateWithoutSourcesInput, ProxyUncheckedUpdateWithoutSourcesInput>
    create: XOR<ProxyCreateWithoutSourcesInput, ProxyUncheckedCreateWithoutSourcesInput>
    where?: ProxyWhereInput
  }

  export type ProxyUpdateToOneWithWhereWithoutSourcesInput = {
    where?: ProxyWhereInput
    data: XOR<ProxyUpdateWithoutSourcesInput, ProxyUncheckedUpdateWithoutSourcesInput>
  }

  export type ProxyUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    darknetOverrides?: DarknetSourceConfigUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    darknetOverrides?: DarknetSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
  }

  export type CredentialUpsertWithoutSourcesInput = {
    update: XOR<CredentialUpdateWithoutSourcesInput, CredentialUncheckedUpdateWithoutSourcesInput>
    create: XOR<CredentialCreateWithoutSourcesInput, CredentialUncheckedCreateWithoutSourcesInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutSourcesInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutSourcesInput, CredentialUncheckedUpdateWithoutSourcesInput>
  }

  export type CredentialUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type WebSourceConfigUpsertWithoutSourceInput = {
    update: XOR<WebSourceConfigUpdateWithoutSourceInput, WebSourceConfigUncheckedUpdateWithoutSourceInput>
    create: XOR<WebSourceConfigCreateWithoutSourceInput, WebSourceConfigUncheckedCreateWithoutSourceInput>
    where?: WebSourceConfigWhereInput
  }

  export type WebSourceConfigUpdateToOneWithWhereWithoutSourceInput = {
    where?: WebSourceConfigWhereInput
    data: XOR<WebSourceConfigUpdateWithoutSourceInput, WebSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type WebSourceConfigUpdateWithoutSourceInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutWebOverridesNestedInput
  }

  export type WebSourceConfigUncheckedUpdateWithoutSourceInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigUpsertWithoutSourceInput = {
    update: XOR<DarknetSourceConfigUpdateWithoutSourceInput, DarknetSourceConfigUncheckedUpdateWithoutSourceInput>
    create: XOR<DarknetSourceConfigCreateWithoutSourceInput, DarknetSourceConfigUncheckedCreateWithoutSourceInput>
    where?: DarknetSourceConfigWhereInput
  }

  export type DarknetSourceConfigUpdateToOneWithWhereWithoutSourceInput = {
    where?: DarknetSourceConfigWhereInput
    data: XOR<DarknetSourceConfigUpdateWithoutSourceInput, DarknetSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type DarknetSourceConfigUpdateWithoutSourceInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneRequiredWithoutDarknetOverridesNestedInput
  }

  export type DarknetSourceConfigUncheckedUpdateWithoutSourceInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    proxyId?: StringFieldUpdateOperationsInput | string
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigUpsertWithoutSourceInput = {
    update: XOR<SearchEngineSourceConfigUpdateWithoutSourceInput, SearchEngineSourceConfigUncheckedUpdateWithoutSourceInput>
    create: XOR<SearchEngineSourceConfigCreateWithoutSourceInput, SearchEngineSourceConfigUncheckedCreateWithoutSourceInput>
    where?: SearchEngineSourceConfigWhereInput
  }

  export type SearchEngineSourceConfigUpdateToOneWithWhereWithoutSourceInput = {
    where?: SearchEngineSourceConfigWhereInput
    data: XOR<SearchEngineSourceConfigUpdateWithoutSourceInput, SearchEngineSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SearchEngineSourceConfigUpdateWithoutSourceInput = {
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: CredentialUpdateOneWithoutSearchOverridesNestedInput
  }

  export type SearchEngineSourceConfigUncheckedUpdateWithoutSourceInput = {
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUpsertWithoutSourceInput = {
    update: XOR<SocialMediaSourceConfigUpdateWithoutSourceInput, SocialMediaSourceConfigUncheckedUpdateWithoutSourceInput>
    create: XOR<SocialMediaSourceConfigCreateWithoutSourceInput, SocialMediaSourceConfigUncheckedCreateWithoutSourceInput>
    where?: SocialMediaSourceConfigWhereInput
  }

  export type SocialMediaSourceConfigUpdateToOneWithWhereWithoutSourceInput = {
    where?: SocialMediaSourceConfigWhereInput
    data: XOR<SocialMediaSourceConfigUpdateWithoutSourceInput, SocialMediaSourceConfigUncheckedUpdateWithoutSourceInput>
  }

  export type SocialMediaSourceConfigUpdateWithoutSourceInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: CredentialUpdateOneWithoutSocialOverridesNestedInput
    proxy?: ProxyUpdateOneWithoutSocialOverridesNestedInput
  }

  export type SocialMediaSourceConfigUncheckedUpdateWithoutSourceInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpsertWithWhereUniqueWithoutSourcesInput = {
    where: QueryWhereUniqueInput
    update: XOR<QueryUpdateWithoutSourcesInput, QueryUncheckedUpdateWithoutSourcesInput>
    create: XOR<QueryCreateWithoutSourcesInput, QueryUncheckedCreateWithoutSourcesInput>
  }

  export type QueryUpdateWithWhereUniqueWithoutSourcesInput = {
    where: QueryWhereUniqueInput
    data: XOR<QueryUpdateWithoutSourcesInput, QueryUncheckedUpdateWithoutSourcesInput>
  }

  export type QueryUpdateManyWithWhereWithoutSourcesInput = {
    where: QueryScalarWhereInput
    data: XOR<QueryUpdateManyMutationInput, QueryUncheckedUpdateManyWithoutSourcesInput>
  }

  export type SourceCreateWithoutWebInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutWebInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutWebInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutWebInput, SourceUncheckedCreateWithoutWebInput>
  }

  export type ProxyCreateWithoutWebOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutProxyInput
  }

  export type ProxyUncheckedCreateWithoutWebOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutProxyInput
  }

  export type ProxyCreateOrConnectWithoutWebOverridesInput = {
    where: ProxyWhereUniqueInput
    create: XOR<ProxyCreateWithoutWebOverridesInput, ProxyUncheckedCreateWithoutWebOverridesInput>
  }

  export type SourceUpsertWithoutWebInput = {
    update: XOR<SourceUpdateWithoutWebInput, SourceUncheckedUpdateWithoutWebInput>
    create: XOR<SourceCreateWithoutWebInput, SourceUncheckedCreateWithoutWebInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutWebInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutWebInput, SourceUncheckedUpdateWithoutWebInput>
  }

  export type SourceUpdateWithoutWebInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutWebInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type ProxyUpsertWithoutWebOverridesInput = {
    update: XOR<ProxyUpdateWithoutWebOverridesInput, ProxyUncheckedUpdateWithoutWebOverridesInput>
    create: XOR<ProxyCreateWithoutWebOverridesInput, ProxyUncheckedCreateWithoutWebOverridesInput>
    where?: ProxyWhereInput
  }

  export type ProxyUpdateToOneWithWhereWithoutWebOverridesInput = {
    where?: ProxyWhereInput
    data: XOR<ProxyUpdateWithoutWebOverridesInput, ProxyUncheckedUpdateWithoutWebOverridesInput>
  }

  export type ProxyUpdateWithoutWebOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateWithoutWebOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
  }

  export type SourceCreateWithoutDarknetInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutDarknetInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutDarknetInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutDarknetInput, SourceUncheckedCreateWithoutDarknetInput>
  }

  export type ProxyCreateWithoutDarknetOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutProxyInput
  }

  export type ProxyUncheckedCreateWithoutDarknetOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutProxyInput
  }

  export type ProxyCreateOrConnectWithoutDarknetOverridesInput = {
    where: ProxyWhereUniqueInput
    create: XOR<ProxyCreateWithoutDarknetOverridesInput, ProxyUncheckedCreateWithoutDarknetOverridesInput>
  }

  export type SourceUpsertWithoutDarknetInput = {
    update: XOR<SourceUpdateWithoutDarknetInput, SourceUncheckedUpdateWithoutDarknetInput>
    create: XOR<SourceCreateWithoutDarknetInput, SourceUncheckedCreateWithoutDarknetInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutDarknetInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutDarknetInput, SourceUncheckedUpdateWithoutDarknetInput>
  }

  export type SourceUpdateWithoutDarknetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutDarknetInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type ProxyUpsertWithoutDarknetOverridesInput = {
    update: XOR<ProxyUpdateWithoutDarknetOverridesInput, ProxyUncheckedUpdateWithoutDarknetOverridesInput>
    create: XOR<ProxyCreateWithoutDarknetOverridesInput, ProxyUncheckedCreateWithoutDarknetOverridesInput>
    where?: ProxyWhereInput
  }

  export type ProxyUpdateToOneWithWhereWithoutDarknetOverridesInput = {
    where?: ProxyWhereInput
    data: XOR<ProxyUpdateWithoutDarknetOverridesInput, ProxyUncheckedUpdateWithoutDarknetOverridesInput>
  }

  export type ProxyUpdateWithoutDarknetOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateWithoutDarknetOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
  }

  export type SourceCreateWithoutSearchInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutSearchInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutSearchInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutSearchInput, SourceUncheckedCreateWithoutSearchInput>
  }

  export type CredentialCreateWithoutSearchOverridesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutCredentialInput
    socialOverrides?: SocialMediaSourceConfigCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutSearchOverridesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutCredentialInput
    socialOverrides?: SocialMediaSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutSearchOverridesInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutSearchOverridesInput, CredentialUncheckedCreateWithoutSearchOverridesInput>
  }

  export type SourceUpsertWithoutSearchInput = {
    update: XOR<SourceUpdateWithoutSearchInput, SourceUncheckedUpdateWithoutSearchInput>
    create: XOR<SourceCreateWithoutSearchInput, SourceUncheckedCreateWithoutSearchInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutSearchInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutSearchInput, SourceUncheckedUpdateWithoutSearchInput>
  }

  export type SourceUpdateWithoutSearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutSearchInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type CredentialUpsertWithoutSearchOverridesInput = {
    update: XOR<CredentialUpdateWithoutSearchOverridesInput, CredentialUncheckedUpdateWithoutSearchOverridesInput>
    create: XOR<CredentialCreateWithoutSearchOverridesInput, CredentialUncheckedCreateWithoutSearchOverridesInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutSearchOverridesInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutSearchOverridesInput, CredentialUncheckedUpdateWithoutSearchOverridesInput>
  }

  export type CredentialUpdateWithoutSearchOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutCredentialNestedInput
    socialOverrides?: SocialMediaSourceConfigUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutSearchOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutCredentialNestedInput
    socialOverrides?: SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type SourceCreateWithoutSocialInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    queries?: QueryCreateNestedManyWithoutSourcesInput
  }

  export type SourceUncheckedCreateWithoutSocialInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    queries?: QueryUncheckedCreateNestedManyWithoutSourcesInput
  }

  export type SourceCreateOrConnectWithoutSocialInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutSocialInput, SourceUncheckedCreateWithoutSocialInput>
  }

  export type CredentialCreateWithoutSocialOverridesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigCreateNestedManyWithoutCredentialInput
  }

  export type CredentialUncheckedCreateWithoutSocialOverridesInput = {
    id?: string
    name: string
    kind: string
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutCredentialInput
    searchOverrides?: SearchEngineSourceConfigUncheckedCreateNestedManyWithoutCredentialInput
  }

  export type CredentialCreateOrConnectWithoutSocialOverridesInput = {
    where: CredentialWhereUniqueInput
    create: XOR<CredentialCreateWithoutSocialOverridesInput, CredentialUncheckedCreateWithoutSocialOverridesInput>
  }

  export type ProxyCreateWithoutSocialOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigCreateNestedManyWithoutProxyInput
  }

  export type ProxyUncheckedCreateWithoutSocialOverridesInput = {
    id?: string
    name: string
    type: $Enums.ProxyType
    url: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sources?: SourceUncheckedCreateNestedManyWithoutProxyInput
    darknetOverrides?: DarknetSourceConfigUncheckedCreateNestedManyWithoutProxyInput
    webOverrides?: WebSourceConfigUncheckedCreateNestedManyWithoutProxyInput
  }

  export type ProxyCreateOrConnectWithoutSocialOverridesInput = {
    where: ProxyWhereUniqueInput
    create: XOR<ProxyCreateWithoutSocialOverridesInput, ProxyUncheckedCreateWithoutSocialOverridesInput>
  }

  export type SourceUpsertWithoutSocialInput = {
    update: XOR<SourceUpdateWithoutSocialInput, SourceUncheckedUpdateWithoutSocialInput>
    create: XOR<SourceCreateWithoutSocialInput, SourceUncheckedCreateWithoutSocialInput>
    where?: SourceWhereInput
  }

  export type SourceUpdateToOneWithWhereWithoutSocialInput = {
    where?: SourceWhereInput
    data: XOR<SourceUpdateWithoutSocialInput, SourceUncheckedUpdateWithoutSocialInput>
  }

  export type SourceUpdateWithoutSocialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutSocialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type CredentialUpsertWithoutSocialOverridesInput = {
    update: XOR<CredentialUpdateWithoutSocialOverridesInput, CredentialUncheckedUpdateWithoutSocialOverridesInput>
    create: XOR<CredentialCreateWithoutSocialOverridesInput, CredentialUncheckedCreateWithoutSocialOverridesInput>
    where?: CredentialWhereInput
  }

  export type CredentialUpdateToOneWithWhereWithoutSocialOverridesInput = {
    where?: CredentialWhereInput
    data: XOR<CredentialUpdateWithoutSocialOverridesInput, CredentialUncheckedUpdateWithoutSocialOverridesInput>
  }

  export type CredentialUpdateWithoutSocialOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUpdateManyWithoutCredentialNestedInput
  }

  export type CredentialUncheckedUpdateWithoutSocialOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    kind?: StringFieldUpdateOperationsInput | string
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutCredentialNestedInput
    searchOverrides?: SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialNestedInput
  }

  export type ProxyUpsertWithoutSocialOverridesInput = {
    update: XOR<ProxyUpdateWithoutSocialOverridesInput, ProxyUncheckedUpdateWithoutSocialOverridesInput>
    create: XOR<ProxyCreateWithoutSocialOverridesInput, ProxyUncheckedCreateWithoutSocialOverridesInput>
    where?: ProxyWhereInput
  }

  export type ProxyUpdateToOneWithWhereWithoutSocialOverridesInput = {
    where?: ProxyWhereInput
    data: XOR<ProxyUpdateWithoutSocialOverridesInput, ProxyUncheckedUpdateWithoutSocialOverridesInput>
  }

  export type ProxyUpdateWithoutSocialOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUpdateManyWithoutProxyNestedInput
  }

  export type ProxyUncheckedUpdateWithoutSocialOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumProxyTypeFieldUpdateOperationsInput | $Enums.ProxyType
    url?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutProxyNestedInput
    darknetOverrides?: DarknetSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
    webOverrides?: WebSourceConfigUncheckedUpdateManyWithoutProxyNestedInput
  }

  export type KeywordCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutKeywordsInput
    contentKeywords?: ContentKeywordCreateNestedManyWithoutKeywordInput
  }

  export type KeywordUncheckedCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    categoryId?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contentKeywords?: ContentKeywordUncheckedCreateNestedManyWithoutKeywordInput
  }

  export type KeywordCreateOrConnectWithoutQueriesInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput>
  }

  export type SourceCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    proxy?: ProxyCreateNestedOneWithoutSourcesInput
    credential?: CredentialCreateNestedOneWithoutSourcesInput
    web?: WebSourceConfigCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigCreateNestedOneWithoutSourceInput
  }

  export type SourceUncheckedCreateWithoutQueriesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    web?: WebSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    darknet?: DarknetSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    search?: SearchEngineSourceConfigUncheckedCreateNestedOneWithoutSourceInput
    social?: SocialMediaSourceConfigUncheckedCreateNestedOneWithoutSourceInput
  }

  export type SourceCreateOrConnectWithoutQueriesInput = {
    where: SourceWhereUniqueInput
    create: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput>
  }

  export type QueryRunCreateWithoutQueryInput = {
    id?: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TaskEventCreateNestedManyWithoutRunInput
  }

  export type QueryRunUncheckedCreateWithoutQueryInput = {
    id?: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    events?: TaskEventUncheckedCreateNestedManyWithoutRunInput
  }

  export type QueryRunCreateOrConnectWithoutQueryInput = {
    where: QueryRunWhereUniqueInput
    create: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput>
  }

  export type QueryRunCreateManyQueryInputEnvelope = {
    data: QueryRunCreateManyQueryInput | QueryRunCreateManyQueryInput[]
    skipDuplicates?: boolean
  }

  export type KeywordUpsertWithWhereUniqueWithoutQueriesInput = {
    where: KeywordWhereUniqueInput
    update: XOR<KeywordUpdateWithoutQueriesInput, KeywordUncheckedUpdateWithoutQueriesInput>
    create: XOR<KeywordCreateWithoutQueriesInput, KeywordUncheckedCreateWithoutQueriesInput>
  }

  export type KeywordUpdateWithWhereUniqueWithoutQueriesInput = {
    where: KeywordWhereUniqueInput
    data: XOR<KeywordUpdateWithoutQueriesInput, KeywordUncheckedUpdateWithoutQueriesInput>
  }

  export type KeywordUpdateManyWithWhereWithoutQueriesInput = {
    where: KeywordScalarWhereInput
    data: XOR<KeywordUpdateManyMutationInput, KeywordUncheckedUpdateManyWithoutQueriesInput>
  }

  export type SourceUpsertWithWhereUniqueWithoutQueriesInput = {
    where: SourceWhereUniqueInput
    update: XOR<SourceUpdateWithoutQueriesInput, SourceUncheckedUpdateWithoutQueriesInput>
    create: XOR<SourceCreateWithoutQueriesInput, SourceUncheckedCreateWithoutQueriesInput>
  }

  export type SourceUpdateWithWhereUniqueWithoutQueriesInput = {
    where: SourceWhereUniqueInput
    data: XOR<SourceUpdateWithoutQueriesInput, SourceUncheckedUpdateWithoutQueriesInput>
  }

  export type SourceUpdateManyWithWhereWithoutQueriesInput = {
    where: SourceScalarWhereInput
    data: XOR<SourceUpdateManyMutationInput, SourceUncheckedUpdateManyWithoutQueriesInput>
  }

  export type QueryRunUpsertWithWhereUniqueWithoutQueryInput = {
    where: QueryRunWhereUniqueInput
    update: XOR<QueryRunUpdateWithoutQueryInput, QueryRunUncheckedUpdateWithoutQueryInput>
    create: XOR<QueryRunCreateWithoutQueryInput, QueryRunUncheckedCreateWithoutQueryInput>
  }

  export type QueryRunUpdateWithWhereUniqueWithoutQueryInput = {
    where: QueryRunWhereUniqueInput
    data: XOR<QueryRunUpdateWithoutQueryInput, QueryRunUncheckedUpdateWithoutQueryInput>
  }

  export type QueryRunUpdateManyWithWhereWithoutQueryInput = {
    where: QueryRunScalarWhereInput
    data: XOR<QueryRunUpdateManyMutationInput, QueryRunUncheckedUpdateManyWithoutQueryInput>
  }

  export type QueryRunScalarWhereInput = {
    AND?: QueryRunScalarWhereInput | QueryRunScalarWhereInput[]
    OR?: QueryRunScalarWhereInput[]
    NOT?: QueryRunScalarWhereInput | QueryRunScalarWhereInput[]
    id?: StringFilter<"QueryRun"> | string
    queryId?: StringFilter<"QueryRun"> | string
    status?: EnumTaskStatusFilter<"QueryRun"> | $Enums.TaskStatus
    progress?: IntFilter<"QueryRun"> | number
    error?: StringNullableFilter<"QueryRun"> | string | null
    startedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    finishedAt?: DateTimeNullableFilter<"QueryRun"> | Date | string | null
    meta?: JsonNullableFilter<"QueryRun">
    createdAt?: DateTimeFilter<"QueryRun"> | Date | string
    updatedAt?: DateTimeFilter<"QueryRun"> | Date | string
  }

  export type QueryCreateWithoutQueryRunsInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordCreateNestedManyWithoutQueriesInput
    sources?: SourceCreateNestedManyWithoutQueriesInput
  }

  export type QueryUncheckedCreateWithoutQueryRunsInput = {
    id?: string
    name: string
    description?: string | null
    enabled?: boolean
    frequency?: $Enums.QueryFrequency
    cronSchedule?: string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: KeywordUncheckedCreateNestedManyWithoutQueriesInput
    sources?: SourceUncheckedCreateNestedManyWithoutQueriesInput
  }

  export type QueryCreateOrConnectWithoutQueryRunsInput = {
    where: QueryWhereUniqueInput
    create: XOR<QueryCreateWithoutQueryRunsInput, QueryUncheckedCreateWithoutQueryRunsInput>
  }

  export type TaskEventCreateWithoutRunInput = {
    id?: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUncheckedCreateWithoutRunInput = {
    id?: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventCreateOrConnectWithoutRunInput = {
    where: TaskEventWhereUniqueInput
    create: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput>
  }

  export type TaskEventCreateManyRunInputEnvelope = {
    data: TaskEventCreateManyRunInput | TaskEventCreateManyRunInput[]
    skipDuplicates?: boolean
  }

  export type QueryUpsertWithoutQueryRunsInput = {
    update: XOR<QueryUpdateWithoutQueryRunsInput, QueryUncheckedUpdateWithoutQueryRunsInput>
    create: XOR<QueryCreateWithoutQueryRunsInput, QueryUncheckedCreateWithoutQueryRunsInput>
    where?: QueryWhereInput
  }

  export type QueryUpdateToOneWithWhereWithoutQueryRunsInput = {
    where?: QueryWhereInput
    data: XOR<QueryUpdateWithoutQueryRunsInput, QueryUncheckedUpdateWithoutQueryRunsInput>
  }

  export type QueryUpdateWithoutQueryRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUpdateManyWithoutQueriesNestedInput
    sources?: SourceUpdateManyWithoutQueriesNestedInput
  }

  export type QueryUncheckedUpdateWithoutQueryRunsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUncheckedUpdateManyWithoutQueriesNestedInput
    sources?: SourceUncheckedUpdateManyWithoutQueriesNestedInput
  }

  export type TaskEventUpsertWithWhereUniqueWithoutRunInput = {
    where: TaskEventWhereUniqueInput
    update: XOR<TaskEventUpdateWithoutRunInput, TaskEventUncheckedUpdateWithoutRunInput>
    create: XOR<TaskEventCreateWithoutRunInput, TaskEventUncheckedCreateWithoutRunInput>
  }

  export type TaskEventUpdateWithWhereUniqueWithoutRunInput = {
    where: TaskEventWhereUniqueInput
    data: XOR<TaskEventUpdateWithoutRunInput, TaskEventUncheckedUpdateWithoutRunInput>
  }

  export type TaskEventUpdateManyWithWhereWithoutRunInput = {
    where: TaskEventScalarWhereInput
    data: XOR<TaskEventUpdateManyMutationInput, TaskEventUncheckedUpdateManyWithoutRunInput>
  }

  export type TaskEventScalarWhereInput = {
    AND?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
    OR?: TaskEventScalarWhereInput[]
    NOT?: TaskEventScalarWhereInput | TaskEventScalarWhereInput[]
    id?: StringFilter<"TaskEvent"> | string
    runId?: StringFilter<"TaskEvent"> | string
    type?: StringFilter<"TaskEvent"> | string
    message?: StringFilter<"TaskEvent"> | string
    data?: JsonNullableFilter<"TaskEvent">
    createdAt?: DateTimeFilter<"TaskEvent"> | Date | string
  }

  export type QueryRunCreateWithoutEventsInput = {
    id?: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    query: QueryCreateNestedOneWithoutQueryRunsInput
  }

  export type QueryRunUncheckedCreateWithoutEventsInput = {
    id?: string
    queryId: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueryRunCreateOrConnectWithoutEventsInput = {
    where: QueryRunWhereUniqueInput
    create: XOR<QueryRunCreateWithoutEventsInput, QueryRunUncheckedCreateWithoutEventsInput>
  }

  export type QueryRunUpsertWithoutEventsInput = {
    update: XOR<QueryRunUpdateWithoutEventsInput, QueryRunUncheckedUpdateWithoutEventsInput>
    create: XOR<QueryRunCreateWithoutEventsInput, QueryRunUncheckedCreateWithoutEventsInput>
    where?: QueryRunWhereInput
  }

  export type QueryRunUpdateToOneWithWhereWithoutEventsInput = {
    where?: QueryRunWhereInput
    data: XOR<QueryRunUpdateWithoutEventsInput, QueryRunUncheckedUpdateWithoutEventsInput>
  }

  export type QueryRunUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    query?: QueryUpdateOneRequiredWithoutQueryRunsNestedInput
  }

  export type QueryRunUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    queryId?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentKeywordCreateWithoutContentInput = {
    id?: string
    keyword: KeywordCreateNestedOneWithoutContentKeywordsInput
  }

  export type ContentKeywordUncheckedCreateWithoutContentInput = {
    id?: string
    keywordId: string
  }

  export type ContentKeywordCreateOrConnectWithoutContentInput = {
    where: ContentKeywordWhereUniqueInput
    create: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput>
  }

  export type ContentKeywordCreateManyContentInputEnvelope = {
    data: ContentKeywordCreateManyContentInput | ContentKeywordCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentEntityCreateWithoutContentInput = {
    id?: string
    persons?: ContentEntityCreatepersonsInput | string[]
    orgs?: ContentEntityCreateorgsInput | string[]
    locations?: ContentEntityCreatelocationsInput | string[]
  }

  export type ContentEntityUncheckedCreateWithoutContentInput = {
    id?: string
    persons?: ContentEntityCreatepersonsInput | string[]
    orgs?: ContentEntityCreateorgsInput | string[]
    locations?: ContentEntityCreatelocationsInput | string[]
  }

  export type ContentEntityCreateOrConnectWithoutContentInput = {
    where: ContentEntityWhereUniqueInput
    create: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
  }

  export type FavoriteCreateWithoutContentInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteUncheckedCreateWithoutContentInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutContentInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput>
  }

  export type FavoriteCreateManyContentInputEnvelope = {
    data: FavoriteCreateManyContentInput | FavoriteCreateManyContentInput[]
    skipDuplicates?: boolean
  }

  export type ContentKeywordUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentKeywordWhereUniqueInput
    update: XOR<ContentKeywordUpdateWithoutContentInput, ContentKeywordUncheckedUpdateWithoutContentInput>
    create: XOR<ContentKeywordCreateWithoutContentInput, ContentKeywordUncheckedCreateWithoutContentInput>
  }

  export type ContentKeywordUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentKeywordWhereUniqueInput
    data: XOR<ContentKeywordUpdateWithoutContentInput, ContentKeywordUncheckedUpdateWithoutContentInput>
  }

  export type ContentKeywordUpdateManyWithWhereWithoutContentInput = {
    where: ContentKeywordScalarWhereInput
    data: XOR<ContentKeywordUpdateManyMutationInput, ContentKeywordUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentEntityUpsertWithoutContentInput = {
    update: XOR<ContentEntityUpdateWithoutContentInput, ContentEntityUncheckedUpdateWithoutContentInput>
    create: XOR<ContentEntityCreateWithoutContentInput, ContentEntityUncheckedCreateWithoutContentInput>
    where?: ContentEntityWhereInput
  }

  export type ContentEntityUpdateToOneWithWhereWithoutContentInput = {
    where?: ContentEntityWhereInput
    data: XOR<ContentEntityUpdateWithoutContentInput, ContentEntityUncheckedUpdateWithoutContentInput>
  }

  export type ContentEntityUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
  }

  export type ContentEntityUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    persons?: ContentEntityUpdatepersonsInput | string[]
    orgs?: ContentEntityUpdateorgsInput | string[]
    locations?: ContentEntityUpdatelocationsInput | string[]
  }

  export type FavoriteUpsertWithWhereUniqueWithoutContentInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutContentInput, FavoriteUncheckedUpdateWithoutContentInput>
    create: XOR<FavoriteCreateWithoutContentInput, FavoriteUncheckedCreateWithoutContentInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutContentInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutContentInput, FavoriteUncheckedUpdateWithoutContentInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutContentInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutContentInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    id?: StringFilter<"Favorite"> | string
    userId?: StringFilter<"Favorite"> | string
    contentId?: StringFilter<"Favorite"> | string
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type ContentCreateWithoutKeywordsInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: ContentEntityCreateNestedOneWithoutContentInput
    favorites?: FavoriteCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutKeywordsInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: ContentEntityUncheckedCreateNestedOneWithoutContentInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutKeywordsInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutKeywordsInput, ContentUncheckedCreateWithoutKeywordsInput>
  }

  export type KeywordCreateWithoutContentKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CategoryCreateNestedOneWithoutKeywordsInput
    queries?: QueryCreateNestedManyWithoutKeywordsInput
  }

  export type KeywordUncheckedCreateWithoutContentKeywordsInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    categoryId?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    queries?: QueryUncheckedCreateNestedManyWithoutKeywordsInput
  }

  export type KeywordCreateOrConnectWithoutContentKeywordsInput = {
    where: KeywordWhereUniqueInput
    create: XOR<KeywordCreateWithoutContentKeywordsInput, KeywordUncheckedCreateWithoutContentKeywordsInput>
  }

  export type ContentUpsertWithoutKeywordsInput = {
    update: XOR<ContentUpdateWithoutKeywordsInput, ContentUncheckedUpdateWithoutKeywordsInput>
    create: XOR<ContentCreateWithoutKeywordsInput, ContentUncheckedCreateWithoutKeywordsInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutKeywordsInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutKeywordsInput, ContentUncheckedUpdateWithoutKeywordsInput>
  }

  export type ContentUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: ContentEntityUpdateOneWithoutContentNestedInput
    favorites?: FavoriteUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: ContentEntityUncheckedUpdateOneWithoutContentNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutContentNestedInput
  }

  export type KeywordUpsertWithoutContentKeywordsInput = {
    update: XOR<KeywordUpdateWithoutContentKeywordsInput, KeywordUncheckedUpdateWithoutContentKeywordsInput>
    create: XOR<KeywordCreateWithoutContentKeywordsInput, KeywordUncheckedCreateWithoutContentKeywordsInput>
    where?: KeywordWhereInput
  }

  export type KeywordUpdateToOneWithWhereWithoutContentKeywordsInput = {
    where?: KeywordWhereInput
    data: XOR<KeywordUpdateWithoutContentKeywordsInput, KeywordUncheckedUpdateWithoutContentKeywordsInput>
  }

  export type KeywordUpdateWithoutContentKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutKeywordsNestedInput
    queries?: QueryUpdateManyWithoutKeywordsNestedInput
  }

  export type KeywordUncheckedUpdateWithoutContentKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: QueryUncheckedUpdateManyWithoutKeywordsNestedInput
  }

  export type ContentCreateWithoutEntitiesInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordCreateNestedManyWithoutContentInput
    favorites?: FavoriteCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutEntitiesInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordUncheckedCreateNestedManyWithoutContentInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutEntitiesInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutEntitiesInput, ContentUncheckedCreateWithoutEntitiesInput>
  }

  export type ContentUpsertWithoutEntitiesInput = {
    update: XOR<ContentUpdateWithoutEntitiesInput, ContentUncheckedUpdateWithoutEntitiesInput>
    create: XOR<ContentCreateWithoutEntitiesInput, ContentUncheckedCreateWithoutEntitiesInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutEntitiesInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutEntitiesInput, ContentUncheckedUpdateWithoutEntitiesInput>
  }

  export type ContentUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUpdateManyWithoutContentNestedInput
    favorites?: FavoriteUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUncheckedUpdateManyWithoutContentNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateWithoutFavoritesInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordCreateNestedManyWithoutContentInput
    entities?: ContentEntityCreateNestedOneWithoutContentInput
  }

  export type ContentUncheckedCreateWithoutFavoritesInput = {
    id?: string
    title: string
    summary: string
    markdown: string
    platform: string
    type: $Enums.ContentType
    time: Date | string
    url?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    keywords?: ContentKeywordUncheckedCreateNestedManyWithoutContentInput
    entities?: ContentEntityUncheckedCreateNestedOneWithoutContentInput
  }

  export type ContentCreateOrConnectWithoutFavoritesInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutFavoritesInput, ContentUncheckedCreateWithoutFavoritesInput>
  }

  export type ContentUpsertWithoutFavoritesInput = {
    update: XOR<ContentUpdateWithoutFavoritesInput, ContentUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ContentCreateWithoutFavoritesInput, ContentUncheckedCreateWithoutFavoritesInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutFavoritesInput, ContentUncheckedUpdateWithoutFavoritesInput>
  }

  export type ContentUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUpdateManyWithoutContentNestedInput
    entities?: ContentEntityUpdateOneWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    markdown?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: ContentKeywordUncheckedUpdateManyWithoutContentNestedInput
    entities?: ContentEntityUncheckedUpdateOneWithoutContentNestedInput
  }

  export type ReportCreateWithoutTemplateInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: ReportMaterialCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutTemplateInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: ReportMaterialUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput>
  }

  export type ReportCreateManyTemplateInputEnvelope = {
    data: ReportCreateManyTemplateInput | ReportCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ReportUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutTemplateInput, ReportUncheckedUpdateWithoutTemplateInput>
    create: XOR<ReportCreateWithoutTemplateInput, ReportUncheckedCreateWithoutTemplateInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutTemplateInput, ReportUncheckedUpdateWithoutTemplateInput>
  }

  export type ReportUpdateManyWithWhereWithoutTemplateInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    title?: StringFilter<"Report"> | string
    summary?: StringNullableFilter<"Report"> | string | null
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    templateId?: StringNullableFilter<"Report"> | string | null
    authorId?: StringNullableFilter<"Report"> | string | null
    markdown?: StringNullableFilter<"Report"> | string | null
    metadata?: JsonNullableFilter<"Report">
    version?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type ReportTemplateCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    description?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportTemplateCreateOrConnectWithoutReportsInput = {
    where: ReportTemplateWhereUniqueInput
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
  }

  export type ReportMaterialCreateWithoutReportInput = {
    id?: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportMaterialUncheckedCreateWithoutReportInput = {
    id?: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportMaterialCreateOrConnectWithoutReportInput = {
    where: ReportMaterialWhereUniqueInput
    create: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput>
  }

  export type ReportMaterialCreateManyReportInputEnvelope = {
    data: ReportMaterialCreateManyReportInput | ReportMaterialCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type ReportTemplateUpsertWithoutReportsInput = {
    update: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
    create: XOR<ReportTemplateCreateWithoutReportsInput, ReportTemplateUncheckedCreateWithoutReportsInput>
    where?: ReportTemplateWhereInput
  }

  export type ReportTemplateUpdateToOneWithWhereWithoutReportsInput = {
    where?: ReportTemplateWhereInput
    data: XOR<ReportTemplateUpdateWithoutReportsInput, ReportTemplateUncheckedUpdateWithoutReportsInput>
  }

  export type ReportTemplateUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportTemplateUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportMaterialWhereUniqueInput
    update: XOR<ReportMaterialUpdateWithoutReportInput, ReportMaterialUncheckedUpdateWithoutReportInput>
    create: XOR<ReportMaterialCreateWithoutReportInput, ReportMaterialUncheckedCreateWithoutReportInput>
  }

  export type ReportMaterialUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportMaterialWhereUniqueInput
    data: XOR<ReportMaterialUpdateWithoutReportInput, ReportMaterialUncheckedUpdateWithoutReportInput>
  }

  export type ReportMaterialUpdateManyWithWhereWithoutReportInput = {
    where: ReportMaterialScalarWhereInput
    data: XOR<ReportMaterialUpdateManyMutationInput, ReportMaterialUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportMaterialScalarWhereInput = {
    AND?: ReportMaterialScalarWhereInput | ReportMaterialScalarWhereInput[]
    OR?: ReportMaterialScalarWhereInput[]
    NOT?: ReportMaterialScalarWhereInput | ReportMaterialScalarWhereInput[]
    id?: StringFilter<"ReportMaterial"> | string
    reportId?: StringFilter<"ReportMaterial"> | string
    sourceType?: EnumMaterialSourceFilter<"ReportMaterial"> | $Enums.MaterialSource
    sourceId?: StringFilter<"ReportMaterial"> | string
    title?: StringNullableFilter<"ReportMaterial"> | string | null
    snippet?: StringNullableFilter<"ReportMaterial"> | string | null
    metadata?: JsonNullableFilter<"ReportMaterial">
    createdAt?: DateTimeFilter<"ReportMaterial"> | Date | string
  }

  export type ReportCreateWithoutMaterialsInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: ReportTemplateCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutMaterialsInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    templateId?: string | null
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutMaterialsInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutMaterialsInput, ReportUncheckedCreateWithoutMaterialsInput>
  }

  export type ReportUpsertWithoutMaterialsInput = {
    update: XOR<ReportUpdateWithoutMaterialsInput, ReportUncheckedUpdateWithoutMaterialsInput>
    create: XOR<ReportCreateWithoutMaterialsInput, ReportUncheckedCreateWithoutMaterialsInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutMaterialsInput, ReportUncheckedUpdateWithoutMaterialsInput>
  }

  export type ReportUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ReportTemplateUpdateOneWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeFileCreateWithoutKnowledgeInput = {
    id?: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkCreateNestedManyWithoutFileInput
  }

  export type KnowledgeFileUncheckedCreateWithoutKnowledgeInput = {
    id?: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    chunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutFileInput
  }

  export type KnowledgeFileCreateOrConnectWithoutKnowledgeInput = {
    where: KnowledgeFileWhereUniqueInput
    create: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput>
  }

  export type KnowledgeFileCreateManyKnowledgeInputEnvelope = {
    data: KnowledgeFileCreateManyKnowledgeInput | KnowledgeFileCreateManyKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeChunkCreateWithoutKnowledgeInput = {
    id?: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
    file?: KnowledgeFileCreateNestedOneWithoutChunksInput
  }

  export type KnowledgeChunkUncheckedCreateWithoutKnowledgeInput = {
    id?: string
    fileId?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeChunkCreateOrConnectWithoutKnowledgeInput = {
    where: KnowledgeChunkWhereUniqueInput
    create: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput>
  }

  export type KnowledgeChunkCreateManyKnowledgeInputEnvelope = {
    data: KnowledgeChunkCreateManyKnowledgeInput | KnowledgeChunkCreateManyKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeFileUpsertWithWhereUniqueWithoutKnowledgeInput = {
    where: KnowledgeFileWhereUniqueInput
    update: XOR<KnowledgeFileUpdateWithoutKnowledgeInput, KnowledgeFileUncheckedUpdateWithoutKnowledgeInput>
    create: XOR<KnowledgeFileCreateWithoutKnowledgeInput, KnowledgeFileUncheckedCreateWithoutKnowledgeInput>
  }

  export type KnowledgeFileUpdateWithWhereUniqueWithoutKnowledgeInput = {
    where: KnowledgeFileWhereUniqueInput
    data: XOR<KnowledgeFileUpdateWithoutKnowledgeInput, KnowledgeFileUncheckedUpdateWithoutKnowledgeInput>
  }

  export type KnowledgeFileUpdateManyWithWhereWithoutKnowledgeInput = {
    where: KnowledgeFileScalarWhereInput
    data: XOR<KnowledgeFileUpdateManyMutationInput, KnowledgeFileUncheckedUpdateManyWithoutKnowledgeInput>
  }

  export type KnowledgeFileScalarWhereInput = {
    AND?: KnowledgeFileScalarWhereInput | KnowledgeFileScalarWhereInput[]
    OR?: KnowledgeFileScalarWhereInput[]
    NOT?: KnowledgeFileScalarWhereInput | KnowledgeFileScalarWhereInput[]
    id?: StringFilter<"KnowledgeFile"> | string
    knowledgeId?: StringFilter<"KnowledgeFile"> | string
    name?: StringFilter<"KnowledgeFile"> | string
    mimeType?: StringNullableFilter<"KnowledgeFile"> | string | null
    size?: IntNullableFilter<"KnowledgeFile"> | number | null
    storageKey?: StringNullableFilter<"KnowledgeFile"> | string | null
    createdAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeFile"> | Date | string
  }

  export type KnowledgeChunkUpsertWithWhereUniqueWithoutKnowledgeInput = {
    where: KnowledgeChunkWhereUniqueInput
    update: XOR<KnowledgeChunkUpdateWithoutKnowledgeInput, KnowledgeChunkUncheckedUpdateWithoutKnowledgeInput>
    create: XOR<KnowledgeChunkCreateWithoutKnowledgeInput, KnowledgeChunkUncheckedCreateWithoutKnowledgeInput>
  }

  export type KnowledgeChunkUpdateWithWhereUniqueWithoutKnowledgeInput = {
    where: KnowledgeChunkWhereUniqueInput
    data: XOR<KnowledgeChunkUpdateWithoutKnowledgeInput, KnowledgeChunkUncheckedUpdateWithoutKnowledgeInput>
  }

  export type KnowledgeChunkUpdateManyWithWhereWithoutKnowledgeInput = {
    where: KnowledgeChunkScalarWhereInput
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyWithoutKnowledgeInput>
  }

  export type KnowledgeChunkScalarWhereInput = {
    AND?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
    OR?: KnowledgeChunkScalarWhereInput[]
    NOT?: KnowledgeChunkScalarWhereInput | KnowledgeChunkScalarWhereInput[]
    id?: StringFilter<"KnowledgeChunk"> | string
    knowledgeId?: StringFilter<"KnowledgeChunk"> | string
    fileId?: StringNullableFilter<"KnowledgeChunk"> | string | null
    content?: StringFilter<"KnowledgeChunk"> | string
    metadata?: JsonNullableFilter<"KnowledgeChunk">
    embedding?: BytesNullableFilter<"KnowledgeChunk"> | Bytes | null
    chunkIndex?: IntFilter<"KnowledgeChunk"> | number
    createdAt?: DateTimeFilter<"KnowledgeChunk"> | Date | string
  }

  export type KnowledgeCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeChunks?: KnowledgeChunkCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledgeChunks?: KnowledgeChunkUncheckedCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeCreateOrConnectWithoutFilesInput = {
    where: KnowledgeWhereUniqueInput
    create: XOR<KnowledgeCreateWithoutFilesInput, KnowledgeUncheckedCreateWithoutFilesInput>
  }

  export type KnowledgeChunkCreateWithoutFileInput = {
    id?: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
    knowledge: KnowledgeCreateNestedOneWithoutKnowledgeChunksInput
  }

  export type KnowledgeChunkUncheckedCreateWithoutFileInput = {
    id?: string
    knowledgeId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeChunkCreateOrConnectWithoutFileInput = {
    where: KnowledgeChunkWhereUniqueInput
    create: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput>
  }

  export type KnowledgeChunkCreateManyFileInputEnvelope = {
    data: KnowledgeChunkCreateManyFileInput | KnowledgeChunkCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type KnowledgeUpsertWithoutFilesInput = {
    update: XOR<KnowledgeUpdateWithoutFilesInput, KnowledgeUncheckedUpdateWithoutFilesInput>
    create: XOR<KnowledgeCreateWithoutFilesInput, KnowledgeUncheckedCreateWithoutFilesInput>
    where?: KnowledgeWhereInput
  }

  export type KnowledgeUpdateToOneWithWhereWithoutFilesInput = {
    where?: KnowledgeWhereInput
    data: XOR<KnowledgeUpdateWithoutFilesInput, KnowledgeUncheckedUpdateWithoutFilesInput>
  }

  export type KnowledgeUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeChunks?: KnowledgeChunkUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledgeChunks?: KnowledgeChunkUncheckedUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeChunkUpsertWithWhereUniqueWithoutFileInput = {
    where: KnowledgeChunkWhereUniqueInput
    update: XOR<KnowledgeChunkUpdateWithoutFileInput, KnowledgeChunkUncheckedUpdateWithoutFileInput>
    create: XOR<KnowledgeChunkCreateWithoutFileInput, KnowledgeChunkUncheckedCreateWithoutFileInput>
  }

  export type KnowledgeChunkUpdateWithWhereUniqueWithoutFileInput = {
    where: KnowledgeChunkWhereUniqueInput
    data: XOR<KnowledgeChunkUpdateWithoutFileInput, KnowledgeChunkUncheckedUpdateWithoutFileInput>
  }

  export type KnowledgeChunkUpdateManyWithWhereWithoutFileInput = {
    where: KnowledgeChunkScalarWhereInput
    data: XOR<KnowledgeChunkUpdateManyMutationInput, KnowledgeChunkUncheckedUpdateManyWithoutFileInput>
  }

  export type KnowledgeCreateWithoutKnowledgeChunksInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KnowledgeFileCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeUncheckedCreateWithoutKnowledgeChunksInput = {
    id?: string
    name: string
    description?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: KnowledgeFileUncheckedCreateNestedManyWithoutKnowledgeInput
  }

  export type KnowledgeCreateOrConnectWithoutKnowledgeChunksInput = {
    where: KnowledgeWhereUniqueInput
    create: XOR<KnowledgeCreateWithoutKnowledgeChunksInput, KnowledgeUncheckedCreateWithoutKnowledgeChunksInput>
  }

  export type KnowledgeFileCreateWithoutChunksInput = {
    id?: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    knowledge: KnowledgeCreateNestedOneWithoutFilesInput
  }

  export type KnowledgeFileUncheckedCreateWithoutChunksInput = {
    id?: string
    knowledgeId: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeFileCreateOrConnectWithoutChunksInput = {
    where: KnowledgeFileWhereUniqueInput
    create: XOR<KnowledgeFileCreateWithoutChunksInput, KnowledgeFileUncheckedCreateWithoutChunksInput>
  }

  export type KnowledgeUpsertWithoutKnowledgeChunksInput = {
    update: XOR<KnowledgeUpdateWithoutKnowledgeChunksInput, KnowledgeUncheckedUpdateWithoutKnowledgeChunksInput>
    create: XOR<KnowledgeCreateWithoutKnowledgeChunksInput, KnowledgeUncheckedCreateWithoutKnowledgeChunksInput>
    where?: KnowledgeWhereInput
  }

  export type KnowledgeUpdateToOneWithWhereWithoutKnowledgeChunksInput = {
    where?: KnowledgeWhereInput
    data: XOR<KnowledgeUpdateWithoutKnowledgeChunksInput, KnowledgeUncheckedUpdateWithoutKnowledgeChunksInput>
  }

  export type KnowledgeUpdateWithoutKnowledgeChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KnowledgeFileUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeUncheckedUpdateWithoutKnowledgeChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: KnowledgeFileUncheckedUpdateManyWithoutKnowledgeNestedInput
  }

  export type KnowledgeFileUpsertWithoutChunksInput = {
    update: XOR<KnowledgeFileUpdateWithoutChunksInput, KnowledgeFileUncheckedUpdateWithoutChunksInput>
    create: XOR<KnowledgeFileCreateWithoutChunksInput, KnowledgeFileUncheckedCreateWithoutChunksInput>
    where?: KnowledgeFileWhereInput
  }

  export type KnowledgeFileUpdateToOneWithWhereWithoutChunksInput = {
    where?: KnowledgeFileWhereInput
    data: XOR<KnowledgeFileUpdateWithoutChunksInput, KnowledgeFileUncheckedUpdateWithoutChunksInput>
  }

  export type KnowledgeFileUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateOneRequiredWithoutFilesNestedInput
  }

  export type KnowledgeFileUncheckedUpdateWithoutChunksInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeywordCreateManyCategoryInput = {
    id?: string
    name: string
    description?: string | null
    lang?: string | null
    includes?: KeywordCreateincludesInput | string[]
    excludes?: KeywordCreateexcludesInput | string[]
    enableAiExpand?: boolean
    synonyms?: KeywordCreatesynonymsInput | string[]
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: QueryUpdateManyWithoutKeywordsNestedInput
    contentKeywords?: ContentKeywordUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    queries?: QueryUncheckedUpdateManyWithoutKeywordsNestedInput
    contentKeywords?: ContentKeywordUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentKeywordCreateManyKeywordInput = {
    id?: string
    contentId: string
  }

  export type QueryUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: SourceUncheckedUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutKeywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentKeywordUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: ContentUpdateOneRequiredWithoutKeywordsNestedInput
  }

  export type ContentKeywordUncheckedUpdateWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentKeywordUncheckedUpdateManyWithoutKeywordInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
  }

  export type SourceCreateManyProxyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DarknetSourceConfigCreateManyProxyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WebSourceConfigCreateManyProxyInput = {
    sourceId: string
    url: string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: $Enums.CrawlerEngine
    render?: boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigCreateManyProxyInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    credentialId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SourceUpdateWithoutProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateManyWithoutProxyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigUpdateWithoutProxyInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutDarknetNestedInput
  }

  export type DarknetSourceConfigUncheckedUpdateWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DarknetSourceConfigUncheckedUpdateManyWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebSourceConfigUpdateWithoutProxyInput = {
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutWebNestedInput
  }

  export type WebSourceConfigUncheckedUpdateWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebSourceConfigUncheckedUpdateManyWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    headers?: NullableJsonNullValueInput | InputJsonValue
    crawlerEngine?: EnumCrawlerEngineFieldUpdateOperationsInput | $Enums.CrawlerEngine
    render?: BoolFieldUpdateOperationsInput | boolean
    parseRules?: NullableJsonNullValueInput | InputJsonValue
    robotsRespect?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUpdateWithoutProxyInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutSocialNestedInput
    credential?: CredentialUpdateOneWithoutSocialOverridesNestedInput
  }

  export type SocialMediaSourceConfigUncheckedUpdateWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUncheckedUpdateManyWithoutProxyInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceCreateManyCredentialInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.SourceType
    active?: boolean
    rateLimit?: number | null
    lastFetchedAt?: Date | string | null
    lastStatus?: string | null
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaSourceConfigCreateManyCredentialInput = {
    sourceId: string
    platform: $Enums.SocialPlatform
    config: JsonNullValueInput | InputJsonValue
    proxyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SearchEngineSourceConfigCreateManyCredentialInput = {
    sourceId: string
    engine: $Enums.SearchEngineKind
    query: string
    region?: string | null
    lang?: string | null
    apiEndpoint?: string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SourceUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
    queries?: QueryUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    queries?: QueryUncheckedUpdateManyWithoutSourcesNestedInput
  }

  export type SourceUncheckedUpdateManyWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUpdateWithoutCredentialInput = {
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutSocialNestedInput
    proxy?: ProxyUpdateOneWithoutSocialOverridesNestedInput
  }

  export type SocialMediaSourceConfigUncheckedUpdateWithoutCredentialInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaSourceConfigUncheckedUpdateManyWithoutCredentialInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    platform?: EnumSocialPlatformFieldUpdateOperationsInput | $Enums.SocialPlatform
    config?: JsonNullValueInput | InputJsonValue
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigUpdateWithoutCredentialInput = {
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: SourceUpdateOneRequiredWithoutSearchNestedInput
  }

  export type SearchEngineSourceConfigUncheckedUpdateWithoutCredentialInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchEngineSourceConfigUncheckedUpdateManyWithoutCredentialInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
    engine?: EnumSearchEngineKindFieldUpdateOperationsInput | $Enums.SearchEngineKind
    query?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    apiEndpoint?: NullableStringFieldUpdateOperationsInput | string | null
    options?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    keywords?: KeywordUncheckedUpdateManyWithoutQueriesNestedInput
    queryRuns?: QueryRunUncheckedUpdateManyWithoutQueryNestedInput
  }

  export type QueryUncheckedUpdateManyWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    enabled?: BoolFieldUpdateOperationsInput | boolean
    frequency?: EnumQueryFrequencyFieldUpdateOperationsInput | $Enums.QueryFrequency
    cronSchedule?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryRunCreateManyQueryInput = {
    id?: string
    status?: $Enums.TaskStatus
    progress?: number
    error?: string | null
    startedAt?: Date | string | null
    finishedAt?: Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KeywordUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CategoryUpdateOneWithoutKeywordsNestedInput
    contentKeywords?: ContentKeywordUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentKeywords?: ContentKeywordUncheckedUpdateManyWithoutKeywordNestedInput
  }

  export type KeywordUncheckedUpdateManyWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    lang?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    includes?: KeywordUpdateincludesInput | string[]
    excludes?: KeywordUpdateexcludesInput | string[]
    enableAiExpand?: BoolFieldUpdateOperationsInput | boolean
    synonyms?: KeywordUpdatesynonymsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    proxy?: ProxyUpdateOneWithoutSourcesNestedInput
    credential?: CredentialUpdateOneWithoutSourcesNestedInput
    web?: WebSourceConfigUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUpdateOneWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    web?: WebSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    darknet?: DarknetSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    search?: SearchEngineSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
    social?: SocialMediaSourceConfigUncheckedUpdateOneWithoutSourceNestedInput
  }

  export type SourceUncheckedUpdateManyWithoutQueriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    active?: BoolFieldUpdateOperationsInput | boolean
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    lastFetchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastStatus?: NullableStringFieldUpdateOperationsInput | string | null
    proxyId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueryRunUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TaskEventUpdateManyWithoutRunNestedInput
  }

  export type QueryRunUncheckedUpdateWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: TaskEventUncheckedUpdateManyWithoutRunNestedInput
  }

  export type QueryRunUncheckedUpdateManyWithoutQueryInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    progress?: IntFieldUpdateOperationsInput | number
    error?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventCreateManyRunInput = {
    id?: string
    type: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type TaskEventUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskEventUncheckedUpdateManyWithoutRunInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentKeywordCreateManyContentInput = {
    id?: string
    keywordId: string
  }

  export type FavoriteCreateManyContentInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ContentKeywordUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: KeywordUpdateOneRequiredWithoutContentKeywordsNestedInput
  }

  export type ContentKeywordUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
  }

  export type ContentKeywordUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    keywordId?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyTemplateInput = {
    id?: string
    title: string
    summary?: string | null
    status?: $Enums.ReportStatus
    authorId?: string | null
    markdown?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: ReportMaterialUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: ReportMaterialUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    markdown?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialCreateManyReportInput = {
    id?: string
    sourceType: $Enums.MaterialSource
    sourceId: string
    title?: string | null
    snippet?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReportMaterialUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportMaterialUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceType?: EnumMaterialSourceFieldUpdateOperationsInput | $Enums.MaterialSource
    sourceId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    snippet?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeFileCreateManyKnowledgeInput = {
    id?: string
    name: string
    mimeType?: string | null
    size?: number | null
    storageKey?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeChunkCreateManyKnowledgeInput = {
    id?: string
    fileId?: string | null
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeFileUpdateWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUpdateManyWithoutFileNestedInput
  }

  export type KnowledgeFileUncheckedUpdateWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chunks?: KnowledgeChunkUncheckedUpdateManyWithoutFileNestedInput
  }

  export type KnowledgeFileUncheckedUpdateManyWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    storageKey?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUpdateWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: KnowledgeFileUpdateOneWithoutChunksNestedInput
  }

  export type KnowledgeChunkUncheckedUpdateWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkCreateManyFileInput = {
    id?: string
    knowledgeId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: Bytes | null
    chunkIndex?: number
    createdAt?: Date | string
  }

  export type KnowledgeChunkUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    knowledge?: KnowledgeUpdateOneRequiredWithoutKnowledgeChunksNestedInput
  }

  export type KnowledgeChunkUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeChunkUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    knowledgeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    embedding?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    chunkIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}