---
description: 性能优化规范（前端优化/后端优化/数据库优化/缓存策略/CDN/监控指标）
globs:
  - "app/**"
  - "components/**"
  - "lib/**"
alwaysApply: true
---

# Oak Research - 性能优化规范

本规范定义前后端性能优化策略、缓存机制、数据库优化与监控指标，确保系统在高负载下的响应速度和用户体验。

## 1. 前端性能优化

### Next.js 优化配置

```ts
// next.config.ts
const nextConfig = {
  // 启用 SWC 编译器
  swcMinify: true,

  // 图片优化
  images: {
    domains: ["example.com"],
    formats: ["image/avif", "image/webp"],
    minimumCacheTTL: 31536000, // 1年
  },

  // 压缩配置
  compress: true,

  // 实验性功能
  experimental: {
    // React 编译器
    reactCompiler: true,
    // 部分预渲染
    ppr: true,
  },

  // 构建优化
  webpack: (config, { isServer }) => {
    // Bundle 分析
    if (process.env.ANALYZE === "true") {
      const { BundleAnalyzerPlugin } = require("webpack-bundle-analyzer");
      config.plugins.push(
        new BundleAnalyzerPlugin({
          analyzerMode: "server",
          openAnalyzer: true,
        })
      );
    }

    return config;
  },
};
```

### 组件性能优化

```tsx
// 使用 memo 和 useMemo
import { memo, useMemo, useCallback } from "react";

const ExpensiveComponent = memo(({ data, onItemClick }) => {
  // 计算密集型操作缓存
  const processedData = useMemo(() => {
    return data.map((item) => ({
      ...item,
      processed: expensiveCalculation(item),
    }));
  }, [data]);

  // 事件处理函数缓存
  const handleClick = useCallback(
    (id: string) => {
      onItemClick?.(id);
    },
    [onItemClick]
  );

  return (
    <div>
      {processedData.map((item) => (
        <ItemComponent key={item.id} item={item} onClick={handleClick} />
      ))}
    </div>
  );
});

// 虚拟滚动大列表
import { FixedSizeList as List } from "react-window";

const VirtualizedList = ({ items }) => (
  <List height={600} itemCount={items.length} itemSize={50} itemData={items}>
    {Row}
  </List>
);
```

### 代码分割与懒加载

```tsx
// 路由级代码分割
import dynamic from "next/dynamic";

const ReportEditor = dynamic(() => import("./ReportEditor"), {
  loading: () => <div>Loading...</div>,
  ssr: false, // 客户端组件
});

// 组件级懒加载
const Chart = dynamic(() => import("./Chart"), {
  loading: () => <ChartSkeleton />,
});

// 条件加载
const AdminPanel = dynamic(() => import("./AdminPanel"), {
  loading: () => <div>Loading admin...</div>,
});

function Dashboard({ user }) {
  return (
    <div>
      <MainContent />
      {user.isAdmin && <AdminPanel />}
    </div>
  );
}
```

### 资源优化

```tsx
// 图片优化
import Image from "next/image";

const OptimizedImage = ({ src, alt }) => (
  <Image
    src={src}
    alt={alt}
    width={400}
    height={300}
    priority={false} // 非关键图片
    placeholder="blur"
    blurDataURL="data:image/jpeg;base64,..."
    sizes="(max-width: 768px) 100vw, 50vw"
  />
);

// 字体优化
import { Inter } from "next/font/google";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  preload: true,
});
```

## 2. 后端性能优化

### API 响应优化

```ts
// 响应缓存
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const cacheKey = `api-${searchParams.toString()}`;

  // 检查缓存
  const cached = await redis.get(cacheKey);
  if (cached) {
    return Response.json(JSON.parse(cached), {
      headers: {
        "Cache-Control": "public, max-age=300, stale-while-revalidate=60",
        "X-Cache": "HIT",
      },
    });
  }

  const data = await fetchData();

  // 设置缓存
  await redis.setex(cacheKey, 300, JSON.stringify(data));

  return Response.json(data, {
    headers: {
      "Cache-Control": "public, max-age=300, stale-while-revalidate=60",
      "X-Cache": "MISS",
    },
  });
}

// 并行数据获取
export async function getPageData() {
  const [keywords, categories, sources] = await Promise.all([
    getKeywords(),
    getCategories(),
    getSources(),
  ]);

  return { keywords, categories, sources };
}
```

### 流式响应

```ts
// 大量数据流式传输
export async function GET() {
  const encoder = new TextEncoder();

  const stream = new ReadableStream({
    async start(controller) {
      try {
        const data = await fetchLargeDataset();

        for (const chunk of data) {
          const encoded = encoder.encode(JSON.stringify(chunk) + "\n");
          controller.enqueue(encoded);

          // 允许其他任务执行
          await new Promise((resolve) => setTimeout(resolve, 0));
        }

        controller.close();
      } catch (error) {
        controller.error(error);
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "application/x-ndjson",
      "Transfer-Encoding": "chunked",
    },
  });
}
```

## 3. 数据库性能优化

### Prisma 查询优化

```ts
// 选择性字段查询
const users = await prisma.user.findMany({
  select: {
    id: true,
    name: true,
    email: true,
    // 不查询不必要的字段
  },
});

// 批量操作
const results = await prisma.$transaction([
  prisma.user.create({ data: userData1 }),
  prisma.user.create({ data: userData2 }),
  prisma.user.create({ data: userData3 }),
]);

// 关联查询优化
const sources = await prisma.source.findMany({
  include: {
    darknet: {
      include: {
        proxy: true, // 只在需要时包含
      },
    },
  },
  where: {
    active: true, // 添加过滤条件
  },
  orderBy: {
    updatedAt: "desc",
  },
  take: 50, // 限制数量
});

// 原生查询（复杂场景）
const results = await prisma.$queryRaw`
  SELECT s.id, s.name, COUNT(c.id) as content_count
  FROM "Source" s
  LEFT JOIN "Content" c ON s.id = c.source_id
  WHERE s.active = true
  GROUP BY s.id, s.name
  ORDER BY content_count DESC
  LIMIT 20
`;
```

### 数据库索引策略

```sql
-- 复合索引
CREATE INDEX idx_content_platform_time ON "Content" (platform, time DESC);
CREATE INDEX idx_source_type_active ON "Source" (type, active) WHERE active = true;

-- 部分索引
CREATE INDEX idx_content_recent ON "Content" (time)
WHERE time > NOW() - INTERVAL '30 days';

-- 全文搜索索引
CREATE INDEX idx_content_search ON "Content"
USING gin(to_tsvector('english', title || ' ' || summary));

-- 向量索引（pgvector）
CREATE INDEX idx_embedding_cosine ON "KnowledgeChunk"
USING ivfflat (embedding vector_cosine_ops) WITH (lists = 100);
```

### 连接池配置

```ts
// lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    datasources: {
      db: {
        url: process.env.DATABASE_URL,
      },
    },
    // 连接池配置
    log:
      process.env.NODE_ENV === "development"
        ? ["query", "error", "warn"]
        : ["error"],
  });

// 连接池监控
if (process.env.NODE_ENV === "production") {
  setInterval(() => {
    console.log("DB Pool Status:", {
      // 监控连接池状态
    });
  }, 60000);
}
```

## 4. 缓存策略

### Redis 缓存层次

```ts
// 多层缓存策略
class CacheManager {
  // L1: 内存缓存 (最快，容量小)
  private memoryCache = new Map<string, CacheItem>();

  // L2: Redis 缓存 (快，容量中等)
  private redis: RedisClient;

  // L3: 数据库 (慢，容量大)
  private db: PrismaClient;

  async get<T>(key: string): Promise<T | null> {
    // 检查内存缓存
    const memoryResult = this.memoryCache.get(key);
    if (memoryResult && !this.isExpired(memoryResult)) {
      return memoryResult.data;
    }

    // 检查 Redis 缓存
    const redisResult = await this.redis.get(key);
    if (redisResult) {
      const data = JSON.parse(redisResult);
      // 回填内存缓存
      this.memoryCache.set(key, {
        data,
        expiry: Date.now() + 60000, // 1分钟
      });
      return data;
    }

    return null;
  }

  async set<T>(key: string, data: T, ttl: number): Promise<void> {
    // 同时写入多级缓存
    this.memoryCache.set(key, {
      data,
      expiry: Date.now() + Math.min(ttl * 1000, 60000),
    });

    await this.redis.setex(key, ttl, JSON.stringify(data));
  }
}
```

### 缓存模式

```ts
// Cache-Aside 模式
export async function getUser(id: string): Promise<User | null> {
  const cacheKey = `user:${id}`;

  // 先检查缓存
  const cached = await cache.get<User>(cacheKey);
  if (cached) return cached;

  // 缓存未命中，查询数据库
  const user = await prisma.user.findUnique({ where: { id } });
  if (user) {
    // 写入缓存
    await cache.set(cacheKey, user, 3600); // 1小时
  }

  return user;
}

// Write-Through 模式
export async function updateUser(
  id: string,
  data: UpdateUserData
): Promise<User> {
  // 同时更新数据库和缓存
  const [updatedUser] = await Promise.all([
    prisma.user.update({ where: { id }, data }),
    cache.delete(`user:${id}`), // 删除旧缓存
  ]);

  // 预热缓存
  await cache.set(`user:${id}`, updatedUser, 3600);

  return updatedUser;
}

// Write-Behind 模式 (异步写入)
export async function logUserAction(
  userId: string,
  action: string
): Promise<void> {
  // 立即写入缓存
  const logEntry = { userId, action, timestamp: Date.now() };
  await cache.lpush("user_actions", JSON.stringify(logEntry));

  // 异步批量写入数据库
  scheduler.schedule("flush_user_actions", { delay: 5000 });
}
```

## 5. CDN 与静态资源优化

### 静态资源配置

```ts
// next.config.ts
const nextConfig = {
  // 静态资源 CDN
  assetPrefix: process.env.CDN_URL || "",

  // 静态导出配置
  output: "standalone",

  // 图片 CDN
  images: {
    loader: "custom",
    loaderFile: "./lib/imageLoader.ts",
  },
};

// lib/imageLoader.ts
export default function imageLoader({ src, width, quality }) {
  const params = new URLSearchParams({
    url: src,
    w: width.toString(),
    q: (quality || 75).toString(),
  });

  return `${process.env.IMAGE_CDN_URL}?${params}`;
}
```

### 缓存控制策略

```ts
// 静态资源缓存配置
export const cacheConfig = {
  // 永久缓存（带版本号的资源）
  immutable: {
    "Cache-Control": "public, max-age=31536000, immutable",
  },

  // 短期缓存（API 响应）
  shortTerm: {
    "Cache-Control": "public, max-age=300, stale-while-revalidate=60",
  },

  // 长期缓存（静态内容）
  longTerm: {
    "Cache-Control": "public, max-age=86400, stale-while-revalidate=3600",
  },

  // 私有缓存（用户数据）
  private: {
    "Cache-Control": "private, max-age=300",
  },
};
```

## 6. 性能监控

### 核心指标收集

```ts
// lib/performance.ts
interface PerformanceMetrics {
  // Core Web Vitals
  LCP: number; // Largest Contentful Paint
  FID: number; // First Input Delay
  CLS: number; // Cumulative Layout Shift
  FCP: number; // First Contentful Paint
  TTFB: number; // Time to First Byte

  // 自定义指标
  apiResponseTime: number;
  databaseQueryTime: number;
  cacheHitRate: number;
  memoryUsage: number;
  cpuUsage: number;
}

class PerformanceMonitor {
  collectWebVitals(): void {
    // 收集 Web Vitals
    getCLS(console.log);
    getFID(console.log);
    getFCP(console.log);
    getLCP(console.log);
    getTTFB(console.log);
  }

  async collectServerMetrics(): Promise<ServerMetrics> {
    return {
      memoryUsage: process.memoryUsage(),
      cpuUsage: process.cpuUsage(),
      uptime: process.uptime(),
      activeConnections: await this.getActiveConnections(),
      cacheStats: await this.getCacheStats(),
    };
  }
}
```

### 性能预算

```ts
// 性能预算配置
export const performanceBudget = {
  // 包体积限制
  bundles: {
    main: 250000, // 250KB
    vendor: 500000, // 500KB
    total: 1000000, // 1MB
  },

  // 性能指标阈值
  metrics: {
    LCP: 2500, // 2.5s
    FID: 100, // 100ms
    CLS: 0.1, // 0.1
    TTFB: 600, // 600ms
  },

  // API 响应时间
  api: {
    p95: 1000, // 95% 请求 < 1s
    p99: 3000, // 99% 请求 < 3s
  },
};

// 性能监控告警
class PerformanceAlert {
  checkBudget(metrics: PerformanceMetrics): void {
    if (metrics.LCP > performanceBudget.metrics.LCP) {
      this.sendAlert("LCP_EXCEEDED", {
        current: metrics.LCP,
        budget: performanceBudget.metrics.LCP,
      });
    }

    // 其他指标检查...
  }
}
```

## 7. 优化检查清单

### 前端优化检查

- [ ] 启用代码分割和懒加载
- [ ] 使用 React.memo 和 useMemo 优化渲染
- [ ] 实施虚拟滚动（大列表）
- [ ] 优化图片加载（Next.js Image）
- [ ] 启用字体优化
- [ ] 配置 Service Worker（PWA）
- [ ] 实施关键资源预加载

### 后端优化检查

- [ ] 数据库查询优化和索引
- [ ] 实施多层缓存策略
- [ ] API 响应压缩
- [ ] 连接池配置优化
- [ ] 批量操作替代单次操作
- [ ] 异步处理重任务
- [ ] 实施限流和熔断

### 监控检查

- [ ] 核心 Web Vitals 监控
- [ ] 服务器性能指标收集
- [ ] 数据库性能监控
- [ ] 缓存命中率监控
- [ ] 错误率和响应时间告警
- [ ] 用户体验指标追踪

## 8. 开发约束

- 所有列表组件超过 100 项必须实施虚拟滚动
- API 响应时间目标：95% < 1 秒，99% < 3 秒
- 页面首屏加载时间 < 2.5 秒
- JavaScript 包总大小 < 1MB
- 图片必须使用 Next.js Image 组件
- 数据库查询必须添加适当索引
- 缓存策略必须考虑数据一致性
- 性能指标必须持续监控和告警
