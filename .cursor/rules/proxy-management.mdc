---
description: 代理资源管理 API 规范（配置/路由/负载均衡/故障转移/监控）
globs:
  - "app/api/**"
  - "app/follow/sources/**"
alwaysApply: true
---

# Oak Research - 代理资源管理 API 规范

本规范定义代理资源的管理方式、API 设计、负载均衡策略与故障转移机制，确保爬虫和外部请求的稳定性。

## 1. 代理资源模型

### 数据结构

```ts
interface Proxy {
  id: string;
  label: string; // 代理标识名
  endpoint: string; // ip:port 或 http(s)://...
  region?: string; // 地区标识
  type: ProxyType; // HTTP | HTTPS | SOCKS5
  auth?: ProxyAuth; // 认证信息
  status: ProxyStatus; // ACTIVE | INACTIVE | ERROR
  metrics: ProxyMetrics; // 性能指标
  createdAt: Date;
  updatedAt: Date;
}

enum ProxyType {
  HTTP = "HTTP",
  HTTPS = "HTTPS",
  SOCKS5 = "SOCKS5",
}

enum ProxyStatus {
  ACTIVE = "ACTIVE",
  INACTIVE = "INACTIVE",
  ERROR = "ERROR",
}

interface ProxyAuth {
  username?: string;
  password?: string;
}

interface ProxyMetrics {
  latency: number; // 平均延迟 (ms)
  successRate: number; // 成功率 0-1
  lastChecked: Date; // 最后检查时间
  errorCount: number; // 错误计数
}
```

## 2. API 端点设计

### 代理管理

```ts
// 获取代理列表
GET /api/follow/proxy
Query: { region?, type?, status?, page?, limit? }
Response: { items: Proxy[], total: number, page: number }

// 创建代理
POST /api/follow/proxy
Body: { label: string, endpoint: string, type: ProxyType, region?: string, auth?: ProxyAuth }
Response: { success: boolean, data: Proxy }

// 更新代理
PATCH /api/follow/proxy/:id
Body: Partial<Proxy>
Response: { success: boolean, data: Proxy }

// 删除代理
DELETE /api/follow/proxy/:id
Response: { success: boolean }

// 测试代理连通性
POST /api/follow/proxy/:id/test
Response: { success: boolean, latency: number, error?: string }
```

### 代理选择与分配

```ts
// 获取可用代理
GET /api/follow/proxy/available
Query: { region?, type?, excludeIds?: string[] }
Response: { data: Proxy[] }

// 批量健康检查
POST /api/follow/proxy/health-check
Body: { proxyIds?: string[] } // 为空则检查所有
Response: { results: { id: string, status: ProxyStatus, latency: number }[] }
```

## 3. 代理选择策略

### 负载均衡算法

```ts
enum BalanceStrategy {
  ROUND_ROBIN = "ROUND_ROBIN", // 轮询
  LEAST_CONNECTIONS = "LEAST_CONN", // 最少连接
  FASTEST_RESPONSE = "FASTEST", // 最快响应
  RANDOM = "RANDOM", // 随机
}

interface ProxySelector {
  selectProxy(options: {
    strategy: BalanceStrategy;
    region?: string;
    excludeIds?: string[];
    requireAuth?: boolean;
  }): Promise<Proxy | null>;
}
```

### 实现示例

```ts
class ProxyManager {
  private activeProxies = new Map<string, Proxy>();
  private connectionCounts = new Map<string, number>();

  async selectProxy(
    strategy: BalanceStrategy,
    filters: ProxyFilters = {}
  ): Promise<Proxy | null> {
    const candidates = await this.getAvailableProxies(filters);

    if (!candidates.length) return null;

    switch (strategy) {
      case BalanceStrategy.ROUND_ROBIN:
        return this.roundRobinSelect(candidates);
      case BalanceStrategy.LEAST_CONNECTIONS:
        return this.leastConnectionsSelect(candidates);
      case BalanceStrategy.FASTEST_RESPONSE:
        return this.fastestResponseSelect(candidates);
      default:
        return candidates[Math.floor(Math.random() * candidates.length)];
    }
  }

  private async getAvailableProxies(filters: ProxyFilters): Promise<Proxy[]> {
    return this.activeProxies
      .values()
      .filter(
        (proxy) =>
          proxy.status === ProxyStatus.ACTIVE &&
          (!filters.region || proxy.region === filters.region) &&
          (!filters.excludeIds || !filters.excludeIds.includes(proxy.id))
      );
  }
}
```

## 4. 故障转移机制

### 健康检查

```ts
interface HealthChecker {
  checkProxy(proxy: Proxy): Promise<HealthResult>;
  scheduleHealthCheck(): void;
}

interface HealthResult {
  status: ProxyStatus;
  latency: number;
  error?: string;
  timestamp: Date;
}

// 定期健康检查 (每 5 分钟)
const healthChecker = new HealthChecker();
setInterval(() => {
  healthChecker.scheduleHealthCheck();
}, 5 * 60 * 1000);
```

### 自动故障转移

```ts
class ProxyFailover {
  private retryAttempts = 3;
  private retryDelay = 1000; // 1s

  async executeWithFailover<T>(
    operation: (proxy: Proxy) => Promise<T>,
    options: FailoverOptions = {}
  ): Promise<T> {
    const maxRetries = options.maxRetries ?? this.retryAttempts;
    const excludeIds: string[] = [];

    for (let attempt = 0; attempt < maxRetries; attempt++) {
      const proxy = await this.proxyManager.selectProxy(
        BalanceStrategy.FASTEST_RESPONSE,
        { excludeIds }
      );

      if (!proxy) throw new Error("No available proxy");

      try {
        const result = await this.executeWithTimeout(
          operation,
          proxy,
          options.timeout
        );
        await this.recordSuccess(proxy);
        return result;
      } catch (error) {
        await this.recordFailure(proxy, error);
        excludeIds.push(proxy.id);

        if (attempt < maxRetries - 1) {
          await this.delay(this.retryDelay * (attempt + 1));
        }
      }
    }

    throw new Error(`All proxy attempts failed after ${maxRetries} retries`);
  }
}
```

## 5. 在爬虫中的使用

### Fetch 配置

```ts
interface FetchWithProxyOptions {
  url: string;
  options?: RequestInit;
  proxyOptions?: {
    region?: string;
    requireAuth?: boolean;
    timeout?: number;
  };
}

async function fetchWithProxy({
  url,
  options,
  proxyOptions,
}: FetchWithProxyOptions) {
  const proxy = await proxyManager.selectProxy(
    BalanceStrategy.FASTEST_RESPONSE,
    proxyOptions
  );

  if (!proxy) {
    throw new Error("No available proxy for request");
  }

  const proxyAgent = new HttpsProxyAgent({
    host: proxy.endpoint.split(":")[0],
    port: parseInt(proxy.endpoint.split(":")[1]),
    auth: proxy.auth
      ? `${proxy.auth.username}:${proxy.auth.password}`
      : undefined,
  });

  return fetch(url, {
    ...options,
    agent: proxyAgent,
    timeout: proxyOptions?.timeout ?? 10000,
  });
}
```

### 爬虫任务中的使用

```ts
// apps/worker/src/crawlers/web-crawler.ts
import { fetchWithProxy } from "@/lib/proxy";

class WebCrawler {
  async crawlWebsite(source: WebSource): Promise<CrawlResult> {
    try {
      const response = await fetchWithProxy({
        url: source.url,
        proxyOptions: {
          region: source.preferredRegion,
          timeout: 15000,
        },
      });

      return this.parseResponse(response);
    } catch (error) {
      this.logger.error(`Crawl failed for ${source.url}:`, error);
      throw error;
    }
  }
}
```

## 6. 监控与指标

### 性能指标收集

```ts
interface ProxyMetricsCollector {
  recordRequest(proxyId: string, latency: number, success: boolean): void;
  getMetrics(proxyId: string, timeRange?: TimeRange): ProxyMetrics;
  getGlobalMetrics(): GlobalProxyMetrics;
}

interface GlobalProxyMetrics {
  totalRequests: number;
  successRate: number;
  averageLatency: number;
  activeProxies: number;
  proxyDistribution: Record<string, number>; // 按地区分布
}
```

### 告警机制

```ts
class ProxyAlertManager {
  checkAlerts(): void {
    const metrics = this.metricsCollector.getGlobalMetrics();

    // 成功率过低告警
    if (metrics.successRate < 0.8) {
      this.sendAlert("LOW_SUCCESS_RATE", {
        current: metrics.successRate,
        threshold: 0.8,
      });
    }

    // 可用代理数过少告警
    if (metrics.activeProxies < 3) {
      this.sendAlert("LOW_PROXY_COUNT", {
        current: metrics.activeProxies,
        minimum: 3,
      });
    }

    // 平均延迟过高告警
    if (metrics.averageLatency > 5000) {
      this.sendAlert("HIGH_LATENCY", {
        current: metrics.averageLatency,
        threshold: 5000,
      });
    }
  }
}
```

## 7. 配置管理

### 环境变量

```bash
# 代理配置
PROXY_HEALTH_CHECK_INTERVAL=300000  # 5分钟
PROXY_REQUEST_TIMEOUT=10000         # 10秒
PROXY_MAX_RETRIES=3
PROXY_RETRY_DELAY=1000

# 负载均衡
DEFAULT_BALANCE_STRATEGY=FASTEST_RESPONSE
ENABLE_FAILOVER=true
MAX_CONNECTIONS_PER_PROXY=10
```

### 动态配置

```ts
interface ProxyConfig {
  balanceStrategy: BalanceStrategy;
  healthCheckInterval: number;
  requestTimeout: number;
  maxRetries: number;
  retryDelay: number;
  enableFailover: boolean;
}

// 支持运行时配置更新
const proxyConfig = new ConfigManager<ProxyConfig>("proxy");
```

## 8. 安全考虑

### 认证信息保护

- 代理认证信息必须加密存储
- API 响应中不返回敏感认证数据
- 使用环境变量管理默认代理配置

### 访问控制

- 代理管理接口需要管理员权限
- 代理使用日志记录与审计
- 限制代理配置的修改频率

## 9. 开发约束

- 所有外部请求必须支持代理配置
- 代理选择逻辑必须可配置和可测试
- 健康检查必须异步执行，不影响主业务
- 故障转移必须透明，对上层调用者无感知
- Cursor 生成爬虫代码时必须集成代理支持
