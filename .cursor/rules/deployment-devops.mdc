---
description: 部署与运维规范（Docker/容器化/环境管理/监控/CI-CD/备份策略）
globs:
  - "docker*"
  - "k8s/**"
  - ".github/**"
  - "scripts/**"
alwaysApply: true
---

# Oak Research - 部署与运维规范

本规范定义应用的容器化、部署流程、环境管理、监控告警与备份策略，确保系统在生产环境中的稳定运行。

## 1. 容器化策略

### Docker 配置

```dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Dependencies
FROM base AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production

# Builder
FROM base AS builder
WORKDIR /app
COPY . .
COPY --from=deps /app/node_modules ./node_modules
RUN npm run build

# Runner
FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs
EXPOSE 3000
ENV PORT=3000

CMD ["node", "server.js"]
```

### Docker Compose 开发环境

```yaml
# docker-compose.dev.yml
version: "3.8"

services:
  app:
    build:
      context: .
      target: builder
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/oakresearch
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - postgres
      - redis

  postgres:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_DB: oakresearch
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init.sql

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  worker:
    build:
      context: .
      target: builder
    environment:
      - NODE_ENV=development
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/oakresearch
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - postgres
      - redis
    command: ["npm", "run", "worker:dev"]

volumes:
  postgres_data:
  redis_data:
```

## 2. 生产环境部署

### Docker Compose 生产配置

```yaml
# docker-compose.prod.yml
version: "3.8"

services:
  app:
    image: oakresearch:${VERSION}
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
      - JWT_SECRET=${JWT_SECRET}
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  worker:
    image: oakresearch:${VERSION}
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_URL=${REDIS_URL}
    command: ["npm", "run", "worker:start"]
    depends_on:
      - postgres
      - redis

  postgres:
    image: pgvector/pgvector:pg16
    restart: unless-stopped
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - app

volumes:
  postgres_data:
  redis_data:
```

## 3. 环境管理

### 环境分离策略

```bash
# 开发环境
NODE_ENV=development
LOG_LEVEL=debug
DATABASE_URL=postgresql://localhost:5432/oakresearch_dev

# 测试环境
NODE_ENV=test
LOG_LEVEL=info
DATABASE_URL=postgresql://localhost:5432/oakresearch_test

# 生产环境
NODE_ENV=production
LOG_LEVEL=warn
DATABASE_URL=${PROD_DATABASE_URL}
```

### 配置管理

```ts
// config/environment.ts
interface EnvironmentConfig {
  nodeEnv: "development" | "test" | "production";
  port: number;
  database: {
    url: string;
    ssl: boolean;
    maxConnections: number;
  };
  redis: {
    url: string;
    password?: string;
  };
  security: {
    jwtSecret: string;
    corsOrigins: string[];
  };
}

export const config: EnvironmentConfig = {
  nodeEnv: (process.env.NODE_ENV as any) || "development",
  port: parseInt(process.env.PORT || "3000"),
  database: {
    url: process.env.DATABASE_URL!,
    ssl: process.env.NODE_ENV === "production",
    maxConnections: parseInt(process.env.DB_MAX_CONNECTIONS || "10"),
  },
  redis: {
    url: process.env.REDIS_URL!,
    password: process.env.REDIS_PASSWORD,
  },
  security: {
    jwtSecret: process.env.JWT_SECRET!,
    corsOrigins: process.env.CORS_ORIGINS?.split(",") || [
      "http://localhost:3000",
    ],
  },
};
```

## 4. 健康检查与监控

### 健康检查端点

```ts
// app/api/health/route.ts
export async function GET() {
  const checks = await Promise.allSettled([
    checkDatabase(),
    checkRedis(),
    checkExternalServices(),
  ]);

  const results = checks.map((check, index) => ({
    service: ["database", "redis", "external"][index],
    status: check.status === "fulfilled" ? "healthy" : "unhealthy",
    error: check.status === "rejected" ? check.reason.message : null,
  }));

  const isHealthy = results.every((r) => r.status === "healthy");

  return Response.json(
    {
      status: isHealthy ? "healthy" : "unhealthy",
      timestamp: new Date().toISOString(),
      checks: results,
    },
    {
      status: isHealthy ? 200 : 503,
    }
  );
}
```

### 监控配置

```yaml
# monitoring/docker-compose.yml
version: "3.8"

services:
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus

  grafana:
    image: grafana/grafana
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards

  alertmanager:
    image: prom/alertmanager
    ports:
      - "9093:9093"
    volumes:
      - ./alertmanager.yml:/etc/alertmanager/alertmanager.yml

volumes:
  prometheus_data:
  grafana_data:
```

## 5. 备份策略

### 数据库备份

```bash
#!/bin/bash
# scripts/backup-db.sh

DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
DB_NAME="oakresearch"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 数据库备份
pg_dump $DATABASE_URL | gzip > $BACKUP_DIR/db_backup_$DATE.sql.gz

# 清理超过7天的备份
find $BACKUP_DIR -name "db_backup_*.sql.gz" -mtime +7 -delete

echo "Database backup completed: db_backup_$DATE.sql.gz"
```

### 自动备份 Cron

```bash
# 每天凌晨2点执行备份
0 2 * * * /app/scripts/backup-db.sh >> /var/log/backup.log 2>&1

# 每周日凌晨3点执行完整备份
0 3 * * 0 /app/scripts/full-backup.sh >> /var/log/backup.log 2>&1
```

## 6. CI/CD 流程

### GitHub Actions 配置

```yaml
# .github/workflows/deploy.yml
name: Deploy to Production

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm run test

      - name: Run E2E tests
        run: npm run test:e2e

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Deploy to production
        run: |
          echo "Deploying version ${{ github.sha }}"
          # 实际部署逻辑
```

## 7. 日志管理

### 结构化日志

```ts
// lib/logger.ts
import winston from "winston";

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
    new winston.transports.File({
      filename: "logs/error.log",
      level: "error",
    }),
    new winston.transports.File({
      filename: "logs/combined.log",
    }),
  ],
});

export default logger;
```

### 日志轮转配置

```bash
# /etc/logrotate.d/oakresearch
/app/logs/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 0644 nodejs nodejs
    postrotate
        systemctl reload oakresearch
    endscript
}
```

## 8. 安全配置

### Nginx 配置

```nginx
# nginx/nginx.conf
upstream app {
    server app:3000;
}

server {
    listen 80;
    server_name your-domain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name your-domain.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;

    # Security headers
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains";

    location / {
        proxy_pass http://app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location /api/health {
        proxy_pass http://app;
        access_log off;
    }
}
```

## 9. 部署脚本

### 部署自动化

```bash
#!/bin/bash
# scripts/deploy.sh

set -e

VERSION=${1:-latest}
ENV=${2:-production}

echo "Deploying version $VERSION to $ENV environment..."

# 拉取最新镜像
docker-compose -f docker-compose.prod.yml pull

# 执行数据库迁移
docker-compose -f docker-compose.prod.yml run --rm app npm run db:migrate

# 滚动更新
docker-compose -f docker-compose.prod.yml up -d --no-deps app worker

# 健康检查
echo "Waiting for services to be ready..."
sleep 30

# 验证部署
if curl -f http://localhost:3000/api/health; then
    echo "Deployment successful!"
else
    echo "Deployment failed! Rolling back..."
    docker-compose -f docker-compose.prod.yml rollback
    exit 1
fi
```

## 10. 开发约束

- 所有服务必须提供健康检查端点
- 生产环境必须使用容器化部署
- 敏感配置通过环境变量管理
- 数据库迁移必须在部署前执行
- 必须实施自动备份和监控
- 部署流程必须包含回滚机制
