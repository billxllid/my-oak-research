---
description: 数据获取与缓存规范（SWR/Fetcher/错误重试/占位骨架/乐观更新/标签化缓存/示例）
globs:
  - "apps/web/**"
  - "packages/**"
alwaysApply: true
---

# Oak Research - 数据获取与缓存规范

本规范统一 SWR 数据获取、全局 fetcher、错误与重试、乐观更新、骨架屏、与服务器端 revalidate 的配合方式，确保前端数据一致性与用户体验。

## 1. SWR 基础配置

- 在 `apps/web/app/providers.tsx` 中配置全局 SWR：

```tsx
<SWRConfig
  value={{
    fetcher: apiFetcher,
    errorRetryCount: 2,
    errorRetryInterval: 2000,
    revalidateOnFocus: false,
    revalidateOnReconnect: true,
    shouldRetryOnError: (err) => err?.status !== 401 && err?.status !== 403,
  }}
>
  {children}
</SWRConfig>
```

## 2. 全局 Fetcher

- 统一放在 `apps/web/lib/fetcher.ts`

```ts
export async function apiFetcher(input: string | URL, init?: RequestInit) {
  const res = await fetch(input, { ...init, credentials: "include" });
  const json = await res.json().catch(() => ({}));
  if (!res.ok || json?.success === false) {
    const err = {
      status: res.status,
      code: json?.error?.code ?? "INTERNAL",
      message: json?.error?.message ?? "Request failed",
    };
    throw err;
  }
  return json?.data ?? json;
}
```

- 仅接受 `{ success: true }` 分支；错误统一抛出，由 SWR 或调用处处理

## 3. Key 组织与依赖

- Key 使用数组：`useSWR(["/api/focus-bulletin/content", params])`
- 过滤条件对象必须稳定（序列化或使用 `useMemo`）
- 级联：父 Key 变化时，子 Key 自动失效

## 4. 加载与骨架

- 列表页：使用骨架组件（SkeletonCard/SkeletonTable）
- 空态：统一 Empty 组件（含“刷新/清空筛选”按钮）
- 加载状态与错误状态必须明确区分

## 5. 错误与重试

- SWR 全局配置控制重试；401/403 不重试
- 组件内捕获错误后：

  - 弹出 toast：`toast.error(err.message)`
  - 给出重试按钮：`mutate()` 或 `revalidate()`（SWR v2）

- 频繁失败的接口给出“降级提示”文案

## 6. 乐观更新与回滚

- 使用 `mutate(key, updater, { optimisticData, rollbackOnError: true })`
- 适用于收藏、点赞、名称变更等轻量写操作
- 服务端失败则自动回滚并提示

## 7. 分页与无限滚动

- 分页列表：`/api/... ?page=1&limit=20`，Key 包含页码
- 无限滚动：使用 `useSWRInfinite`，Key 为 `getKey(pageIndex, prevPage)`
- 返回 `meta.nextCursor` 时优先 Cursor 模式；否则 page 模式

## 8. 与 Server Actions 协作

- 写操作由 Action 完成后，前端调用 `mutate(listKey)` 或 `router.refresh()`
- 服务端使用 `revalidatePath("/...")` 或 `revalidateTag("...")` 与前端 SWR 配合
- 建议列表类页面使用 tag 化缓存（由服务端控制片段新鲜度）

## 9. 选择器与派生状态

- 大列表中避免在渲染时做复杂计算，使用 memoized selector：

```ts
const items = useMemo(() => data?.rows?.filter(...), [data, filters]);
```

- 搜索输入使用 `debounce`（300–500ms）

## 10. 统一 Hook 封装

- 在 `apps/web/hooks/` 封装资源级 Hook，隐藏 URL 细节：

```ts
export function useFocusContent(params) {
  return useSWR(["/api/focus-bulletin/content", params], ([url, p]) =>
    apiFetcher(`${url}?${new URLSearchParams(p)}`)
  );
}
```

- 复用：页面仅管渲染与交互

## 11. 文件上传与长任务

- 上传使用 `fetch` + `FormData`，进度通过 `XMLHttpRequest` 或专用组件
- 长任务（LLM 生成/向量化）：前端轮询 `GET /api/task/:id` 或使用 SSE/WebSocket（后续扩展）
- 显示进度条与“可中断”UI

## 12. 安全与合规

- 前端禁止记录或缓存敏感字段（密钥、Cookie、Tokens）
- API 调用仅携带必要参数，避免在 URL 中放 PII
- 错误对象不包含敏感信息；仅展示简化 message

## 13. 示例：关注内容列表

```ts
type ContentQuery = {
  page?: number;
  limit?: number;
  platform?: string;
  from?: string;
  to?: string;
  q?: string;
};

export function useFocusContent(query: ContentQuery = { page: 1, limit: 20 }) {
  return useSWR(["/api/focus-bulletin/content", query], async ([url, q]) => {
    const u = new URL(
      url,
      typeof window === "undefined"
        ? "http://localhost"
        : window.location.origin
    );
    Object.entries(q).forEach(([k, v]) => {
      if (v != null && v !== "") u.searchParams.set(k, String(v));
    });
    return apiFetcher(u.toString());
  });
}
```

## 14. 示例：乐观收藏

```ts
export function useToggleFavorite() {
  const key = ["/api/library/favorites"];
  return async function toggle(id: string, next: boolean) {
    await mutate(
      key,
      async (prev: any) => {
        const optimistic = next
          ? { ...prev, items: [{ id, favored: true }, ...(prev?.items ?? [])] }
          : {
              ...prev,
              items: (prev?.items ?? []).filter((x: any) => x.id !== id),
            };
        // fire & forget
        fetch("/api/focus-bulletin/favorites", {
          method: next ? "POST" : "DELETE",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ contentId: id }),
        }).catch(() => {});
        return optimistic;
      },
      { revalidate: true, rollbackOnError: true }
    );
  };
}
```

## 15. 性能建议

- 对大型列表开启虚拟滚动（未来引入 react-virtualized/virtuoso）
- 图表数据做降采样与预聚合
- 合理利用 Suspense + streaming（Server Components）减少 TTFB

## 16. 测试

- Hook 级单测：成功/失败/重试/乐观回滚
- 组件级：骨架/空态/错误态渲染正确
- E2E：筛选条件与分页串联正确
