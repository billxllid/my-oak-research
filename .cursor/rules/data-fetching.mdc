---
description: 数据获取与缓存规范（React Query/Fetcher/错误重试/占位骨架/乐观更新/标签化缓存/示例）
globs:
  - "apps/web/**"
  - "packages/**"
alwaysApply: true
---

# Oak Research - 数据获取与缓存规范

本规范统一 React Query 数据获取、全局 fetcher、错误与重试、乐观更新、骨架屏、与服务器端 revalidate 的配合方式，确保前端数据一致性与用户体验。

## 1. React Query 基础配置

- 在 `app/QueryClientProvider.tsx` 中配置全局 React Query：

```tsx
"use client";

import React from "react";
import {
  QueryClient,
  QueryClientProvider as ReactQueryClientProvider,
} from "@tanstack/react-query";

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 2,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      staleTime: 1000 * 60 * 5, // 5 minutes
    },
    mutations: {
      retry: 1,
      onError: (err: any) => {
        // 401/403 不重试
        if (err?.status === 401 || err?.status === 403) {
          return false;
        }
      },
    },
  },
});

const QueryClientProvider = ({ children }: { children: React.ReactNode }) => {
  return (
    <ReactQueryClientProvider client={queryClient}>
      {children}
    </ReactQueryClientProvider>
  );
};

export default QueryClientProvider;
```

## 2. 全局 Fetcher

- 统一放在 `lib/fetcher.ts`

```ts
export async function apiFetcher(input: string | URL, init?: RequestInit) {
  const res = await fetch(input, { ...init, credentials: "include" });
  const json = await res.json().catch(() => ({}));
  if (!res.ok || json?.success === false) {
    const err = {
      status: res.status,
      code: json?.error?.code ?? "INTERNAL",
      message: json?.error?.message ?? "Request failed",
    };
    throw err;
  }
  return json?.data ?? json;
}
```

- 仅接受 `{ success: true }` 分支；错误统一抛出，由 React Query 处理

## 3. Query Key 组织与依赖

- Query Key 使用数组：`useQuery({ queryKey: ["/api/follow/sources", "DARKNET"] })`
- 过滤条件对象必须稳定（序列化或使用 `useMemo`）
- 级联：父 Key 变化时，子 Key 自动失效

## 4. 加载与骨架

- 列表页：使用骨架组件（SkeletonCard/SkeletonTable）
- 空态：统一 Empty 组件（含“刷新/清空筛选”按钮）
- 加载状态与错误状态必须明确区分

## 5. 错误与重试

- React Query 全局配置控制重试；401/403 不重试
- 组件内捕获错误后：

  - 弹出 toast：`toast.error(err.message)`
  - 给出重试按钮：`refetch()` 或 `queryClient.invalidateQueries()`

- 频繁失败的接口给出"降级提示"文案

## 6. 乐观更新与回滚

- 使用 `useMutation` 的 `onMutate` 进行乐观更新
- 在 `onError` 中进行回滚：`queryClient.setQueryData(queryKey, previousData)`
- 适用于收藏、点赞、名称变更等轻量写操作
- 服务端失败则自动回滚并提示

## 7. 分页与无限滚动

- 分页列表：`/api/... ?page=1&limit=20`，Query Key 包含页码
- 无限滚动：使用 `useInfiniteQuery`，`getNextPageParam` 返回下一页参数
- 返回 `meta.nextCursor` 时优先 Cursor 模式；否则 page 模式

## 8. 与 Server Actions 协作

- 写操作由 Mutation 完成后，前端调用 `queryClient.invalidateQueries()`
- 服务端使用 `revalidatePath("/...")` 或 `revalidateTag("...")` 与前端协作
- 建议列表类页面使用 tag 化缓存（由服务端控制片段新鲜度）

## 9. 选择器与派生状态

- 大列表中避免在渲染时做复杂计算，使用 React Query 的 `select` 选项：

```ts
const { data: filteredItems } = useQuery({
  queryKey: ["sources", "DARKNET"],
  queryFn: fetchSources,
  select: (data) => data?.filter((item) => item.active) || [],
});
```

- 搜索输入使用 `debounce`（300–500ms）

## 10. 统一 Hook 封装

- 在 `hooks/` 封装资源级 Hook，隐藏 URL 细节：

```ts
export function useSources(type?: string) {
  return useQuery({
    queryKey: ["sources", type],
    queryFn: () =>
      apiFetcher(`/api/follow/sources${type ? `?type=${type}` : ""}`),
  });
}
```

- 复用：页面仅管渲染与交互

## 11. 文件上传与长任务

- 上传使用 `fetch` + `FormData`，进度通过 `XMLHttpRequest` 或专用组件
- 长任务（LLM 生成/向量化）：前端轮询 `GET /api/task/:id` 或使用 SSE/WebSocket（后续扩展）
- 显示进度条与“可中断”UI

## 12. 安全与合规

- 前端禁止记录或缓存敏感字段（密钥、Cookie、Tokens）
- API 调用仅携带必要参数，避免在 URL 中放 PII
- 错误对象不包含敏感信息；仅展示简化 message

## 13. 示例：关注内容列表

```ts
type ContentQuery = {
  page?: number;
  limit?: number;
  platform?: string;
  from?: string;
  to?: string;
  q?: string;
};

export function useFocusContent(query: ContentQuery = { page: 1, limit: 20 }) {
  return useQuery({
    queryKey: ["/api/focus-bulletin/content", query],
    queryFn: async () => {
      const u = new URL(
        "/api/focus-bulletin/content",
        typeof window === "undefined"
          ? "http://localhost"
          : window.location.origin
      );
      Object.entries(query).forEach(([k, v]) => {
        if (v != null && v !== "") u.searchParams.set(k, String(v));
      });
      return apiFetcher(u.toString());
    },
  });
}
```

## 14. 示例：乐观收藏

```ts
export function useToggleFavorite() {
  const queryClient = useQueryClient();
  const queryKey = ["/api/library/favorites"];

  return useMutation({
    mutationFn: async ({ id, next }: { id: string; next: boolean }) => {
      const response = await fetch("/api/focus-bulletin/favorites", {
        method: next ? "POST" : "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ contentId: id }),
      });
      if (!response.ok) throw new Error("Failed to toggle favorite");
      return response.json();
    },
    onMutate: async ({ id, next }) => {
      // 取消正在进行的查询
      await queryClient.cancelQueries({ queryKey });

      // 获取之前的数据
      const previousData = queryClient.getQueryData(queryKey);

      // 乐观更新
      queryClient.setQueryData(queryKey, (old: any) => {
        if (!old) return old;
        const optimistic = next
          ? { ...old, items: [{ id, favored: true }, ...(old?.items ?? [])] }
          : {
              ...old,
              items: (old?.items ?? []).filter((x: any) => x.id !== id),
            };
        return optimistic;
      });

      return { previousData };
    },
    onError: (err, variables, context) => {
      // 回滚
      if (context?.previousData) {
        queryClient.setQueryData(queryKey, context.previousData);
      }
    },
    onSettled: () => {
      // 重新获取数据
      queryClient.invalidateQueries({ queryKey });
    },
  });
}
```

## 15. 性能建议

- 对大型列表开启虚拟滚动（未来引入 react-virtualized/virtuoso）
- 图表数据做降采样与预聚合
- 合理利用 Suspense + streaming（Server Components）减少 TTFB

## 16. 测试

- Hook 级单测：成功/失败/重试/乐观回滚，使用 `@testing-library/react-hooks` + `QueryClient` mock
- 组件级：骨架/空态/错误态渲染正确，包装组件在 `QueryClientProvider` 中
- E2E：筛选条件与分页串联正确

## 17. 开发约束

- 禁止在组件内直接使用 `fetch`，必须通过 React Query
- 新增资源必须定义对应的 Hook
- 所有写操作必须使用 `useMutation`
- Cursor 生成数据获取代码时，必须自动使用 React Query 模式
