---
description: Next.js 15 API 路由设计规范（返回结构/错误码/分页/鉴权/速率限制/版本化/示例）
globs:
  - "apps/web/app/api/**"
  - "apps/worker/**"
alwaysApply: true
---

# Oak Research - API 路由设计规范

本规范约束 Next.js 15 App Router 下的 API 端点编写方式，覆盖统一响应结构、错误码、分页、鉴权、速率限制、输入校验与版本化等。目标：稳定可观测、前后端强约束、易于在 React Query/Server Actions 中复用。

## 1. 目录与命名

所有 API 放在 `apps/web/app/api/`，按资源分包：

```

apps/web/app/api/
├── dashboard/
│   ├── top-keywords/route.ts
│   └── trends/route.ts
├── focus-bulletin/
│   ├── content/route.ts
│   ├── favorites/route.ts
│   └── config/
│       ├── keywords/route.ts
│       ├── categories/route.ts
│       ├── platforms/route.ts
│       ├── sites/route.ts
│       ├── search-engines/route.ts
│       ├── proxies/route.ts
│       └── ai/route.ts
├── report-writer/
│   ├── templates/route.ts
│   ├── reports/route.ts
│   └── generate/route.ts
├── library/
│   ├── knowledge/route.ts
│   ├── favorites/route.ts
│   └── retrieve/route.ts
├── admin/
│   ├── users/route.ts
│   ├── roles/route.ts
│   └── logs/
│       ├── system/route.ts
│       ├── action/route.ts
│       └── push/route.ts
└── ai/
├── keywords/derive/route.ts
└── content/
├── clean/route.ts
└── summary/route.ts

```

子资源 ID 场景采用 `PATCH /:id` `DELETE /:id` 写在同一 `route.ts` 内，通过 `request.url` 解析查询参数或路径段。

## 2. 统一响应结构

所有端点返回以下 Envelope（Content-Type: `application/json`）：

```ts
type ApiSuccess<T> = { success: true; data: T; error: null; meta?: Meta };
type ApiFailure = { success: false; data: null; error: ApiError; meta?: Meta };

type Meta = {
  page?: number;
  limit?: number;
  total?: number;
  nextCursor?: string; // cursor 分页可选
  durationMs?: number;
  requestId?: string;
  version?: string;
};

type ApiError = {
  code: ErrCode; // 规范化错误码
  message: string; // 面向用户/前端的简明错误
  details?: Record<string, any>; // 可序列化调试信息（不含敏感）
};

type ErrCode =
  | "OK"
  | "BAD_REQUEST"
  | "UNAUTHORIZED"
  | "FORBIDDEN"
  | "NOT_FOUND"
  | "CONFLICT"
  | "RATE_LIMITED"
  | "UNPROCESSABLE"
  | "INTERNAL"
  | "DEPENDENCY_FAIL";
```

React Query 只读取 `success` 与 `data`，错误分支统一用 `error.code` + `error.message` 呈现。

## 3. 输入校验（Zod）与 DTO

每个路由需为 Query 与 Body 定义 Zod Schema，并导出 DTO 类型，禁止以 any 透传：

```ts
import { z } from "zod";

export const PaginateQuery = z.object({
  page: z.coerce.number().int().min(1).default(1),
  limit: z.coerce.number().int().min(1).max(100).default(20),
  search: z.string().max(200).optional(),
});

export const CreateKeywordDto = z.object({
  name: z.string().min(1).max(50),
  categoryId: z.string().uuid().optional(),
  derive: z.boolean().default(false),
});
export type TCreateKeywordDto = z.infer<typeof CreateKeywordDto>;
```

校验失败返回：

```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "BAD_REQUEST",
    "message": "Invalid payload",
    "details": {
      /* zod issues */
    }
  }
}
```

## 4. 方法语义

- `GET /resource` 列表/读取，支持分页与筛选
- `POST /resource` 新建
- `PATCH /resource/:id` 局部更新
- `DELETE /resource/:id` 删除
- 特殊动作（生成/派生/上传）使用子路径：`POST /report-writer/generate`、`POST /ai/keywords/derive`、`POST /library/knowledge/:id/upload`

## 5. 分页规范

支持两种分页方式，优先 Cursor：

- Cursor：`?cursor=<opaque>&limit=20` 返回 `meta.nextCursor`
- Page：`?page=1&limit=20` 返回 `meta.page/meta.limit/meta.total`
  同一资源保持一种分页策略，列表端点须在 `meta` 带上耗时与版本。

## 6. 鉴权与权限

在 Handler 起始读取 Session/Token（如 `NextAuth` 或自研）：

- 未登录：`UNAUTHORIZED`
- 无权限：`FORBIDDEN`
- 资源不存在或越权：`NOT_FOUND`（避免暴露存在性）
  权限点示例：
- `admin:*` 管理员
- `report:write` 生成/编辑报告
- `focus:config` 关注设置 CRUD
- `logs:view` 查看日志，`logs:push:write` 配置推送

## 7. 速率限制与防刷

对敏感端点开启限流（如 `ai/*`, `report-writer/generate`, `library/retrieve`）：

- 推荐中间件：基于 IP/用户的 Token Bucket（如 upstash 或自建）
- 超限：`RATE_LIMITED`，`Retry-After` 响应头
- 返回带 `meta.durationMs` 便于观测

## 8. 错误处理与依赖降级

- 捕获 Prisma/外部依赖错误并映射为 `DEPENDENCY_FAIL` 或 `INTERNAL`
- 外部依赖（LLM/搜索/对象存储）失败需提供降级路径（如返回占位摘要/提示文案）
- 日志记录 `requestId` 与 error stack（不回传 stack 给前端）

## 9. 版本化与兼容

- URL 版本：`/api/v1/...`（建议在 `app/api/v1/` 下组织）
- `meta.version` 标识当前接口版本
- 重大变更需并行保留旧版本至少一个小版本周期

## 10. 示例端点

关注内容列表：

```ts
// apps/web/app/api/focus-bulletin/content/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { PaginateQuery } from "@/app/api/_schemas";
import { prisma } from "@oak/prisma";
import { withAuth, ok, fail, time } from "@/app/api/_utils";

const FilterQuery = PaginateQuery.extend({
  platform: z.string().optional(),
  from: z.coerce.date().optional(),
  to: z.coerce.date().optional(),
  q: z.string().max(200).optional(),
});

export async function GET(req: NextRequest) {
  return withAuth(req, async (ctx) => {
    const t0 = performance.now();
    const url = new URL(req.url);
    const parse = FilterQuery.safeParse(Object.fromEntries(url.searchParams));
    if (!parse.success)
      return NextResponse.json(
        fail("BAD_REQUEST", "Invalid query", parse.error.flatten()),
        { status: 400 }
      );

    const { page, limit, platform, from, to, q } = parse.data;
    const where: any = {};
    if (platform) where.platform = platform;
    if (from || to)
      where.time = { gte: from ?? undefined, lte: to ?? undefined };
    if (q)
      where.OR = [{ title: { contains: q } }, { summary: { contains: q } }];

    const [total, rows] = await Promise.all([
      prisma.content.count({ where }),
      prisma.content.findMany({
        where,
        orderBy: { time: "desc" },
        skip: (page - 1) * limit,
        take: limit,
      }),
    ]);

    return NextResponse.json(
      ok(rows, { page, limit, total, durationMs: time(t0), version: "v1" })
    );
  });
}
```

关键词派生：

```ts
// apps/web/app/api/ai/keywords/derive/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { ok, fail, withAuth } from "@/app/api/_utils";
import { llmGateway } from "@oak/agents/llm-gateway";
import { redact, stripPromptLike } from "@oak/agents/security";

const Body = z.object({
  keyword: z.string().min(1).max(50),
  options: z
    .object({
      languages: z
        .array(z.enum(["zh", "en", "ja", "ko", "de", "fr"]))
        .default(["en", "ja", "ko", "de", "fr"]),
      synonyms: z.boolean().default(true),
    })
    .default({}),
});

export async function POST(req: NextRequest) {
  return withAuth(req, async () => {
    const json = await req.json().catch(() => ({}));
    const parse = Body.safeParse(json);
    if (!parse.success)
      return NextResponse.json(
        fail("BAD_REQUEST", "Invalid payload", parse.error.flatten()),
        { status: 400 }
      );

    const { keyword, options } = parse.data;
    const prompt = stripPromptLike(
      `基于关键词 "${keyword}" 生成多语言、多表述形式的相关表达，输出 JSON。languages=${options.languages.join(
        ","
      )}, synonyms=${options.synonyms}`
    );
    const out = await llmGateway.json("keyword-derive", {
      prompt: redact({ prompt }),
    });

    return NextResponse.json(ok(out, { version: "v1" }));
  });
}
```

报告生成：

```ts
// apps/web/app/api/report-writer/generate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { z } from "zod";
import { ok, fail, withAuth } from "@/app/api/_utils";
import { retrieve } from "@/app/api/_rag";
import { llmGateway } from "@oak/agents/llm-gateway";
import { ReportSchema } from "@/app/api/_schemas";

const Body = z.object({
  prompt: z.string().min(5).max(2000),
  templateId: z.string().uuid(),
  materialIds: z.array(z.string().uuid()).default([]),
  options: z
    .object({
      model: z.string().optional(),
      temperature: z.number().min(0).max(1).default(0.7),
    })
    .default({}),
});

export async function POST(req: NextRequest) {
  return withAuth(req, async (ctx) => {
    const body = await req.json().catch(() => ({}));
    const parse = Body.safeParse(body);
    if (!parse.success)
      return NextResponse.json(
        fail("BAD_REQUEST", "Invalid payload", parse.error.flatten()),
        { status: 400 }
      );

    const { prompt, templateId, materialIds, options } = parse.data;
    const chunks = await retrieve({ materialIds, topK: 8 }); // RAG
    const draft = await llmGateway.json("report-generate", {
      prompt,
      templateId,
      chunks,
      options,
    });

    const checked = ReportSchema.safeParse(draft);
    if (!checked.success)
      return NextResponse.json(
        fail("UNPROCESSABLE", "Model output invalid", checked.error.flatten()),
        { status: 422 }
      );

    // persist report draft ...
    return NextResponse.json(ok(checked.data, { version: "v1" }));
  });
}
```

## 11. 公共工具与中间件

放在 `apps/web/app/api/_utils.ts`：

```ts
import { NextRequest, NextResponse } from "next/server";
export const ok = <T>(data: T, meta?: any) => ({
  success: true,
  data,
  error: null,
  meta,
});
export const fail = (code: any, message: string, details?: any) => ({
  success: false,
  data: null,
  error: { code, message, details },
});

export async function withAuth(
  req: NextRequest,
  fn: (ctx: { userId: string; roles: string[] }) => Promise<NextResponse>
) {
  const auth = await getSession(req); // 自行实现
  if (!auth)
    return NextResponse.json(fail("UNAUTHORIZED", "Auth required"), {
      status: 401,
    });
  return fn({ userId: auth.user.id, roles: auth.user.roles });
}
export const time = (t0: number) => Math.round(performance.now() - t0);
```

## 12. CORS 与缓存

- 内部前端直连默认不需要跨域；若对外开放只读接口，配置 `OPTIONS` 处理与白名单
- 列表/只读接口可设置短缓存（如 `Cache-Control: private, max-age=15`），React Query 侧配合 `staleTime` 配置

## 13. 日志与可观测性

- 每个响应头加入 `x-request-id`，错误链路写入审计表
- 端点记录：耗时、调用次数、错误分布；关键 AI 端点记录模型路由与 tokens 统计
- 与“系统管理/日志管理”模块打通，提供可检索与告警能力

## 14. 测试约定

- 单测：每个端点需包含参数校验、权限校验、成功用例、失败用例
- E2E：登录后调用真实端点，校验 Envelope 与重要字段
- Mock 外部依赖（LLM/向量库/对象存储），仅保留契约

## 15. 前端调用约束

- React Query 统一 fetcher：只接受 `{ success: true }` 分支，错误走 toast + 重试
- 表单提交采用 `POST/PATCH`，提交前本地 Zod 校验
- 禁止在前端拼接未脱敏的调试信息上报
